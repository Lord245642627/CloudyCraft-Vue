{"ast":null,"code":"var BoundingRect = require(\"../core/BoundingRect\");\n\nvar imageHelper = require(\"../graphic/helper/image\");\n\nvar _util = require(\"../core/util\");\n\nvar getContext = _util.getContext;\nvar extend = _util.extend;\nvar retrieve2 = _util.retrieve2;\nvar retrieve3 = _util.retrieve3;\nvar trim = _util.trim;\nvar textWidthCache = {};\nvar textWidthCacheCounter = 0;\nvar TEXT_CACHE_MAX = 5000;\nvar STYLE_REG = /\\{([a-zA-Z0-9_]+)\\|([^}]*)\\}/g;\nvar DEFAULT_FONT = '12px sans-serif'; // Avoid assign to an exported variable, for transforming to cjs.\n\nvar methods = {};\n\nfunction $override(name, fn) {\n  methods[name] = fn;\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @return {number} width\n */\n\n\nfunction getWidth(text, font) {\n  font = font || DEFAULT_FONT;\n  var key = text + ':' + font;\n\n  if (textWidthCache[key]) {\n    return textWidthCache[key];\n  }\n\n  var textLines = (text + '').split('\\n');\n  var width = 0;\n\n  for (var i = 0, l = textLines.length; i < l; i++) {\n    // textContain.measureText may be overrided in SVG or VML\n    width = Math.max(measureText(textLines[i], font).width, width);\n  }\n\n  if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n    textWidthCacheCounter = 0;\n    textWidthCache = {};\n  }\n\n  textWidthCacheCounter++;\n  textWidthCache[key] = width;\n  return width;\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @param {string} [textAlign='left']\n * @param {string} [textVerticalAlign='top']\n * @param {Array.<number>} [textPadding]\n * @param {Object} [rich]\n * @param {Object} [truncate]\n * @return {Object} {x, y, width, height, lineHeight}\n */\n\n\nfunction getBoundingRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, rich, truncate) {\n  return rich ? getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, rich, truncate) : getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, truncate);\n}\n\nfunction getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, truncate) {\n  var contentBlock = parsePlainText(text, font, textPadding, textLineHeight, truncate);\n  var outerWidth = getWidth(text, font);\n\n  if (textPadding) {\n    outerWidth += textPadding[1] + textPadding[3];\n  }\n\n  var outerHeight = contentBlock.outerHeight;\n  var x = adjustTextX(0, outerWidth, textAlign);\n  var y = adjustTextY(0, outerHeight, textVerticalAlign);\n  var rect = new BoundingRect(x, y, outerWidth, outerHeight);\n  rect.lineHeight = contentBlock.lineHeight;\n  return rect;\n}\n\nfunction getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, rich, truncate) {\n  var contentBlock = parseRichText(text, {\n    rich: rich,\n    truncate: truncate,\n    font: font,\n    textAlign: textAlign,\n    textPadding: textPadding,\n    textLineHeight: textLineHeight\n  });\n  var outerWidth = contentBlock.outerWidth;\n  var outerHeight = contentBlock.outerHeight;\n  var x = adjustTextX(0, outerWidth, textAlign);\n  var y = adjustTextY(0, outerHeight, textVerticalAlign);\n  return new BoundingRect(x, y, outerWidth, outerHeight);\n}\n/**\n * @public\n * @param {number} x\n * @param {number} width\n * @param {string} [textAlign='left']\n * @return {number} Adjusted x.\n */\n\n\nfunction adjustTextX(x, width, textAlign) {\n  // FIXME Right to left language\n  if (textAlign === 'right') {\n    x -= width;\n  } else if (textAlign === 'center') {\n    x -= width / 2;\n  }\n\n  return x;\n}\n/**\n * @public\n * @param {number} y\n * @param {number} height\n * @param {string} [textVerticalAlign='top']\n * @return {number} Adjusted y.\n */\n\n\nfunction adjustTextY(y, height, textVerticalAlign) {\n  if (textVerticalAlign === 'middle') {\n    y -= height / 2;\n  } else if (textVerticalAlign === 'bottom') {\n    y -= height;\n  }\n\n  return y;\n}\n/**\n * Follow same interface to `Displayable.prototype.calculateTextPosition`.\n * @public\n * @param {Obejct} [out] Prepared out object. If not input, auto created in the method.\n * @param {module:zrender/graphic/Style} style where `textPosition` and `textDistance` are visited.\n * @param {Object} rect {x, y, width, height} Rect of the host elment, according to which the text positioned.\n * @return {Object} The input `out`. Set: {x, y, textAlign, textVerticalAlign}\n */\n\n\nfunction calculateTextPosition(out, style, rect) {\n  var textPosition = style.textPosition;\n  var distance = style.textDistance;\n  var x = rect.x;\n  var y = rect.y;\n  distance = distance || 0;\n  var height = rect.height;\n  var width = rect.width;\n  var halfHeight = height / 2;\n  var textAlign = 'left';\n  var textVerticalAlign = 'top';\n\n  switch (textPosition) {\n    case 'left':\n      x -= distance;\n      y += halfHeight;\n      textAlign = 'right';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'right':\n      x += distance + width;\n      y += halfHeight;\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'top':\n      x += width / 2;\n      y -= distance;\n      textAlign = 'center';\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'bottom':\n      x += width / 2;\n      y += height + distance;\n      textAlign = 'center';\n      break;\n\n    case 'inside':\n      x += width / 2;\n      y += halfHeight;\n      textAlign = 'center';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideLeft':\n      x += distance;\n      y += halfHeight;\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideRight':\n      x += width - distance;\n      y += halfHeight;\n      textAlign = 'right';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideTop':\n      x += width / 2;\n      y += distance;\n      textAlign = 'center';\n      break;\n\n    case 'insideBottom':\n      x += width / 2;\n      y += height - distance;\n      textAlign = 'center';\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'insideTopLeft':\n      x += distance;\n      y += distance;\n      break;\n\n    case 'insideTopRight':\n      x += width - distance;\n      y += distance;\n      textAlign = 'right';\n      break;\n\n    case 'insideBottomLeft':\n      x += distance;\n      y += height - distance;\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'insideBottomRight':\n      x += width - distance;\n      y += height - distance;\n      textAlign = 'right';\n      textVerticalAlign = 'bottom';\n      break;\n  }\n\n  out = out || {};\n  out.x = x;\n  out.y = y;\n  out.textAlign = textAlign;\n  out.textVerticalAlign = textVerticalAlign;\n  return out;\n}\n/**\n * To be removed. But still do not remove in case that some one has imported it.\n * @deprecated\n * @public\n * @param {stirng} textPosition\n * @param {Object} rect {x, y, width, height}\n * @param {number} distance\n * @return {Object} {x, y, textAlign, textVerticalAlign}\n */\n\n\nfunction adjustTextPositionOnRect(textPosition, rect, distance) {\n  var dummyStyle = {\n    textPosition: textPosition,\n    textDistance: distance\n  };\n  return calculateTextPosition({}, dummyStyle, rect);\n}\n/**\n * Show ellipsis if overflow.\n *\n * @public\n * @param  {string} text\n * @param  {string} containerWidth\n * @param  {string} font\n * @param  {number} [ellipsis='...']\n * @param  {Object} [options]\n * @param  {number} [options.maxIterations=3]\n * @param  {number} [options.minChar=0] If truncate result are less\n *                  then minChar, ellipsis will not show, which is\n *                  better for user hint in some cases.\n * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n * @return {string}\n */\n\n\nfunction truncateText(text, containerWidth, font, ellipsis, options) {\n  if (!containerWidth) {\n    return '';\n  }\n\n  var textLines = (text + '').split('\\n');\n  options = prepareTruncateOptions(containerWidth, font, ellipsis, options); // FIXME\n  // It is not appropriate that every line has '...' when truncate multiple lines.\n\n  for (var i = 0, len = textLines.length; i < len; i++) {\n    textLines[i] = truncateSingleLine(textLines[i], options);\n  }\n\n  return textLines.join('\\n');\n}\n\nfunction prepareTruncateOptions(containerWidth, font, ellipsis, options) {\n  options = extend({}, options);\n  options.font = font;\n  var ellipsis = retrieve2(ellipsis, '...');\n  options.maxIterations = retrieve2(options.maxIterations, 2);\n  var minChar = options.minChar = retrieve2(options.minChar, 0); // FIXME\n  // Other languages?\n\n  options.cnCharWidth = getWidth('国', font); // FIXME\n  // Consider proportional font?\n\n  var ascCharWidth = options.ascCharWidth = getWidth('a', font);\n  options.placeholder = retrieve2(options.placeholder, ''); // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n  // Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.\n\n  var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.\n\n  for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n    contentWidth -= ascCharWidth;\n  }\n\n  var ellipsisWidth = getWidth(ellipsis, font);\n\n  if (ellipsisWidth > contentWidth) {\n    ellipsis = '';\n    ellipsisWidth = 0;\n  }\n\n  contentWidth = containerWidth - ellipsisWidth;\n  options.ellipsis = ellipsis;\n  options.ellipsisWidth = ellipsisWidth;\n  options.contentWidth = contentWidth;\n  options.containerWidth = containerWidth;\n  return options;\n}\n\nfunction truncateSingleLine(textLine, options) {\n  var containerWidth = options.containerWidth;\n  var font = options.font;\n  var contentWidth = options.contentWidth;\n\n  if (!containerWidth) {\n    return '';\n  }\n\n  var lineWidth = getWidth(textLine, font);\n\n  if (lineWidth <= containerWidth) {\n    return textLine;\n  }\n\n  for (var j = 0;; j++) {\n    if (lineWidth <= contentWidth || j >= options.maxIterations) {\n      textLine += options.ellipsis;\n      break;\n    }\n\n    var subLength = j === 0 ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;\n    textLine = textLine.substr(0, subLength);\n    lineWidth = getWidth(textLine, font);\n  }\n\n  if (textLine === '') {\n    textLine = options.placeholder;\n  }\n\n  return textLine;\n}\n\nfunction estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n  var width = 0;\n  var i = 0;\n\n  for (var len = text.length; i < len && width < contentWidth; i++) {\n    var charCode = text.charCodeAt(i);\n    width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;\n  }\n\n  return i;\n}\n/**\n * @public\n * @param {string} font\n * @return {number} line height\n */\n\n\nfunction getLineHeight(font) {\n  // FIXME A rough approach.\n  return getWidth('国', font);\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @return {Object} width\n */\n\n\nfunction measureText(text, font) {\n  return methods.measureText(text, font);\n} // Avoid assign to an exported variable, for transforming to cjs.\n\n\nmethods.measureText = function (text, font) {\n  var ctx = getContext();\n  ctx.font = font || DEFAULT_FONT;\n  return ctx.measureText(text);\n};\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @param {Object} [truncate]\n * @return {Object} block: {lineHeight, lines, height, outerHeight, canCacheByTextString}\n *  Notice: for performance, do not calculate outerWidth util needed.\n *  `canCacheByTextString` means the result `lines` is only determined by the input `text`.\n *  Thus we can simply comparing the `input` text to determin whether the result changed,\n *  without travel the result `lines`.\n */\n\n\nfunction parsePlainText(text, font, padding, textLineHeight, truncate) {\n  text != null && (text += '');\n  var lineHeight = retrieve2(textLineHeight, getLineHeight(font));\n  var lines = text ? text.split('\\n') : [];\n  var height = lines.length * lineHeight;\n  var outerHeight = height;\n  var canCacheByTextString = true;\n\n  if (padding) {\n    outerHeight += padding[0] + padding[2];\n  }\n\n  if (text && truncate) {\n    canCacheByTextString = false;\n    var truncOuterHeight = truncate.outerHeight;\n    var truncOuterWidth = truncate.outerWidth;\n\n    if (truncOuterHeight != null && outerHeight > truncOuterHeight) {\n      text = '';\n      lines = [];\n    } else if (truncOuterWidth != null) {\n      var options = prepareTruncateOptions(truncOuterWidth - (padding ? padding[1] + padding[3] : 0), font, truncate.ellipsis, {\n        minChar: truncate.minChar,\n        placeholder: truncate.placeholder\n      }); // FIXME\n      // It is not appropriate that every line has '...' when truncate multiple lines.\n\n      for (var i = 0, len = lines.length; i < len; i++) {\n        lines[i] = truncateSingleLine(lines[i], options);\n      }\n    }\n  }\n\n  return {\n    lines: lines,\n    height: height,\n    outerHeight: outerHeight,\n    lineHeight: lineHeight,\n    canCacheByTextString: canCacheByTextString\n  };\n}\n/**\n * For example: 'some text {a|some text}other text{b|some text}xxx{c|}xxx'\n * Also consider 'bbbb{a|xxx\\nzzz}xxxx\\naaaa'.\n *\n * @public\n * @param {string} text\n * @param {Object} style\n * @return {Object} block\n * {\n *      width,\n *      height,\n *      lines: [{\n *          lineHeight,\n *          width,\n *          tokens: [[{\n *              styleName,\n *              text,\n *              width,      // include textPadding\n *              height,     // include textPadding\n *              textWidth, // pure text width\n *              textHeight, // pure text height\n *              lineHeihgt,\n *              font,\n *              textAlign,\n *              textVerticalAlign\n *          }], [...], ...]\n *      }, ...]\n * }\n * If styleName is undefined, it is plain text.\n */\n\n\nfunction parseRichText(text, style) {\n  var contentBlock = {\n    lines: [],\n    width: 0,\n    height: 0\n  };\n  text != null && (text += '');\n\n  if (!text) {\n    return contentBlock;\n  }\n\n  var lastIndex = STYLE_REG.lastIndex = 0;\n  var result;\n\n  while ((result = STYLE_REG.exec(text)) != null) {\n    var matchedIndex = result.index;\n\n    if (matchedIndex > lastIndex) {\n      pushTokens(contentBlock, text.substring(lastIndex, matchedIndex));\n    }\n\n    pushTokens(contentBlock, result[2], result[1]);\n    lastIndex = STYLE_REG.lastIndex;\n  }\n\n  if (lastIndex < text.length) {\n    pushTokens(contentBlock, text.substring(lastIndex, text.length));\n  }\n\n  var lines = contentBlock.lines;\n  var contentHeight = 0;\n  var contentWidth = 0; // For `textWidth: 100%`\n\n  var pendingList = [];\n  var stlPadding = style.textPadding;\n  var truncate = style.truncate;\n  var truncateWidth = truncate && truncate.outerWidth;\n  var truncateHeight = truncate && truncate.outerHeight;\n\n  if (stlPadding) {\n    truncateWidth != null && (truncateWidth -= stlPadding[1] + stlPadding[3]);\n    truncateHeight != null && (truncateHeight -= stlPadding[0] + stlPadding[2]);\n  } // Calculate layout info of tokens.\n\n\n  for (var i = 0; i < lines.length; i++) {\n    var line = lines[i];\n    var lineHeight = 0;\n    var lineWidth = 0;\n\n    for (var j = 0; j < line.tokens.length; j++) {\n      var token = line.tokens[j];\n      var tokenStyle = token.styleName && style.rich[token.styleName] || {}; // textPadding should not inherit from style.\n\n      var textPadding = token.textPadding = tokenStyle.textPadding; // textFont has been asigned to font by `normalizeStyle`.\n\n      var font = token.font = tokenStyle.font || style.font; // textHeight can be used when textVerticalAlign is specified in token.\n\n      var tokenHeight = token.textHeight = retrieve2( // textHeight should not be inherited, consider it can be specified\n      // as box height of the block.\n      tokenStyle.textHeight, getLineHeight(font));\n      textPadding && (tokenHeight += textPadding[0] + textPadding[2]);\n      token.height = tokenHeight;\n      token.lineHeight = retrieve3(tokenStyle.textLineHeight, style.textLineHeight, tokenHeight);\n      token.textAlign = tokenStyle && tokenStyle.textAlign || style.textAlign;\n      token.textVerticalAlign = tokenStyle && tokenStyle.textVerticalAlign || 'middle';\n\n      if (truncateHeight != null && contentHeight + token.lineHeight > truncateHeight) {\n        return {\n          lines: [],\n          width: 0,\n          height: 0\n        };\n      }\n\n      token.textWidth = getWidth(token.text, font);\n      var tokenWidth = tokenStyle.textWidth;\n      var tokenWidthNotSpecified = tokenWidth == null || tokenWidth === 'auto'; // Percent width, can be `100%`, can be used in drawing separate\n      // line when box width is needed to be auto.\n\n      if (typeof tokenWidth === 'string' && tokenWidth.charAt(tokenWidth.length - 1) === '%') {\n        token.percentWidth = tokenWidth;\n        pendingList.push(token);\n        tokenWidth = 0; // Do not truncate in this case, because there is no user case\n        // and it is too complicated.\n      } else {\n        if (tokenWidthNotSpecified) {\n          tokenWidth = token.textWidth; // FIXME: If image is not loaded and textWidth is not specified, calling\n          // `getBoundingRect()` will not get correct result.\n\n          var textBackgroundColor = tokenStyle.textBackgroundColor;\n          var bgImg = textBackgroundColor && textBackgroundColor.image; // Use cases:\n          // (1) If image is not loaded, it will be loaded at render phase and call\n          // `dirty()` and `textBackgroundColor.image` will be replaced with the loaded\n          // image, and then the right size will be calculated here at the next tick.\n          // See `graphic/helper/text.js`.\n          // (2) If image loaded, and `textBackgroundColor.image` is image src string,\n          // use `imageHelper.findExistImage` to find cached image.\n          // `imageHelper.findExistImage` will always be called here before\n          // `imageHelper.createOrUpdateImage` in `graphic/helper/text.js#renderRichText`\n          // which ensures that image will not be rendered before correct size calcualted.\n\n          if (bgImg) {\n            bgImg = imageHelper.findExistImage(bgImg);\n\n            if (imageHelper.isImageReady(bgImg)) {\n              tokenWidth = Math.max(tokenWidth, bgImg.width * tokenHeight / bgImg.height);\n            }\n          }\n        }\n\n        var paddingW = textPadding ? textPadding[1] + textPadding[3] : 0;\n        tokenWidth += paddingW;\n        var remianTruncWidth = truncateWidth != null ? truncateWidth - lineWidth : null;\n\n        if (remianTruncWidth != null && remianTruncWidth < tokenWidth) {\n          if (!tokenWidthNotSpecified || remianTruncWidth < paddingW) {\n            token.text = '';\n            token.textWidth = tokenWidth = 0;\n          } else {\n            token.text = truncateText(token.text, remianTruncWidth - paddingW, font, truncate.ellipsis, {\n              minChar: truncate.minChar\n            });\n            token.textWidth = getWidth(token.text, font);\n            tokenWidth = token.textWidth + paddingW;\n          }\n        }\n      }\n\n      lineWidth += token.width = tokenWidth;\n      tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));\n    }\n\n    line.width = lineWidth;\n    line.lineHeight = lineHeight;\n    contentHeight += lineHeight;\n    contentWidth = Math.max(contentWidth, lineWidth);\n  }\n\n  contentBlock.outerWidth = contentBlock.width = retrieve2(style.textWidth, contentWidth);\n  contentBlock.outerHeight = contentBlock.height = retrieve2(style.textHeight, contentHeight);\n\n  if (stlPadding) {\n    contentBlock.outerWidth += stlPadding[1] + stlPadding[3];\n    contentBlock.outerHeight += stlPadding[0] + stlPadding[2];\n  }\n\n  for (var i = 0; i < pendingList.length; i++) {\n    var token = pendingList[i];\n    var percentWidth = token.percentWidth; // Should not base on outerWidth, because token can not be placed out of padding.\n\n    token.width = parseInt(percentWidth, 10) / 100 * contentWidth;\n  }\n\n  return contentBlock;\n}\n\nfunction pushTokens(block, str, styleName) {\n  var isEmptyStr = str === '';\n  var strs = str.split('\\n');\n  var lines = block.lines;\n\n  for (var i = 0; i < strs.length; i++) {\n    var text = strs[i];\n    var token = {\n      styleName: styleName,\n      text: text,\n      isLineHolder: !text && !isEmptyStr\n    }; // The first token should be appended to the last line.\n\n    if (!i) {\n      var tokens = (lines[lines.length - 1] || (lines[0] = {\n        tokens: []\n      })).tokens; // Consider cases:\n      // (1) ''.split('\\n') => ['', '\\n', ''], the '' at the first item\n      // (which is a placeholder) should be replaced by new token.\n      // (2) A image backage, where token likes {a|}.\n      // (3) A redundant '' will affect textAlign in line.\n      // (4) tokens with the same tplName should not be merged, because\n      // they should be displayed in different box (with border and padding).\n\n      var tokensLen = tokens.length;\n      tokensLen === 1 && tokens[0].isLineHolder ? tokens[0] = token : // Consider text is '', only insert when it is the \"lineHolder\" or\n      // \"emptyStr\". Otherwise a redundant '' will affect textAlign in line.\n      (text || !tokensLen || isEmptyStr) && tokens.push(token);\n    } // Other tokens always start a new line.\n    else {\n      // If there is '', insert it as a placeholder.\n      lines.push({\n        tokens: [token]\n      });\n    }\n  }\n}\n\nfunction makeFont(style) {\n  // FIXME in node-canvas fontWeight is before fontStyle\n  // Use `fontSize` `fontFamily` to check whether font properties are defined.\n  var font = (style.fontSize || style.fontFamily) && [style.fontStyle, style.fontWeight, (style.fontSize || 12) + 'px', // If font properties are defined, `fontFamily` should not be ignored.\n  style.fontFamily || 'sans-serif'].join(' ');\n  return font && trim(font) || style.textFont || style.font;\n}\n\nexports.DEFAULT_FONT = DEFAULT_FONT;\nexports.$override = $override;\nexports.getWidth = getWidth;\nexports.getBoundingRect = getBoundingRect;\nexports.adjustTextX = adjustTextX;\nexports.adjustTextY = adjustTextY;\nexports.calculateTextPosition = calculateTextPosition;\nexports.adjustTextPositionOnRect = adjustTextPositionOnRect;\nexports.truncateText = truncateText;\nexports.getLineHeight = getLineHeight;\nexports.measureText = measureText;\nexports.parsePlainText = parsePlainText;\nexports.parseRichText = parseRichText;\nexports.makeFont = makeFont;","map":{"version":3,"names":["BoundingRect","require","imageHelper","_util","getContext","extend","retrieve2","retrieve3","trim","textWidthCache","textWidthCacheCounter","TEXT_CACHE_MAX","STYLE_REG","DEFAULT_FONT","methods","$override","name","fn","getWidth","text","font","key","textLines","split","width","i","l","length","Math","max","measureText","getBoundingRect","textAlign","textVerticalAlign","textPadding","textLineHeight","rich","truncate","getRichTextRect","getPlainTextRect","contentBlock","parsePlainText","outerWidth","outerHeight","x","adjustTextX","y","adjustTextY","rect","lineHeight","parseRichText","height","calculateTextPosition","out","style","textPosition","distance","textDistance","halfHeight","adjustTextPositionOnRect","dummyStyle","truncateText","containerWidth","ellipsis","options","prepareTruncateOptions","len","truncateSingleLine","join","maxIterations","minChar","cnCharWidth","ascCharWidth","placeholder","contentWidth","ellipsisWidth","textLine","lineWidth","j","subLength","estimateLength","floor","substr","charCode","charCodeAt","getLineHeight","ctx","padding","lines","canCacheByTextString","truncOuterHeight","truncOuterWidth","lastIndex","result","exec","matchedIndex","index","pushTokens","substring","contentHeight","pendingList","stlPadding","truncateWidth","truncateHeight","line","tokens","token","tokenStyle","styleName","tokenHeight","textHeight","textWidth","tokenWidth","tokenWidthNotSpecified","charAt","percentWidth","push","textBackgroundColor","bgImg","image","findExistImage","isImageReady","paddingW","remianTruncWidth","parseInt","block","str","isEmptyStr","strs","isLineHolder","tokensLen","makeFont","fontSize","fontFamily","fontStyle","fontWeight","textFont","exports"],"sources":["/Users/lord/Documents/Programmer/vue/VueProjects/cloudycraft-vue/blog-admin/node_modules/zrender/lib/contain/text.js"],"sourcesContent":["var BoundingRect = require(\"../core/BoundingRect\");\n\nvar imageHelper = require(\"../graphic/helper/image\");\n\nvar _util = require(\"../core/util\");\n\nvar getContext = _util.getContext;\nvar extend = _util.extend;\nvar retrieve2 = _util.retrieve2;\nvar retrieve3 = _util.retrieve3;\nvar trim = _util.trim;\nvar textWidthCache = {};\nvar textWidthCacheCounter = 0;\nvar TEXT_CACHE_MAX = 5000;\nvar STYLE_REG = /\\{([a-zA-Z0-9_]+)\\|([^}]*)\\}/g;\nvar DEFAULT_FONT = '12px sans-serif'; // Avoid assign to an exported variable, for transforming to cjs.\n\nvar methods = {};\n\nfunction $override(name, fn) {\n  methods[name] = fn;\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @return {number} width\n */\n\n\nfunction getWidth(text, font) {\n  font = font || DEFAULT_FONT;\n  var key = text + ':' + font;\n\n  if (textWidthCache[key]) {\n    return textWidthCache[key];\n  }\n\n  var textLines = (text + '').split('\\n');\n  var width = 0;\n\n  for (var i = 0, l = textLines.length; i < l; i++) {\n    // textContain.measureText may be overrided in SVG or VML\n    width = Math.max(measureText(textLines[i], font).width, width);\n  }\n\n  if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n    textWidthCacheCounter = 0;\n    textWidthCache = {};\n  }\n\n  textWidthCacheCounter++;\n  textWidthCache[key] = width;\n  return width;\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @param {string} [textAlign='left']\n * @param {string} [textVerticalAlign='top']\n * @param {Array.<number>} [textPadding]\n * @param {Object} [rich]\n * @param {Object} [truncate]\n * @return {Object} {x, y, width, height, lineHeight}\n */\n\n\nfunction getBoundingRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, rich, truncate) {\n  return rich ? getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, rich, truncate) : getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, truncate);\n}\n\nfunction getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, truncate) {\n  var contentBlock = parsePlainText(text, font, textPadding, textLineHeight, truncate);\n  var outerWidth = getWidth(text, font);\n\n  if (textPadding) {\n    outerWidth += textPadding[1] + textPadding[3];\n  }\n\n  var outerHeight = contentBlock.outerHeight;\n  var x = adjustTextX(0, outerWidth, textAlign);\n  var y = adjustTextY(0, outerHeight, textVerticalAlign);\n  var rect = new BoundingRect(x, y, outerWidth, outerHeight);\n  rect.lineHeight = contentBlock.lineHeight;\n  return rect;\n}\n\nfunction getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, rich, truncate) {\n  var contentBlock = parseRichText(text, {\n    rich: rich,\n    truncate: truncate,\n    font: font,\n    textAlign: textAlign,\n    textPadding: textPadding,\n    textLineHeight: textLineHeight\n  });\n  var outerWidth = contentBlock.outerWidth;\n  var outerHeight = contentBlock.outerHeight;\n  var x = adjustTextX(0, outerWidth, textAlign);\n  var y = adjustTextY(0, outerHeight, textVerticalAlign);\n  return new BoundingRect(x, y, outerWidth, outerHeight);\n}\n/**\n * @public\n * @param {number} x\n * @param {number} width\n * @param {string} [textAlign='left']\n * @return {number} Adjusted x.\n */\n\n\nfunction adjustTextX(x, width, textAlign) {\n  // FIXME Right to left language\n  if (textAlign === 'right') {\n    x -= width;\n  } else if (textAlign === 'center') {\n    x -= width / 2;\n  }\n\n  return x;\n}\n/**\n * @public\n * @param {number} y\n * @param {number} height\n * @param {string} [textVerticalAlign='top']\n * @return {number} Adjusted y.\n */\n\n\nfunction adjustTextY(y, height, textVerticalAlign) {\n  if (textVerticalAlign === 'middle') {\n    y -= height / 2;\n  } else if (textVerticalAlign === 'bottom') {\n    y -= height;\n  }\n\n  return y;\n}\n/**\n * Follow same interface to `Displayable.prototype.calculateTextPosition`.\n * @public\n * @param {Obejct} [out] Prepared out object. If not input, auto created in the method.\n * @param {module:zrender/graphic/Style} style where `textPosition` and `textDistance` are visited.\n * @param {Object} rect {x, y, width, height} Rect of the host elment, according to which the text positioned.\n * @return {Object} The input `out`. Set: {x, y, textAlign, textVerticalAlign}\n */\n\n\nfunction calculateTextPosition(out, style, rect) {\n  var textPosition = style.textPosition;\n  var distance = style.textDistance;\n  var x = rect.x;\n  var y = rect.y;\n  distance = distance || 0;\n  var height = rect.height;\n  var width = rect.width;\n  var halfHeight = height / 2;\n  var textAlign = 'left';\n  var textVerticalAlign = 'top';\n\n  switch (textPosition) {\n    case 'left':\n      x -= distance;\n      y += halfHeight;\n      textAlign = 'right';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'right':\n      x += distance + width;\n      y += halfHeight;\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'top':\n      x += width / 2;\n      y -= distance;\n      textAlign = 'center';\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'bottom':\n      x += width / 2;\n      y += height + distance;\n      textAlign = 'center';\n      break;\n\n    case 'inside':\n      x += width / 2;\n      y += halfHeight;\n      textAlign = 'center';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideLeft':\n      x += distance;\n      y += halfHeight;\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideRight':\n      x += width - distance;\n      y += halfHeight;\n      textAlign = 'right';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideTop':\n      x += width / 2;\n      y += distance;\n      textAlign = 'center';\n      break;\n\n    case 'insideBottom':\n      x += width / 2;\n      y += height - distance;\n      textAlign = 'center';\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'insideTopLeft':\n      x += distance;\n      y += distance;\n      break;\n\n    case 'insideTopRight':\n      x += width - distance;\n      y += distance;\n      textAlign = 'right';\n      break;\n\n    case 'insideBottomLeft':\n      x += distance;\n      y += height - distance;\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'insideBottomRight':\n      x += width - distance;\n      y += height - distance;\n      textAlign = 'right';\n      textVerticalAlign = 'bottom';\n      break;\n  }\n\n  out = out || {};\n  out.x = x;\n  out.y = y;\n  out.textAlign = textAlign;\n  out.textVerticalAlign = textVerticalAlign;\n  return out;\n}\n/**\n * To be removed. But still do not remove in case that some one has imported it.\n * @deprecated\n * @public\n * @param {stirng} textPosition\n * @param {Object} rect {x, y, width, height}\n * @param {number} distance\n * @return {Object} {x, y, textAlign, textVerticalAlign}\n */\n\n\nfunction adjustTextPositionOnRect(textPosition, rect, distance) {\n  var dummyStyle = {\n    textPosition: textPosition,\n    textDistance: distance\n  };\n  return calculateTextPosition({}, dummyStyle, rect);\n}\n/**\n * Show ellipsis if overflow.\n *\n * @public\n * @param  {string} text\n * @param  {string} containerWidth\n * @param  {string} font\n * @param  {number} [ellipsis='...']\n * @param  {Object} [options]\n * @param  {number} [options.maxIterations=3]\n * @param  {number} [options.minChar=0] If truncate result are less\n *                  then minChar, ellipsis will not show, which is\n *                  better for user hint in some cases.\n * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n * @return {string}\n */\n\n\nfunction truncateText(text, containerWidth, font, ellipsis, options) {\n  if (!containerWidth) {\n    return '';\n  }\n\n  var textLines = (text + '').split('\\n');\n  options = prepareTruncateOptions(containerWidth, font, ellipsis, options); // FIXME\n  // It is not appropriate that every line has '...' when truncate multiple lines.\n\n  for (var i = 0, len = textLines.length; i < len; i++) {\n    textLines[i] = truncateSingleLine(textLines[i], options);\n  }\n\n  return textLines.join('\\n');\n}\n\nfunction prepareTruncateOptions(containerWidth, font, ellipsis, options) {\n  options = extend({}, options);\n  options.font = font;\n  var ellipsis = retrieve2(ellipsis, '...');\n  options.maxIterations = retrieve2(options.maxIterations, 2);\n  var minChar = options.minChar = retrieve2(options.minChar, 0); // FIXME\n  // Other languages?\n\n  options.cnCharWidth = getWidth('国', font); // FIXME\n  // Consider proportional font?\n\n  var ascCharWidth = options.ascCharWidth = getWidth('a', font);\n  options.placeholder = retrieve2(options.placeholder, ''); // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n  // Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.\n\n  var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.\n\n  for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n    contentWidth -= ascCharWidth;\n  }\n\n  var ellipsisWidth = getWidth(ellipsis, font);\n\n  if (ellipsisWidth > contentWidth) {\n    ellipsis = '';\n    ellipsisWidth = 0;\n  }\n\n  contentWidth = containerWidth - ellipsisWidth;\n  options.ellipsis = ellipsis;\n  options.ellipsisWidth = ellipsisWidth;\n  options.contentWidth = contentWidth;\n  options.containerWidth = containerWidth;\n  return options;\n}\n\nfunction truncateSingleLine(textLine, options) {\n  var containerWidth = options.containerWidth;\n  var font = options.font;\n  var contentWidth = options.contentWidth;\n\n  if (!containerWidth) {\n    return '';\n  }\n\n  var lineWidth = getWidth(textLine, font);\n\n  if (lineWidth <= containerWidth) {\n    return textLine;\n  }\n\n  for (var j = 0;; j++) {\n    if (lineWidth <= contentWidth || j >= options.maxIterations) {\n      textLine += options.ellipsis;\n      break;\n    }\n\n    var subLength = j === 0 ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;\n    textLine = textLine.substr(0, subLength);\n    lineWidth = getWidth(textLine, font);\n  }\n\n  if (textLine === '') {\n    textLine = options.placeholder;\n  }\n\n  return textLine;\n}\n\nfunction estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n  var width = 0;\n  var i = 0;\n\n  for (var len = text.length; i < len && width < contentWidth; i++) {\n    var charCode = text.charCodeAt(i);\n    width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;\n  }\n\n  return i;\n}\n/**\n * @public\n * @param {string} font\n * @return {number} line height\n */\n\n\nfunction getLineHeight(font) {\n  // FIXME A rough approach.\n  return getWidth('国', font);\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @return {Object} width\n */\n\n\nfunction measureText(text, font) {\n  return methods.measureText(text, font);\n} // Avoid assign to an exported variable, for transforming to cjs.\n\n\nmethods.measureText = function (text, font) {\n  var ctx = getContext();\n  ctx.font = font || DEFAULT_FONT;\n  return ctx.measureText(text);\n};\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @param {Object} [truncate]\n * @return {Object} block: {lineHeight, lines, height, outerHeight, canCacheByTextString}\n *  Notice: for performance, do not calculate outerWidth util needed.\n *  `canCacheByTextString` means the result `lines` is only determined by the input `text`.\n *  Thus we can simply comparing the `input` text to determin whether the result changed,\n *  without travel the result `lines`.\n */\n\n\nfunction parsePlainText(text, font, padding, textLineHeight, truncate) {\n  text != null && (text += '');\n  var lineHeight = retrieve2(textLineHeight, getLineHeight(font));\n  var lines = text ? text.split('\\n') : [];\n  var height = lines.length * lineHeight;\n  var outerHeight = height;\n  var canCacheByTextString = true;\n\n  if (padding) {\n    outerHeight += padding[0] + padding[2];\n  }\n\n  if (text && truncate) {\n    canCacheByTextString = false;\n    var truncOuterHeight = truncate.outerHeight;\n    var truncOuterWidth = truncate.outerWidth;\n\n    if (truncOuterHeight != null && outerHeight > truncOuterHeight) {\n      text = '';\n      lines = [];\n    } else if (truncOuterWidth != null) {\n      var options = prepareTruncateOptions(truncOuterWidth - (padding ? padding[1] + padding[3] : 0), font, truncate.ellipsis, {\n        minChar: truncate.minChar,\n        placeholder: truncate.placeholder\n      }); // FIXME\n      // It is not appropriate that every line has '...' when truncate multiple lines.\n\n      for (var i = 0, len = lines.length; i < len; i++) {\n        lines[i] = truncateSingleLine(lines[i], options);\n      }\n    }\n  }\n\n  return {\n    lines: lines,\n    height: height,\n    outerHeight: outerHeight,\n    lineHeight: lineHeight,\n    canCacheByTextString: canCacheByTextString\n  };\n}\n/**\n * For example: 'some text {a|some text}other text{b|some text}xxx{c|}xxx'\n * Also consider 'bbbb{a|xxx\\nzzz}xxxx\\naaaa'.\n *\n * @public\n * @param {string} text\n * @param {Object} style\n * @return {Object} block\n * {\n *      width,\n *      height,\n *      lines: [{\n *          lineHeight,\n *          width,\n *          tokens: [[{\n *              styleName,\n *              text,\n *              width,      // include textPadding\n *              height,     // include textPadding\n *              textWidth, // pure text width\n *              textHeight, // pure text height\n *              lineHeihgt,\n *              font,\n *              textAlign,\n *              textVerticalAlign\n *          }], [...], ...]\n *      }, ...]\n * }\n * If styleName is undefined, it is plain text.\n */\n\n\nfunction parseRichText(text, style) {\n  var contentBlock = {\n    lines: [],\n    width: 0,\n    height: 0\n  };\n  text != null && (text += '');\n\n  if (!text) {\n    return contentBlock;\n  }\n\n  var lastIndex = STYLE_REG.lastIndex = 0;\n  var result;\n\n  while ((result = STYLE_REG.exec(text)) != null) {\n    var matchedIndex = result.index;\n\n    if (matchedIndex > lastIndex) {\n      pushTokens(contentBlock, text.substring(lastIndex, matchedIndex));\n    }\n\n    pushTokens(contentBlock, result[2], result[1]);\n    lastIndex = STYLE_REG.lastIndex;\n  }\n\n  if (lastIndex < text.length) {\n    pushTokens(contentBlock, text.substring(lastIndex, text.length));\n  }\n\n  var lines = contentBlock.lines;\n  var contentHeight = 0;\n  var contentWidth = 0; // For `textWidth: 100%`\n\n  var pendingList = [];\n  var stlPadding = style.textPadding;\n  var truncate = style.truncate;\n  var truncateWidth = truncate && truncate.outerWidth;\n  var truncateHeight = truncate && truncate.outerHeight;\n\n  if (stlPadding) {\n    truncateWidth != null && (truncateWidth -= stlPadding[1] + stlPadding[3]);\n    truncateHeight != null && (truncateHeight -= stlPadding[0] + stlPadding[2]);\n  } // Calculate layout info of tokens.\n\n\n  for (var i = 0; i < lines.length; i++) {\n    var line = lines[i];\n    var lineHeight = 0;\n    var lineWidth = 0;\n\n    for (var j = 0; j < line.tokens.length; j++) {\n      var token = line.tokens[j];\n      var tokenStyle = token.styleName && style.rich[token.styleName] || {}; // textPadding should not inherit from style.\n\n      var textPadding = token.textPadding = tokenStyle.textPadding; // textFont has been asigned to font by `normalizeStyle`.\n\n      var font = token.font = tokenStyle.font || style.font; // textHeight can be used when textVerticalAlign is specified in token.\n\n      var tokenHeight = token.textHeight = retrieve2( // textHeight should not be inherited, consider it can be specified\n      // as box height of the block.\n      tokenStyle.textHeight, getLineHeight(font));\n      textPadding && (tokenHeight += textPadding[0] + textPadding[2]);\n      token.height = tokenHeight;\n      token.lineHeight = retrieve3(tokenStyle.textLineHeight, style.textLineHeight, tokenHeight);\n      token.textAlign = tokenStyle && tokenStyle.textAlign || style.textAlign;\n      token.textVerticalAlign = tokenStyle && tokenStyle.textVerticalAlign || 'middle';\n\n      if (truncateHeight != null && contentHeight + token.lineHeight > truncateHeight) {\n        return {\n          lines: [],\n          width: 0,\n          height: 0\n        };\n      }\n\n      token.textWidth = getWidth(token.text, font);\n      var tokenWidth = tokenStyle.textWidth;\n      var tokenWidthNotSpecified = tokenWidth == null || tokenWidth === 'auto'; // Percent width, can be `100%`, can be used in drawing separate\n      // line when box width is needed to be auto.\n\n      if (typeof tokenWidth === 'string' && tokenWidth.charAt(tokenWidth.length - 1) === '%') {\n        token.percentWidth = tokenWidth;\n        pendingList.push(token);\n        tokenWidth = 0; // Do not truncate in this case, because there is no user case\n        // and it is too complicated.\n      } else {\n        if (tokenWidthNotSpecified) {\n          tokenWidth = token.textWidth; // FIXME: If image is not loaded and textWidth is not specified, calling\n          // `getBoundingRect()` will not get correct result.\n\n          var textBackgroundColor = tokenStyle.textBackgroundColor;\n          var bgImg = textBackgroundColor && textBackgroundColor.image; // Use cases:\n          // (1) If image is not loaded, it will be loaded at render phase and call\n          // `dirty()` and `textBackgroundColor.image` will be replaced with the loaded\n          // image, and then the right size will be calculated here at the next tick.\n          // See `graphic/helper/text.js`.\n          // (2) If image loaded, and `textBackgroundColor.image` is image src string,\n          // use `imageHelper.findExistImage` to find cached image.\n          // `imageHelper.findExistImage` will always be called here before\n          // `imageHelper.createOrUpdateImage` in `graphic/helper/text.js#renderRichText`\n          // which ensures that image will not be rendered before correct size calcualted.\n\n          if (bgImg) {\n            bgImg = imageHelper.findExistImage(bgImg);\n\n            if (imageHelper.isImageReady(bgImg)) {\n              tokenWidth = Math.max(tokenWidth, bgImg.width * tokenHeight / bgImg.height);\n            }\n          }\n        }\n\n        var paddingW = textPadding ? textPadding[1] + textPadding[3] : 0;\n        tokenWidth += paddingW;\n        var remianTruncWidth = truncateWidth != null ? truncateWidth - lineWidth : null;\n\n        if (remianTruncWidth != null && remianTruncWidth < tokenWidth) {\n          if (!tokenWidthNotSpecified || remianTruncWidth < paddingW) {\n            token.text = '';\n            token.textWidth = tokenWidth = 0;\n          } else {\n            token.text = truncateText(token.text, remianTruncWidth - paddingW, font, truncate.ellipsis, {\n              minChar: truncate.minChar\n            });\n            token.textWidth = getWidth(token.text, font);\n            tokenWidth = token.textWidth + paddingW;\n          }\n        }\n      }\n\n      lineWidth += token.width = tokenWidth;\n      tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));\n    }\n\n    line.width = lineWidth;\n    line.lineHeight = lineHeight;\n    contentHeight += lineHeight;\n    contentWidth = Math.max(contentWidth, lineWidth);\n  }\n\n  contentBlock.outerWidth = contentBlock.width = retrieve2(style.textWidth, contentWidth);\n  contentBlock.outerHeight = contentBlock.height = retrieve2(style.textHeight, contentHeight);\n\n  if (stlPadding) {\n    contentBlock.outerWidth += stlPadding[1] + stlPadding[3];\n    contentBlock.outerHeight += stlPadding[0] + stlPadding[2];\n  }\n\n  for (var i = 0; i < pendingList.length; i++) {\n    var token = pendingList[i];\n    var percentWidth = token.percentWidth; // Should not base on outerWidth, because token can not be placed out of padding.\n\n    token.width = parseInt(percentWidth, 10) / 100 * contentWidth;\n  }\n\n  return contentBlock;\n}\n\nfunction pushTokens(block, str, styleName) {\n  var isEmptyStr = str === '';\n  var strs = str.split('\\n');\n  var lines = block.lines;\n\n  for (var i = 0; i < strs.length; i++) {\n    var text = strs[i];\n    var token = {\n      styleName: styleName,\n      text: text,\n      isLineHolder: !text && !isEmptyStr\n    }; // The first token should be appended to the last line.\n\n    if (!i) {\n      var tokens = (lines[lines.length - 1] || (lines[0] = {\n        tokens: []\n      })).tokens; // Consider cases:\n      // (1) ''.split('\\n') => ['', '\\n', ''], the '' at the first item\n      // (which is a placeholder) should be replaced by new token.\n      // (2) A image backage, where token likes {a|}.\n      // (3) A redundant '' will affect textAlign in line.\n      // (4) tokens with the same tplName should not be merged, because\n      // they should be displayed in different box (with border and padding).\n\n      var tokensLen = tokens.length;\n      tokensLen === 1 && tokens[0].isLineHolder ? tokens[0] = token : // Consider text is '', only insert when it is the \"lineHolder\" or\n      // \"emptyStr\". Otherwise a redundant '' will affect textAlign in line.\n      (text || !tokensLen || isEmptyStr) && tokens.push(token);\n    } // Other tokens always start a new line.\n    else {\n        // If there is '', insert it as a placeholder.\n        lines.push({\n          tokens: [token]\n        });\n      }\n  }\n}\n\nfunction makeFont(style) {\n  // FIXME in node-canvas fontWeight is before fontStyle\n  // Use `fontSize` `fontFamily` to check whether font properties are defined.\n  var font = (style.fontSize || style.fontFamily) && [style.fontStyle, style.fontWeight, (style.fontSize || 12) + 'px', // If font properties are defined, `fontFamily` should not be ignored.\n  style.fontFamily || 'sans-serif'].join(' ');\n  return font && trim(font) || style.textFont || style.font;\n}\n\nexports.DEFAULT_FONT = DEFAULT_FONT;\nexports.$override = $override;\nexports.getWidth = getWidth;\nexports.getBoundingRect = getBoundingRect;\nexports.adjustTextX = adjustTextX;\nexports.adjustTextY = adjustTextY;\nexports.calculateTextPosition = calculateTextPosition;\nexports.adjustTextPositionOnRect = adjustTextPositionOnRect;\nexports.truncateText = truncateText;\nexports.getLineHeight = getLineHeight;\nexports.measureText = measureText;\nexports.parsePlainText = parsePlainText;\nexports.parseRichText = parseRichText;\nexports.makeFont = makeFont;"],"mappings":"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"},"metadata":{},"sourceType":"script"}