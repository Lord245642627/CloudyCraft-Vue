{"ast":null,"code":"module.exports = function (modules) {\n  function __webpack_require__(moduleId) {\n    if (installedModules[moduleId]) return installedModules[moduleId].exports;\n    var module = installedModules[moduleId] = {\n      i: moduleId,\n      l: !1,\n      exports: {}\n    };\n    return modules[moduleId].call(module.exports, module, module.exports, __webpack_require__), module.l = !0, module.exports;\n  }\n\n  var installedModules = {};\n  return __webpack_require__.m = modules, __webpack_require__.c = installedModules, __webpack_require__.i = function (value) {\n    return value;\n  }, __webpack_require__.d = function (exports, name, getter) {\n    __webpack_require__.o(exports, name) || Object.defineProperty(exports, name, {\n      configurable: !1,\n      enumerable: !0,\n      get: getter\n    });\n  }, __webpack_require__.n = function (module) {\n    var getter = module && module.__esModule ? function () {\n      return module.default;\n    } : function () {\n      return module;\n    };\n    return __webpack_require__.d(getter, \"a\", getter), getter;\n  }, __webpack_require__.o = function (object, property) {\n    return Object.prototype.hasOwnProperty.call(object, property);\n  }, __webpack_require__.p = \"\", __webpack_require__(__webpack_require__.s = 3);\n}([function (module, __webpack_exports__, __webpack_require__) {\n  \"use strict\";\n\n  __webpack_require__.d(__webpack_exports__, \"a\", function () {\n    return DEFAULT_RANGE_COLOR;\n  }), __webpack_require__.d(__webpack_exports__, \"e\", function () {\n    return DEFAULT_LOCALE;\n  }), __webpack_require__.d(__webpack_exports__, \"b\", function () {\n    return DEFAULT_TOOLTIP_UNIT;\n  }), __webpack_require__.d(__webpack_exports__, \"f\", function () {\n    return DAYS_IN_ONE_YEAR;\n  }), __webpack_require__.d(__webpack_exports__, \"c\", function () {\n    return DAYS_IN_WEEK;\n  }), __webpack_require__.d(__webpack_exports__, \"d\", function () {\n    return SQUARE_SIZE;\n  });\n  var DEFAULT_RANGE_COLOR = [\"#ebedf0\", \"#c0ddf9\", \"#73b3f3\", \"#3886e1\", \"#17459e\"],\n      DEFAULT_LOCALE = {\n    months: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"],\n    days: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n    on: \"on\",\n    less: \"Less\",\n    more: \"More\"\n  },\n      DEFAULT_TOOLTIP_UNIT = \"contributions\",\n      DAYS_IN_ONE_YEAR = 365,\n      DAYS_IN_WEEK = 7,\n      SQUARE_SIZE = 10;\n}, function (module, exports, __webpack_require__) {\n  __webpack_require__(7), __webpack_require__(6);\n\n  var Component = __webpack_require__(8)(__webpack_require__(5), __webpack_require__(9), \"data-v-a9cfea66\", null);\n\n  module.exports = Component.exports;\n}, function (module, __webpack_exports__, __webpack_require__) {\n  \"use strict\";\n\n  function _toConsumableArray(arr) {\n    if (Array.isArray(arr)) {\n      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n      return arr2;\n    }\n\n    return Array.from(arr);\n  }\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) throw new TypeError(\"Cannot call a class as a function\");\n  }\n\n  var __WEBPACK_IMPORTED_MODULE_0__consts__ = __webpack_require__(0),\n      _createClass = function () {\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, \"value\" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n\n    return function (Constructor, protoProps, staticProps) {\n      return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), Constructor;\n    };\n  }(),\n      CalendarHeatmap = function () {\n    function CalendarHeatmap(endDate, values, max) {\n      _classCallCheck(this, CalendarHeatmap), this.endDate = this._parseDate(endDate), this.max = max || Math.ceil(Math.max.apply(Math, _toConsumableArray(values.map(function (day) {\n        return day.count;\n      }))) / 5 * 4), this.startDate = this._shiftDate(endDate, -__WEBPACK_IMPORTED_MODULE_0__consts__.f), this.values = values;\n    }\n\n    return _createClass(CalendarHeatmap, [{\n      key: \"getColorIndex\",\n      value: function (value) {\n        return value <= 0 ? 0 : value >= this.max ? 4 : Math.ceil(100 * value / this.max * .03);\n      }\n    }, {\n      key: \"getCountEmptyDaysAtStart\",\n      value: function () {\n        return this.startDate.getDay();\n      }\n    }, {\n      key: \"getCountEmptyDaysAtEnd\",\n      value: function () {\n        return __WEBPACK_IMPORTED_MODULE_0__consts__.c - 1 - this.endDate.getDay();\n      }\n    }, {\n      key: \"getDaysCount\",\n      value: function () {\n        return __WEBPACK_IMPORTED_MODULE_0__consts__.f + 1 + this.getCountEmptyDaysAtStart() + this.getCountEmptyDaysAtEnd();\n      }\n    }, {\n      key: \"_shiftDate\",\n      value: function (date, numDays) {\n        var newDate = new Date(date);\n        return newDate.setDate(newDate.getDate() + numDays), newDate;\n      }\n    }, {\n      key: \"_parseDate\",\n      value: function (entry) {\n        return entry instanceof Date ? entry : new Date(entry);\n      }\n    }, {\n      key: \"_keyDayParser\",\n      value: function (date) {\n        var day = this._parseDate(date);\n\n        return day.getFullYear() + \"-\" + day.getMonth() + \"-\" + day.getDate();\n      }\n    }, {\n      key: \"activities\",\n      get: function () {\n        var _this = this;\n\n        return this.values.reduce(function (newValues, day) {\n          return newValues[_this._keyDayParser(day.date)] = {\n            count: day.count,\n            colorIndex: _this.getColorIndex(day.count)\n          }, newValues;\n        }, {});\n      }\n    }, {\n      key: \"weekCount\",\n      get: function () {\n        return this.getDaysCount() / __WEBPACK_IMPORTED_MODULE_0__consts__.c;\n      }\n    }, {\n      key: \"calendar\",\n      get: function () {\n        var _this2 = this,\n            date = this._shiftDate(this.startDate, -this.getCountEmptyDaysAtStart());\n\n        return Array.from({\n          length: this.weekCount\n        }, function () {\n          return Array.from({\n            length: __WEBPACK_IMPORTED_MODULE_0__consts__.c\n          }, function () {\n            var dDate = new Date(date.getFullYear(), date.getMonth(), date.getDate()),\n                dayValues = _this2.activities[_this2._keyDayParser(dDate)];\n\n            return date.setDate(date.getDate() + 1), {\n              date: dDate,\n              count: dayValues ? dayValues.count : 0,\n              colorIndex: dayValues ? dayValues.colorIndex : 0\n            };\n          });\n        });\n      }\n    }, {\n      key: \"firstFullWeekOfMonths\",\n      get: function () {\n        return this.calendar.reduce(function (months, week, index, weeks) {\n          if (index > 0) {\n            var lastWeek = weeks[index - 1][0].date,\n                currentWeek = week[0].date;\n            (lastWeek.getFullYear() < currentWeek.getFullYear() || lastWeek.getMonth() < currentWeek.getMonth()) && months.push({\n              value: currentWeek.getMonth(),\n              index: index\n            });\n          }\n\n          return months;\n        }, []);\n      }\n    }]), CalendarHeatmap;\n  }();\n\n  __webpack_exports__.a = CalendarHeatmap;\n}, function (module, __webpack_exports__, __webpack_require__) {\n  \"use strict\";\n\n  function install(Vue) {\n    Vue.component(\"calendarHeatmap\", __WEBPACK_IMPORTED_MODULE_0__components_CalendarHeatmap_vue___default.a);\n  }\n\n  Object.defineProperty(__webpack_exports__, \"__esModule\", {\n    value: !0\n  }), __webpack_exports__.install = install;\n\n  var __WEBPACK_IMPORTED_MODULE_0__components_CalendarHeatmap_vue__ = __webpack_require__(1),\n      __WEBPACK_IMPORTED_MODULE_0__components_CalendarHeatmap_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__components_CalendarHeatmap_vue__);\n\n  __webpack_require__.d(__webpack_exports__, \"CalendarHeatmap\", function () {\n    return __WEBPACK_IMPORTED_MODULE_0__components_CalendarHeatmap_vue___default.a;\n  });\n\n  var plugin = {\n    version: \"0.8.4\",\n    install: install\n  };\n  __webpack_exports__.default = plugin;\n  var GlobalVue = null;\n  \"undefined\" != typeof window ? GlobalVue = window.Vue : \"undefined\" != typeof global && (GlobalVue = global.Vue), GlobalVue && GlobalVue.use(plugin);\n}, function (module, __webpack_exports__, __webpack_require__) {\n  \"use strict\";\n\n  function microtaskDebounce(fn) {\n    var called = !1;\n    return function () {\n      called || (called = !0, window.Promise.resolve().then(function () {\n        called = !1, fn();\n      }));\n    };\n  }\n\n  function taskDebounce(fn) {\n    var scheduled = !1;\n    return function () {\n      scheduled || (scheduled = !0, setTimeout(function () {\n        scheduled = !1, fn();\n      }, timeoutDuration));\n    };\n  }\n\n  function isFunction(functionToCheck) {\n    var getType = {};\n    return functionToCheck && \"[object Function]\" === getType.toString.call(functionToCheck);\n  }\n\n  function getStyleComputedProperty(element, property) {\n    if (1 !== element.nodeType) return [];\n    var css = getComputedStyle(element, null);\n    return property ? css[property] : css;\n  }\n\n  function getParentNode(element) {\n    return \"HTML\" === element.nodeName ? element : element.parentNode || element.host;\n  }\n\n  function getScrollParent(element) {\n    if (!element) return document.body;\n\n    switch (element.nodeName) {\n      case \"HTML\":\n      case \"BODY\":\n        return element.ownerDocument.body;\n\n      case \"#document\":\n        return element.body;\n    }\n\n    var _getStyleComputedProp = getStyleComputedProperty(element),\n        overflow = _getStyleComputedProp.overflow,\n        overflowX = _getStyleComputedProp.overflowX;\n\n    return /(auto|scroll|overlay)/.test(overflow + _getStyleComputedProp.overflowY + overflowX) ? element : getScrollParent(getParentNode(element));\n  }\n\n  function isIE(version) {\n    return 11 === version ? isIE11 : 10 === version ? isIE10 : isIE11 || isIE10;\n  }\n\n  function getOffsetParent(element) {\n    if (!element) return document.documentElement;\n\n    for (var noOffsetParent = isIE(10) ? document.body : null, offsetParent = element.offsetParent; offsetParent === noOffsetParent && element.nextElementSibling;) offsetParent = (element = element.nextElementSibling).offsetParent;\n\n    var nodeName = offsetParent && offsetParent.nodeName;\n    return nodeName && \"BODY\" !== nodeName && \"HTML\" !== nodeName ? -1 !== [\"TD\", \"TABLE\"].indexOf(offsetParent.nodeName) && \"static\" === getStyleComputedProperty(offsetParent, \"position\") ? getOffsetParent(offsetParent) : offsetParent : element ? element.ownerDocument.documentElement : document.documentElement;\n  }\n\n  function isOffsetContainer(element) {\n    var nodeName = element.nodeName;\n    return \"BODY\" !== nodeName && (\"HTML\" === nodeName || getOffsetParent(element.firstElementChild) === element);\n  }\n\n  function getRoot(node) {\n    return null !== node.parentNode ? getRoot(node.parentNode) : node;\n  }\n\n  function findCommonOffsetParent(element1, element2) {\n    if (!(element1 && element1.nodeType && element2 && element2.nodeType)) return document.documentElement;\n    var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING,\n        start = order ? element1 : element2,\n        end = order ? element2 : element1,\n        range = document.createRange();\n    range.setStart(start, 0), range.setEnd(end, 0);\n    var commonAncestorContainer = range.commonAncestorContainer;\n    if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) return isOffsetContainer(commonAncestorContainer) ? commonAncestorContainer : getOffsetParent(commonAncestorContainer);\n    var element1root = getRoot(element1);\n    return element1root.host ? findCommonOffsetParent(element1root.host, element2) : findCommonOffsetParent(element1, getRoot(element2).host);\n  }\n\n  function getScroll(element) {\n    var side = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : \"top\",\n        upperSide = \"top\" === side ? \"scrollTop\" : \"scrollLeft\",\n        nodeName = element.nodeName;\n\n    if (\"BODY\" === nodeName || \"HTML\" === nodeName) {\n      var html = element.ownerDocument.documentElement;\n      return (element.ownerDocument.scrollingElement || html)[upperSide];\n    }\n\n    return element[upperSide];\n  }\n\n  function includeScroll(rect, element) {\n    var subtract = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],\n        scrollTop = getScroll(element, \"top\"),\n        scrollLeft = getScroll(element, \"left\"),\n        modifier = subtract ? -1 : 1;\n    return rect.top += scrollTop * modifier, rect.bottom += scrollTop * modifier, rect.left += scrollLeft * modifier, rect.right += scrollLeft * modifier, rect;\n  }\n\n  function getBordersSize(styles, axis) {\n    var sideA = \"x\" === axis ? \"Left\" : \"Top\",\n        sideB = \"Left\" === sideA ? \"Right\" : \"Bottom\";\n    return parseFloat(styles[\"border\" + sideA + \"Width\"], 10) + parseFloat(styles[\"border\" + sideB + \"Width\"], 10);\n  }\n\n  function getSize(axis, body, html, computedStyle) {\n    return Math.max(body[\"offset\" + axis], body[\"scroll\" + axis], html[\"client\" + axis], html[\"offset\" + axis], html[\"scroll\" + axis], isIE(10) ? html[\"offset\" + axis] + computedStyle[\"margin\" + (\"Height\" === axis ? \"Top\" : \"Left\")] + computedStyle[\"margin\" + (\"Height\" === axis ? \"Bottom\" : \"Right\")] : 0);\n  }\n\n  function getWindowSizes() {\n    var body = document.body,\n        html = document.documentElement,\n        computedStyle = isIE(10) && getComputedStyle(html);\n    return {\n      height: getSize(\"Height\", body, html, computedStyle),\n      width: getSize(\"Width\", body, html, computedStyle)\n    };\n  }\n\n  function getClientRect(offsets) {\n    return _extends({}, offsets, {\n      right: offsets.left + offsets.width,\n      bottom: offsets.top + offsets.height\n    });\n  }\n\n  function getBoundingClientRect(element) {\n    var rect = {};\n\n    try {\n      if (isIE(10)) {\n        rect = element.getBoundingClientRect();\n        var scrollTop = getScroll(element, \"top\"),\n            scrollLeft = getScroll(element, \"left\");\n        rect.top += scrollTop, rect.left += scrollLeft, rect.bottom += scrollTop, rect.right += scrollLeft;\n      } else rect = element.getBoundingClientRect();\n    } catch (e) {}\n\n    var result = {\n      left: rect.left,\n      top: rect.top,\n      width: rect.right - rect.left,\n      height: rect.bottom - rect.top\n    },\n        sizes = \"HTML\" === element.nodeName ? getWindowSizes() : {},\n        width = sizes.width || element.clientWidth || result.right - result.left,\n        height = sizes.height || element.clientHeight || result.bottom - result.top,\n        horizScrollbar = element.offsetWidth - width,\n        vertScrollbar = element.offsetHeight - height;\n\n    if (horizScrollbar || vertScrollbar) {\n      var styles = getStyleComputedProperty(element);\n      horizScrollbar -= getBordersSize(styles, \"x\"), vertScrollbar -= getBordersSize(styles, \"y\"), result.width -= horizScrollbar, result.height -= vertScrollbar;\n    }\n\n    return getClientRect(result);\n  }\n\n  function getOffsetRectRelativeToArbitraryNode(children, parent) {\n    var fixedPosition = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],\n        isIE10 = isIE(10),\n        isHTML = \"HTML\" === parent.nodeName,\n        childrenRect = getBoundingClientRect(children),\n        parentRect = getBoundingClientRect(parent),\n        scrollParent = getScrollParent(children),\n        styles = getStyleComputedProperty(parent),\n        borderTopWidth = parseFloat(styles.borderTopWidth, 10),\n        borderLeftWidth = parseFloat(styles.borderLeftWidth, 10);\n    fixedPosition && \"HTML\" === parent.nodeName && (parentRect.top = Math.max(parentRect.top, 0), parentRect.left = Math.max(parentRect.left, 0));\n    var offsets = getClientRect({\n      top: childrenRect.top - parentRect.top - borderTopWidth,\n      left: childrenRect.left - parentRect.left - borderLeftWidth,\n      width: childrenRect.width,\n      height: childrenRect.height\n    });\n\n    if (offsets.marginTop = 0, offsets.marginLeft = 0, !isIE10 && isHTML) {\n      var marginTop = parseFloat(styles.marginTop, 10),\n          marginLeft = parseFloat(styles.marginLeft, 10);\n      offsets.top -= borderTopWidth - marginTop, offsets.bottom -= borderTopWidth - marginTop, offsets.left -= borderLeftWidth - marginLeft, offsets.right -= borderLeftWidth - marginLeft, offsets.marginTop = marginTop, offsets.marginLeft = marginLeft;\n    }\n\n    return (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && \"BODY\" !== scrollParent.nodeName) && (offsets = includeScroll(offsets, parent)), offsets;\n  }\n\n  function getViewportOffsetRectRelativeToArtbitraryNode(element) {\n    var excludeScroll = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],\n        html = element.ownerDocument.documentElement,\n        relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html),\n        width = Math.max(html.clientWidth, window.innerWidth || 0),\n        height = Math.max(html.clientHeight, window.innerHeight || 0),\n        scrollTop = excludeScroll ? 0 : getScroll(html),\n        scrollLeft = excludeScroll ? 0 : getScroll(html, \"left\");\n    return getClientRect({\n      top: scrollTop - relativeOffset.top + relativeOffset.marginTop,\n      left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,\n      width: width,\n      height: height\n    });\n  }\n\n  function isFixed(element) {\n    var nodeName = element.nodeName;\n    return \"BODY\" !== nodeName && \"HTML\" !== nodeName && (\"fixed\" === getStyleComputedProperty(element, \"position\") || isFixed(getParentNode(element)));\n  }\n\n  function getFixedPositionOffsetParent(element) {\n    if (!element || !element.parentElement || isIE()) return document.documentElement;\n\n    for (var el = element.parentElement; el && \"none\" === getStyleComputedProperty(el, \"transform\");) el = el.parentElement;\n\n    return el || document.documentElement;\n  }\n\n  function getBoundaries(popper, reference, padding, boundariesElement) {\n    var fixedPosition = arguments.length > 4 && void 0 !== arguments[4] && arguments[4],\n        boundaries = {\n      top: 0,\n      left: 0\n    },\n        offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);\n    if (\"viewport\" === boundariesElement) boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);else {\n      var boundariesNode = void 0;\n      \"scrollParent\" === boundariesElement ? (boundariesNode = getScrollParent(getParentNode(reference)), \"BODY\" === boundariesNode.nodeName && (boundariesNode = popper.ownerDocument.documentElement)) : boundariesNode = \"window\" === boundariesElement ? popper.ownerDocument.documentElement : boundariesElement;\n      var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);\n      if (\"HTML\" !== boundariesNode.nodeName || isFixed(offsetParent)) boundaries = offsets;else {\n        var _getWindowSizes = getWindowSizes(),\n            height = _getWindowSizes.height,\n            width = _getWindowSizes.width;\n\n        boundaries.top += offsets.top - offsets.marginTop, boundaries.bottom = height + offsets.top, boundaries.left += offsets.left - offsets.marginLeft, boundaries.right = width + offsets.left;\n      }\n    }\n    return boundaries.left += padding, boundaries.top += padding, boundaries.right -= padding, boundaries.bottom -= padding, boundaries;\n  }\n\n  function getArea(_ref) {\n    return _ref.width * _ref.height;\n  }\n\n  function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {\n    var padding = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0;\n    if (-1 === placement.indexOf(\"auto\")) return placement;\n    var boundaries = getBoundaries(popper, reference, padding, boundariesElement),\n        rects = {\n      top: {\n        width: boundaries.width,\n        height: refRect.top - boundaries.top\n      },\n      right: {\n        width: boundaries.right - refRect.right,\n        height: boundaries.height\n      },\n      bottom: {\n        width: boundaries.width,\n        height: boundaries.bottom - refRect.bottom\n      },\n      left: {\n        width: refRect.left - boundaries.left,\n        height: boundaries.height\n      }\n    },\n        sortedAreas = Object.keys(rects).map(function (key) {\n      return _extends({\n        key: key\n      }, rects[key], {\n        area: getArea(rects[key])\n      });\n    }).sort(function (a, b) {\n      return b.area - a.area;\n    }),\n        filteredAreas = sortedAreas.filter(function (_ref2) {\n      var width = _ref2.width,\n          height = _ref2.height;\n      return width >= popper.clientWidth && height >= popper.clientHeight;\n    }),\n        computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key,\n        variation = placement.split(\"-\")[1];\n    return computedPlacement + (variation ? \"-\" + variation : \"\");\n  }\n\n  function getReferenceOffsets(state, popper, reference) {\n    var fixedPosition = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;\n    return getOffsetRectRelativeToArbitraryNode(reference, fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference), fixedPosition);\n  }\n\n  function getOuterSizes(element) {\n    var styles = getComputedStyle(element),\n        x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom),\n        y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);\n    return {\n      width: element.offsetWidth + y,\n      height: element.offsetHeight + x\n    };\n  }\n\n  function getOppositePlacement(placement) {\n    var hash = {\n      left: \"right\",\n      right: \"left\",\n      bottom: \"top\",\n      top: \"bottom\"\n    };\n    return placement.replace(/left|right|bottom|top/g, function (matched) {\n      return hash[matched];\n    });\n  }\n\n  function getPopperOffsets(popper, referenceOffsets, placement) {\n    placement = placement.split(\"-\")[0];\n    var popperRect = getOuterSizes(popper),\n        popperOffsets = {\n      width: popperRect.width,\n      height: popperRect.height\n    },\n        isHoriz = -1 !== [\"right\", \"left\"].indexOf(placement),\n        mainSide = isHoriz ? \"top\" : \"left\",\n        secondarySide = isHoriz ? \"left\" : \"top\",\n        measurement = isHoriz ? \"height\" : \"width\",\n        secondaryMeasurement = isHoriz ? \"width\" : \"height\";\n    return popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2, popperOffsets[secondarySide] = placement === secondarySide ? referenceOffsets[secondarySide] - popperRect[secondaryMeasurement] : referenceOffsets[getOppositePlacement(secondarySide)], popperOffsets;\n  }\n\n  function find(arr, check) {\n    return Array.prototype.find ? arr.find(check) : arr.filter(check)[0];\n  }\n\n  function findIndex(arr, prop, value) {\n    if (Array.prototype.findIndex) return arr.findIndex(function (cur) {\n      return cur[prop] === value;\n    });\n    var match = find(arr, function (obj) {\n      return obj[prop] === value;\n    });\n    return arr.indexOf(match);\n  }\n\n  function runModifiers(modifiers, data, ends) {\n    return (void 0 === ends ? modifiers : modifiers.slice(0, findIndex(modifiers, \"name\", ends))).forEach(function (modifier) {\n      modifier.function && console.warn(\"`modifier.function` is deprecated, use `modifier.fn`!\");\n      var fn = modifier.function || modifier.fn;\n      modifier.enabled && isFunction(fn) && (data.offsets.popper = getClientRect(data.offsets.popper), data.offsets.reference = getClientRect(data.offsets.reference), data = fn(data, modifier));\n    }), data;\n  }\n\n  function update() {\n    if (!this.state.isDestroyed) {\n      var data = {\n        instance: this,\n        styles: {},\n        arrowStyles: {},\n        attributes: {},\n        flipped: !1,\n        offsets: {}\n      };\n      data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed), data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding), data.originalPlacement = data.placement, data.positionFixed = this.options.positionFixed, data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement), data.offsets.popper.position = this.options.positionFixed ? \"fixed\" : \"absolute\", data = runModifiers(this.modifiers, data), this.state.isCreated ? this.options.onUpdate(data) : (this.state.isCreated = !0, this.options.onCreate(data));\n    }\n  }\n\n  function isModifierEnabled(modifiers, modifierName) {\n    return modifiers.some(function (_ref) {\n      var name = _ref.name;\n      return _ref.enabled && name === modifierName;\n    });\n  }\n\n  function getSupportedPropertyName(property) {\n    for (var prefixes = [!1, \"ms\", \"Webkit\", \"Moz\", \"O\"], upperProp = property.charAt(0).toUpperCase() + property.slice(1), i = 0; i < prefixes.length; i++) {\n      var prefix = prefixes[i],\n          toCheck = prefix ? \"\" + prefix + upperProp : property;\n      if (void 0 !== document.body.style[toCheck]) return toCheck;\n    }\n\n    return null;\n  }\n\n  function destroy() {\n    return this.state.isDestroyed = !0, isModifierEnabled(this.modifiers, \"applyStyle\") && (this.popper.removeAttribute(\"x-placement\"), this.popper.style.position = \"\", this.popper.style.top = \"\", this.popper.style.left = \"\", this.popper.style.right = \"\", this.popper.style.bottom = \"\", this.popper.style.willChange = \"\", this.popper.style[getSupportedPropertyName(\"transform\")] = \"\"), this.disableEventListeners(), this.options.removeOnDestroy && this.popper.parentNode.removeChild(this.popper), this;\n  }\n\n  function getWindow(element) {\n    var ownerDocument = element.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView : window;\n  }\n\n  function attachToScrollParents(scrollParent, event, callback, scrollParents) {\n    var isBody = \"BODY\" === scrollParent.nodeName,\n        target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;\n    target.addEventListener(event, callback, {\n      passive: !0\n    }), isBody || attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents), scrollParents.push(target);\n  }\n\n  function setupEventListeners(reference, options, state, updateBound) {\n    state.updateBound = updateBound, getWindow(reference).addEventListener(\"resize\", state.updateBound, {\n      passive: !0\n    });\n    var scrollElement = getScrollParent(reference);\n    return attachToScrollParents(scrollElement, \"scroll\", state.updateBound, state.scrollParents), state.scrollElement = scrollElement, state.eventsEnabled = !0, state;\n  }\n\n  function enableEventListeners() {\n    this.state.eventsEnabled || (this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate));\n  }\n\n  function removeEventListeners(reference, state) {\n    return getWindow(reference).removeEventListener(\"resize\", state.updateBound), state.scrollParents.forEach(function (target) {\n      target.removeEventListener(\"scroll\", state.updateBound);\n    }), state.updateBound = null, state.scrollParents = [], state.scrollElement = null, state.eventsEnabled = !1, state;\n  }\n\n  function disableEventListeners() {\n    this.state.eventsEnabled && (cancelAnimationFrame(this.scheduleUpdate), this.state = removeEventListeners(this.reference, this.state));\n  }\n\n  function isNumeric(n) {\n    return \"\" !== n && !isNaN(parseFloat(n)) && isFinite(n);\n  }\n\n  function setStyles(element, styles) {\n    Object.keys(styles).forEach(function (prop) {\n      var unit = \"\";\n      -1 !== [\"width\", \"height\", \"top\", \"right\", \"bottom\", \"left\"].indexOf(prop) && isNumeric(styles[prop]) && (unit = \"px\"), element.style[prop] = styles[prop] + unit;\n    });\n  }\n\n  function setAttributes(element, attributes) {\n    Object.keys(attributes).forEach(function (prop) {\n      !1 !== attributes[prop] ? element.setAttribute(prop, attributes[prop]) : element.removeAttribute(prop);\n    });\n  }\n\n  function applyStyle(data) {\n    return setStyles(data.instance.popper, data.styles), setAttributes(data.instance.popper, data.attributes), data.arrowElement && Object.keys(data.arrowStyles).length && setStyles(data.arrowElement, data.arrowStyles), data;\n  }\n\n  function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {\n    var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed),\n        placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);\n    return popper.setAttribute(\"x-placement\", placement), setStyles(popper, {\n      position: options.positionFixed ? \"fixed\" : \"absolute\"\n    }), options;\n  }\n\n  function computeStyle(data, options) {\n    var x = options.x,\n        y = options.y,\n        popper = data.offsets.popper,\n        legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {\n      return \"applyStyle\" === modifier.name;\n    }).gpuAcceleration;\n    void 0 !== legacyGpuAccelerationOption && console.warn(\"WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!\");\n    var gpuAcceleration = void 0 !== legacyGpuAccelerationOption ? legacyGpuAccelerationOption : options.gpuAcceleration,\n        offsetParent = getOffsetParent(data.instance.popper),\n        offsetParentRect = getBoundingClientRect(offsetParent),\n        styles = {\n      position: popper.position\n    },\n        offsets = {\n      left: Math.floor(popper.left),\n      top: Math.round(popper.top),\n      bottom: Math.round(popper.bottom),\n      right: Math.floor(popper.right)\n    },\n        sideA = \"bottom\" === x ? \"top\" : \"bottom\",\n        sideB = \"right\" === y ? \"left\" : \"right\",\n        prefixedProperty = getSupportedPropertyName(\"transform\"),\n        left = void 0,\n        top = void 0;\n    if (top = \"bottom\" === sideA ? -offsetParentRect.height + offsets.bottom : offsets.top, left = \"right\" === sideB ? -offsetParentRect.width + offsets.right : offsets.left, gpuAcceleration && prefixedProperty) styles[prefixedProperty] = \"translate3d(\" + left + \"px, \" + top + \"px, 0)\", styles[sideA] = 0, styles[sideB] = 0, styles.willChange = \"transform\";else {\n      var invertTop = \"bottom\" === sideA ? -1 : 1,\n          invertLeft = \"right\" === sideB ? -1 : 1;\n      styles[sideA] = top * invertTop, styles[sideB] = left * invertLeft, styles.willChange = sideA + \", \" + sideB;\n    }\n    var attributes = {\n      \"x-placement\": data.placement\n    };\n    return data.attributes = _extends({}, attributes, data.attributes), data.styles = _extends({}, styles, data.styles), data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles), data;\n  }\n\n  function isModifierRequired(modifiers, requestingName, requestedName) {\n    var requesting = find(modifiers, function (_ref) {\n      return _ref.name === requestingName;\n    }),\n        isRequired = !!requesting && modifiers.some(function (modifier) {\n      return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;\n    });\n\n    if (!isRequired) {\n      var _requesting = \"`\" + requestingName + \"`\",\n          requested = \"`\" + requestedName + \"`\";\n\n      console.warn(requested + \" modifier is required by \" + _requesting + \" modifier in order to work, be sure to include it before \" + _requesting + \"!\");\n    }\n\n    return isRequired;\n  }\n\n  function arrow(data, options) {\n    var _data$offsets$arrow;\n\n    if (!isModifierRequired(data.instance.modifiers, \"arrow\", \"keepTogether\")) return data;\n    var arrowElement = options.element;\n\n    if (\"string\" == typeof arrowElement) {\n      if (!(arrowElement = data.instance.popper.querySelector(arrowElement))) return data;\n    } else if (!data.instance.popper.contains(arrowElement)) return console.warn(\"WARNING: `arrow.element` must be child of its popper element!\"), data;\n\n    var placement = data.placement.split(\"-\")[0],\n        _data$offsets = data.offsets,\n        popper = _data$offsets.popper,\n        reference = _data$offsets.reference,\n        isVertical = -1 !== [\"left\", \"right\"].indexOf(placement),\n        len = isVertical ? \"height\" : \"width\",\n        sideCapitalized = isVertical ? \"Top\" : \"Left\",\n        side = sideCapitalized.toLowerCase(),\n        altSide = isVertical ? \"left\" : \"top\",\n        opSide = isVertical ? \"bottom\" : \"right\",\n        arrowElementSize = getOuterSizes(arrowElement)[len];\n    reference[opSide] - arrowElementSize < popper[side] && (data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize)), reference[side] + arrowElementSize > popper[opSide] && (data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide]), data.offsets.popper = getClientRect(data.offsets.popper);\n    var center = reference[side] + reference[len] / 2 - arrowElementSize / 2,\n        css = getStyleComputedProperty(data.instance.popper),\n        popperMarginSide = parseFloat(css[\"margin\" + sideCapitalized], 10),\n        popperBorderSide = parseFloat(css[\"border\" + sideCapitalized + \"Width\"], 10),\n        sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;\n    return sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0), data.arrowElement = arrowElement, data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, \"\"), _data$offsets$arrow), data;\n  }\n\n  function getOppositeVariation(variation) {\n    return \"end\" === variation ? \"start\" : \"start\" === variation ? \"end\" : variation;\n  }\n\n  function clockwise(placement) {\n    var counter = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],\n        index = validPlacements.indexOf(placement),\n        arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));\n    return counter ? arr.reverse() : arr;\n  }\n\n  function flip(data, options) {\n    if (isModifierEnabled(data.instance.modifiers, \"inner\")) return data;\n    if (data.flipped && data.placement === data.originalPlacement) return data;\n    var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed),\n        placement = data.placement.split(\"-\")[0],\n        placementOpposite = getOppositePlacement(placement),\n        variation = data.placement.split(\"-\")[1] || \"\",\n        flipOrder = [];\n\n    switch (options.behavior) {\n      case BEHAVIORS.FLIP:\n        flipOrder = [placement, placementOpposite];\n        break;\n\n      case BEHAVIORS.CLOCKWISE:\n        flipOrder = clockwise(placement);\n        break;\n\n      case BEHAVIORS.COUNTERCLOCKWISE:\n        flipOrder = clockwise(placement, !0);\n        break;\n\n      default:\n        flipOrder = options.behavior;\n    }\n\n    return flipOrder.forEach(function (step, index) {\n      if (placement !== step || flipOrder.length === index + 1) return data;\n      placement = data.placement.split(\"-\")[0], placementOpposite = getOppositePlacement(placement);\n      var popperOffsets = data.offsets.popper,\n          refOffsets = data.offsets.reference,\n          floor = Math.floor,\n          overlapsRef = \"left\" === placement && floor(popperOffsets.right) > floor(refOffsets.left) || \"right\" === placement && floor(popperOffsets.left) < floor(refOffsets.right) || \"top\" === placement && floor(popperOffsets.bottom) > floor(refOffsets.top) || \"bottom\" === placement && floor(popperOffsets.top) < floor(refOffsets.bottom),\n          overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left),\n          overflowsRight = floor(popperOffsets.right) > floor(boundaries.right),\n          overflowsTop = floor(popperOffsets.top) < floor(boundaries.top),\n          overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom),\n          overflowsBoundaries = \"left\" === placement && overflowsLeft || \"right\" === placement && overflowsRight || \"top\" === placement && overflowsTop || \"bottom\" === placement && overflowsBottom,\n          isVertical = -1 !== [\"top\", \"bottom\"].indexOf(placement),\n          flippedVariation = !!options.flipVariations && (isVertical && \"start\" === variation && overflowsLeft || isVertical && \"end\" === variation && overflowsRight || !isVertical && \"start\" === variation && overflowsTop || !isVertical && \"end\" === variation && overflowsBottom);\n      (overlapsRef || overflowsBoundaries || flippedVariation) && (data.flipped = !0, (overlapsRef || overflowsBoundaries) && (placement = flipOrder[index + 1]), flippedVariation && (variation = getOppositeVariation(variation)), data.placement = placement + (variation ? \"-\" + variation : \"\"), data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement)), data = runModifiers(data.instance.modifiers, data, \"flip\"));\n    }), data;\n  }\n\n  function keepTogether(data) {\n    var _data$offsets = data.offsets,\n        popper = _data$offsets.popper,\n        reference = _data$offsets.reference,\n        placement = data.placement.split(\"-\")[0],\n        floor = Math.floor,\n        isVertical = -1 !== [\"top\", \"bottom\"].indexOf(placement),\n        side = isVertical ? \"right\" : \"bottom\",\n        opSide = isVertical ? \"left\" : \"top\",\n        measurement = isVertical ? \"width\" : \"height\";\n    return popper[side] < floor(reference[opSide]) && (data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement]), popper[opSide] > floor(reference[side]) && (data.offsets.popper[opSide] = floor(reference[side])), data;\n  }\n\n  function toValue(str, measurement, popperOffsets, referenceOffsets) {\n    var split = str.match(/((?:\\-|\\+)?\\d*\\.?\\d*)(.*)/),\n        value = +split[1],\n        unit = split[2];\n    if (!value) return str;\n\n    if (0 === unit.indexOf(\"%\")) {\n      var element = void 0;\n\n      switch (unit) {\n        case \"%p\":\n          element = popperOffsets;\n          break;\n\n        case \"%\":\n        case \"%r\":\n        default:\n          element = referenceOffsets;\n      }\n\n      return getClientRect(element)[measurement] / 100 * value;\n    }\n\n    if (\"vh\" === unit || \"vw\" === unit) {\n      return (\"vh\" === unit ? Math.max(document.documentElement.clientHeight, window.innerHeight || 0) : Math.max(document.documentElement.clientWidth, window.innerWidth || 0)) / 100 * value;\n    }\n\n    return value;\n  }\n\n  function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {\n    var offsets = [0, 0],\n        useHeight = -1 !== [\"right\", \"left\"].indexOf(basePlacement),\n        fragments = offset.split(/(\\+|\\-)/).map(function (frag) {\n      return frag.trim();\n    }),\n        divider = fragments.indexOf(find(fragments, function (frag) {\n      return -1 !== frag.search(/,|\\s/);\n    }));\n    fragments[divider] && -1 === fragments[divider].indexOf(\",\") && console.warn(\"Offsets separated by white space(s) are deprecated, use a comma (,) instead.\");\n    var splitRegex = /\\s*,\\s*|\\s+/,\n        ops = -1 !== divider ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];\n    return ops = ops.map(function (op, index) {\n      var measurement = (1 === index ? !useHeight : useHeight) ? \"height\" : \"width\",\n          mergeWithPrevious = !1;\n      return op.reduce(function (a, b) {\n        return \"\" === a[a.length - 1] && -1 !== [\"+\", \"-\"].indexOf(b) ? (a[a.length - 1] = b, mergeWithPrevious = !0, a) : mergeWithPrevious ? (a[a.length - 1] += b, mergeWithPrevious = !1, a) : a.concat(b);\n      }, []).map(function (str) {\n        return toValue(str, measurement, popperOffsets, referenceOffsets);\n      });\n    }), ops.forEach(function (op, index) {\n      op.forEach(function (frag, index2) {\n        isNumeric(frag) && (offsets[index] += frag * (\"-\" === op[index2 - 1] ? -1 : 1));\n      });\n    }), offsets;\n  }\n\n  function offset(data, _ref) {\n    var offset = _ref.offset,\n        placement = data.placement,\n        _data$offsets = data.offsets,\n        popper = _data$offsets.popper,\n        reference = _data$offsets.reference,\n        basePlacement = placement.split(\"-\")[0],\n        offsets = void 0;\n    return offsets = isNumeric(+offset) ? [+offset, 0] : parseOffset(offset, popper, reference, basePlacement), \"left\" === basePlacement ? (popper.top += offsets[0], popper.left -= offsets[1]) : \"right\" === basePlacement ? (popper.top += offsets[0], popper.left += offsets[1]) : \"top\" === basePlacement ? (popper.left += offsets[0], popper.top -= offsets[1]) : \"bottom\" === basePlacement && (popper.left += offsets[0], popper.top += offsets[1]), data.popper = popper, data;\n  }\n\n  function preventOverflow(data, options) {\n    var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);\n    data.instance.reference === boundariesElement && (boundariesElement = getOffsetParent(boundariesElement));\n    var transformProp = getSupportedPropertyName(\"transform\"),\n        popperStyles = data.instance.popper.style,\n        top = popperStyles.top,\n        left = popperStyles.left,\n        transform = popperStyles[transformProp];\n    popperStyles.top = \"\", popperStyles.left = \"\", popperStyles[transformProp] = \"\";\n    var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);\n    popperStyles.top = top, popperStyles.left = left, popperStyles[transformProp] = transform, options.boundaries = boundaries;\n    var order = options.priority,\n        popper = data.offsets.popper,\n        check = {\n      primary: function (placement) {\n        var value = popper[placement];\n        return popper[placement] < boundaries[placement] && !options.escapeWithReference && (value = Math.max(popper[placement], boundaries[placement])), defineProperty({}, placement, value);\n      },\n      secondary: function (placement) {\n        var mainSide = \"right\" === placement ? \"left\" : \"top\",\n            value = popper[mainSide];\n        return popper[placement] > boundaries[placement] && !options.escapeWithReference && (value = Math.min(popper[mainSide], boundaries[placement] - (\"right\" === placement ? popper.width : popper.height))), defineProperty({}, mainSide, value);\n      }\n    };\n    return order.forEach(function (placement) {\n      var side = -1 !== [\"left\", \"top\"].indexOf(placement) ? \"primary\" : \"secondary\";\n      popper = _extends({}, popper, check[side](placement));\n    }), data.offsets.popper = popper, data;\n  }\n\n  function shift(data) {\n    var placement = data.placement,\n        basePlacement = placement.split(\"-\")[0],\n        shiftvariation = placement.split(\"-\")[1];\n\n    if (shiftvariation) {\n      var _data$offsets = data.offsets,\n          reference = _data$offsets.reference,\n          popper = _data$offsets.popper,\n          isVertical = -1 !== [\"bottom\", \"top\"].indexOf(basePlacement),\n          side = isVertical ? \"left\" : \"top\",\n          measurement = isVertical ? \"width\" : \"height\",\n          shiftOffsets = {\n        start: defineProperty({}, side, reference[side]),\n        end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])\n      };\n      data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);\n    }\n\n    return data;\n  }\n\n  function hide(data) {\n    if (!isModifierRequired(data.instance.modifiers, \"hide\", \"preventOverflow\")) return data;\n    var refRect = data.offsets.reference,\n        bound = find(data.instance.modifiers, function (modifier) {\n      return \"preventOverflow\" === modifier.name;\n    }).boundaries;\n\n    if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {\n      if (!0 === data.hide) return data;\n      data.hide = !0, data.attributes[\"x-out-of-boundaries\"] = \"\";\n    } else {\n      if (!1 === data.hide) return data;\n      data.hide = !1, data.attributes[\"x-out-of-boundaries\"] = !1;\n    }\n\n    return data;\n  }\n\n  function inner(data) {\n    var placement = data.placement,\n        basePlacement = placement.split(\"-\")[0],\n        _data$offsets = data.offsets,\n        popper = _data$offsets.popper,\n        reference = _data$offsets.reference,\n        isHoriz = -1 !== [\"left\", \"right\"].indexOf(basePlacement),\n        subtractLength = -1 === [\"top\", \"left\"].indexOf(basePlacement);\n    return popper[isHoriz ? \"left\" : \"top\"] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? \"width\" : \"height\"] : 0), data.placement = getOppositePlacement(placement), data.offsets.popper = getClientRect(popper), data;\n  }\n\n  function convertToArray(value) {\n    return \"string\" == typeof value && (value = value.split(\" \")), value;\n  }\n\n  function addClasses(el, classes) {\n    var newClasses = convertToArray(classes),\n        classList = void 0;\n    classList = convertToArray(el.className instanceof SVGAnimatedString ? el.className.baseVal : el.className), newClasses.forEach(function (newClass) {\n      -1 === classList.indexOf(newClass) && classList.push(newClass);\n    }), el instanceof SVGElement ? el.setAttribute(\"class\", classList.join(\" \")) : el.className = classList.join(\" \");\n  }\n\n  function removeClasses(el, classes) {\n    var newClasses = convertToArray(classes),\n        classList = void 0;\n    classList = convertToArray(el.className instanceof SVGAnimatedString ? el.className.baseVal : el.className), newClasses.forEach(function (newClass) {\n      var index = classList.indexOf(newClass);\n      -1 !== index && classList.splice(index, 1);\n    }), el instanceof SVGElement ? el.setAttribute(\"class\", classList.join(\" \")) : el.className = classList.join(\" \");\n  }\n\n  function getOptions(options) {\n    var result = {\n      placement: void 0 !== options.placement ? options.placement : directive.options.defaultPlacement,\n      delay: void 0 !== options.delay ? options.delay : directive.options.defaultDelay,\n      html: void 0 !== options.html ? options.html : directive.options.defaultHtml,\n      template: void 0 !== options.template ? options.template : directive.options.defaultTemplate,\n      arrowSelector: void 0 !== options.arrowSelector ? options.arrowSelector : directive.options.defaultArrowSelector,\n      innerSelector: void 0 !== options.innerSelector ? options.innerSelector : directive.options.defaultInnerSelector,\n      trigger: void 0 !== options.trigger ? options.trigger : directive.options.defaultTrigger,\n      offset: void 0 !== options.offset ? options.offset : directive.options.defaultOffset,\n      container: void 0 !== options.container ? options.container : directive.options.defaultContainer,\n      boundariesElement: void 0 !== options.boundariesElement ? options.boundariesElement : directive.options.defaultBoundariesElement,\n      autoHide: void 0 !== options.autoHide ? options.autoHide : directive.options.autoHide,\n      hideOnTargetClick: void 0 !== options.hideOnTargetClick ? options.hideOnTargetClick : directive.options.defaultHideOnTargetClick,\n      loadingClass: void 0 !== options.loadingClass ? options.loadingClass : directive.options.defaultLoadingClass,\n      loadingContent: void 0 !== options.loadingContent ? options.loadingContent : directive.options.defaultLoadingContent,\n      popperOptions: _extends$1({}, void 0 !== options.popperOptions ? options.popperOptions : directive.options.defaultPopperOptions)\n    };\n\n    if (result.offset) {\n      var typeofOffset = _typeof(result.offset),\n          offset = result.offset;\n\n      (\"number\" === typeofOffset || \"string\" === typeofOffset && -1 === offset.indexOf(\",\")) && (offset = \"0, \" + offset), result.popperOptions.modifiers || (result.popperOptions.modifiers = {}), result.popperOptions.modifiers.offset = {\n        offset: offset\n      };\n    }\n\n    return result;\n  }\n\n  function getPlacement(value, modifiers) {\n    for (var placement = value.placement, i = 0; i < positions.length; i++) {\n      var pos = positions[i];\n      modifiers[pos] && (placement = pos);\n    }\n\n    return placement;\n  }\n\n  function getContent(value) {\n    var type = void 0 === value ? \"undefined\" : _typeof(value);\n    return \"string\" === type ? value : !(!value || \"object\" !== type) && value.content;\n  }\n\n  function createTooltip(el, value) {\n    var modifiers = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},\n        content = getContent(value),\n        classes = void 0 !== value.classes ? value.classes : directive.options.defaultClass,\n        opts = _extends$1({\n      title: content\n    }, getOptions(_extends$1({}, value, {\n      placement: getPlacement(value, modifiers)\n    }))),\n        tooltip = el._tooltip = new Tooltip(el, opts);\n\n    tooltip.setClasses(classes), tooltip._vueEl = el;\n    var targetClasses = void 0 !== value.targetClasses ? value.targetClasses : directive.options.defaultTargetClass;\n    return el._tooltipTargetClasses = targetClasses, addClasses(el, targetClasses), tooltip;\n  }\n\n  function destroyTooltip(el) {\n    el._tooltip && (el._tooltip.dispose(), delete el._tooltip, delete el._tooltipOldShow), el._tooltipTargetClasses && (removeClasses(el, el._tooltipTargetClasses), delete el._tooltipTargetClasses);\n  }\n\n  function bind(el, _ref) {\n    var value = _ref.value,\n        modifiers = (_ref.oldValue, _ref.modifiers),\n        content = getContent(value);\n\n    if (content && state.enabled) {\n      var tooltip = void 0;\n      el._tooltip ? (tooltip = el._tooltip, tooltip.setContent(content), tooltip.setOptions(_extends$1({}, value, {\n        placement: getPlacement(value, modifiers)\n      }))) : tooltip = createTooltip(el, value, modifiers), void 0 !== value.show && value.show !== el._tooltipOldShow && (el._tooltipOldShow = value.show, value.show ? tooltip.show() : tooltip.hide());\n    } else destroyTooltip(el);\n  }\n\n  function addListeners(el) {\n    el.addEventListener(\"click\", onClick), el.addEventListener(\"touchstart\", onTouchStart, !!supportsPassive && {\n      passive: !0\n    });\n  }\n\n  function removeListeners(el) {\n    el.removeEventListener(\"click\", onClick), el.removeEventListener(\"touchstart\", onTouchStart), el.removeEventListener(\"touchend\", onTouchEnd), el.removeEventListener(\"touchcancel\", onTouchCancel);\n  }\n\n  function onClick(event) {\n    var el = event.currentTarget;\n    event.closePopover = !el.$_vclosepopover_touch, event.closeAllPopover = el.$_closePopoverModifiers && !!el.$_closePopoverModifiers.all;\n  }\n\n  function onTouchStart(event) {\n    if (1 === event.changedTouches.length) {\n      var el = event.currentTarget;\n      el.$_vclosepopover_touch = !0;\n      var touch = event.changedTouches[0];\n      el.$_vclosepopover_touchPoint = touch, el.addEventListener(\"touchend\", onTouchEnd), el.addEventListener(\"touchcancel\", onTouchCancel);\n    }\n  }\n\n  function onTouchEnd(event) {\n    var el = event.currentTarget;\n\n    if (el.$_vclosepopover_touch = !1, 1 === event.changedTouches.length) {\n      var touch = event.changedTouches[0],\n          firstTouch = el.$_vclosepopover_touchPoint;\n      event.closePopover = Math.abs(touch.screenY - firstTouch.screenY) < 20 && Math.abs(touch.screenX - firstTouch.screenX) < 20, event.closeAllPopover = el.$_closePopoverModifiers && !!el.$_closePopoverModifiers.all;\n    }\n  }\n\n  function onTouchCancel(event) {\n    event.currentTarget.$_vclosepopover_touch = !1;\n  }\n\n  function getInternetExplorerVersion() {\n    var ua = window.navigator.userAgent,\n        msie = ua.indexOf(\"MSIE \");\n    if (msie > 0) return parseInt(ua.substring(msie + 5, ua.indexOf(\".\", msie)), 10);\n\n    if (ua.indexOf(\"Trident/\") > 0) {\n      var rv = ua.indexOf(\"rv:\");\n      return parseInt(ua.substring(rv + 3, ua.indexOf(\".\", rv)), 10);\n    }\n\n    var edge = ua.indexOf(\"Edge/\");\n    return edge > 0 ? parseInt(ua.substring(edge + 5, ua.indexOf(\".\", edge)), 10) : -1;\n  }\n\n  function initCompat() {\n    initCompat.init || (initCompat.init = !0, isIE$1 = -1 !== getInternetExplorerVersion());\n  }\n\n  function install$1(Vue) {\n    Vue.component(\"resize-observer\", ResizeObserver);\n  }\n\n  function getDefault(key) {\n    var value = directive.options.popover[key];\n    return void 0 === value ? directive.options[key] : value;\n  }\n\n  function handleGlobalClick(event) {\n    handleGlobalClose(event);\n  }\n\n  function handleGlobalTouchend(event) {\n    handleGlobalClose(event, !0);\n  }\n\n  function handleGlobalClose(event) {\n    var touch = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];\n    requestAnimationFrame(function () {\n      for (var popover = void 0, i = 0; i < openPopovers.length; i++) if (popover = openPopovers[i], popover.$refs.popover) {\n        var contains = popover.$refs.popover.contains(event.target);\n        (event.closeAllPopover || event.closePopover && contains || popover.autoHide && !contains) && popover.$_handleGlobalClose(event, touch);\n      }\n    });\n  }\n\n  function install(Vue) {\n    var options = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};\n\n    if (!install.installed) {\n      install.installed = !0;\n      var finalOptions = {};\n      lodash_merge(finalOptions, defaultOptions, options), plugin.options = finalOptions, directive.options = finalOptions, Vue.directive(\"tooltip\", directive), Vue.directive(\"close-popover\", vclosepopover), Vue.component(\"v-popover\", Popover);\n    }\n  }\n\n  __webpack_require__.d(__webpack_exports__, \"a\", function () {\n    return VTooltip;\n  });\n\n  for (var _typeof2 = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, isBrowser = \"undefined\" != typeof window && \"undefined\" != typeof document, longerTimeoutBrowsers = [\"Edge\", \"Trident\", \"Firefox\"], timeoutDuration = 0, i = 0; i < longerTimeoutBrowsers.length; i += 1) if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {\n    timeoutDuration = 1;\n    break;\n  }\n\n  var supportsMicroTasks = isBrowser && window.Promise,\n      debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce,\n      isIE11 = isBrowser && !(!window.MSInputMethodContext || !document.documentMode),\n      isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent),\n      classCallCheck = function (instance, Constructor) {\n    if (!(instance instanceof Constructor)) throw new TypeError(\"Cannot call a class as a function\");\n  },\n      createClass = function () {\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, \"value\" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n\n    return function (Constructor, protoProps, staticProps) {\n      return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), Constructor;\n    };\n  }(),\n      defineProperty = function (obj, key, value) {\n    return key in obj ? Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }) : obj[key] = value, obj;\n  },\n      _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);\n    }\n\n    return target;\n  },\n      placements = [\"auto-start\", \"auto\", \"auto-end\", \"top-start\", \"top\", \"top-end\", \"right-start\", \"right\", \"right-end\", \"bottom-end\", \"bottom\", \"bottom-start\", \"left-end\", \"left\", \"left-start\"],\n      validPlacements = placements.slice(3),\n      BEHAVIORS = {\n    FLIP: \"flip\",\n    CLOCKWISE: \"clockwise\",\n    COUNTERCLOCKWISE: \"counterclockwise\"\n  },\n      modifiers = {\n    shift: {\n      order: 100,\n      enabled: !0,\n      fn: shift\n    },\n    offset: {\n      order: 200,\n      enabled: !0,\n      fn: offset,\n      offset: 0\n    },\n    preventOverflow: {\n      order: 300,\n      enabled: !0,\n      fn: preventOverflow,\n      priority: [\"left\", \"right\", \"top\", \"bottom\"],\n      padding: 5,\n      boundariesElement: \"scrollParent\"\n    },\n    keepTogether: {\n      order: 400,\n      enabled: !0,\n      fn: keepTogether\n    },\n    arrow: {\n      order: 500,\n      enabled: !0,\n      fn: arrow,\n      element: \"[x-arrow]\"\n    },\n    flip: {\n      order: 600,\n      enabled: !0,\n      fn: flip,\n      behavior: \"flip\",\n      padding: 5,\n      boundariesElement: \"viewport\"\n    },\n    inner: {\n      order: 700,\n      enabled: !1,\n      fn: inner\n    },\n    hide: {\n      order: 800,\n      enabled: !0,\n      fn: hide\n    },\n    computeStyle: {\n      order: 850,\n      enabled: !0,\n      fn: computeStyle,\n      gpuAcceleration: !0,\n      x: \"bottom\",\n      y: \"right\"\n    },\n    applyStyle: {\n      order: 900,\n      enabled: !0,\n      fn: applyStyle,\n      onLoad: applyStyleOnLoad,\n      gpuAcceleration: void 0\n    }\n  },\n      Defaults = {\n    placement: \"bottom\",\n    positionFixed: !1,\n    eventsEnabled: !0,\n    removeOnDestroy: !1,\n    onCreate: function () {},\n    onUpdate: function () {},\n    modifiers: modifiers\n  },\n      Popper = function () {\n    function Popper(reference, popper) {\n      var _this = this,\n          options = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};\n\n      classCallCheck(this, Popper), this.scheduleUpdate = function () {\n        return requestAnimationFrame(_this.update);\n      }, this.update = debounce(this.update.bind(this)), this.options = _extends({}, Popper.Defaults, options), this.state = {\n        isDestroyed: !1,\n        isCreated: !1,\n        scrollParents: []\n      }, this.reference = reference && reference.jquery ? reference[0] : reference, this.popper = popper && popper.jquery ? popper[0] : popper, this.options.modifiers = {}, Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {\n        _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});\n      }), this.modifiers = Object.keys(this.options.modifiers).map(function (name) {\n        return _extends({\n          name: name\n        }, _this.options.modifiers[name]);\n      }).sort(function (a, b) {\n        return a.order - b.order;\n      }), this.modifiers.forEach(function (modifierOptions) {\n        modifierOptions.enabled && isFunction(modifierOptions.onLoad) && modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);\n      }), this.update();\n      var eventsEnabled = this.options.eventsEnabled;\n      eventsEnabled && this.enableEventListeners(), this.state.eventsEnabled = eventsEnabled;\n    }\n\n    return createClass(Popper, [{\n      key: \"update\",\n      value: function () {\n        return update.call(this);\n      }\n    }, {\n      key: \"destroy\",\n      value: function () {\n        return destroy.call(this);\n      }\n    }, {\n      key: \"enableEventListeners\",\n      value: function () {\n        return enableEventListeners.call(this);\n      }\n    }, {\n      key: \"disableEventListeners\",\n      value: function () {\n        return disableEventListeners.call(this);\n      }\n    }]), Popper;\n  }();\n\n  Popper.Utils = (\"undefined\" != typeof window ? window : global).PopperUtils, Popper.placements = placements, Popper.Defaults = Defaults;\n\n  var SVGAnimatedString = function () {};\n\n  \"undefined\" != typeof window && (SVGAnimatedString = window.SVGAnimatedString);\n  var supportsPassive = !1;\n\n  if (\"undefined\" != typeof window) {\n    supportsPassive = !1;\n\n    try {\n      var opts = Object.defineProperty({}, \"passive\", {\n        get: function () {\n          supportsPassive = !0;\n        }\n      });\n      window.addEventListener(\"test\", null, opts);\n    } catch (e) {}\n  }\n\n  var _typeof = \"function\" == typeof Symbol && \"symbol\" === _typeof2(Symbol.iterator) ? function (obj) {\n    return void 0 === obj ? \"undefined\" : _typeof2(obj);\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : void 0 === obj ? \"undefined\" : _typeof2(obj);\n  },\n      classCallCheck$1 = function (instance, Constructor) {\n    if (!(instance instanceof Constructor)) throw new TypeError(\"Cannot call a class as a function\");\n  },\n      createClass$1 = function () {\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, \"value\" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n\n    return function (Constructor, protoProps, staticProps) {\n      return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), Constructor;\n    };\n  }(),\n      _extends$1 = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);\n    }\n\n    return target;\n  },\n      DEFAULT_OPTIONS = {\n    container: !1,\n    delay: 0,\n    html: !1,\n    placement: \"top\",\n    title: \"\",\n    template: '<div class=\"tooltip\" role=\"tooltip\"><div class=\"tooltip-arrow\"></div><div class=\"tooltip-inner\"></div></div>',\n    trigger: \"hover focus\",\n    offset: 0\n  },\n      openTooltips = [],\n      Tooltip = function () {\n    function Tooltip(reference, options) {\n      classCallCheck$1(this, Tooltip), _initialiseProps.call(this), options = _extends$1({}, DEFAULT_OPTIONS, options), reference.jquery && (reference = reference[0]), this.reference = reference, this.options = options, this._isOpen = !1, this._init();\n    }\n\n    return createClass$1(Tooltip, [{\n      key: \"setClasses\",\n      value: function (classes) {\n        this._classes = classes;\n      }\n    }, {\n      key: \"setContent\",\n      value: function (content) {\n        this.options.title = content, this._tooltipNode && this._setContent(content, this.options);\n      }\n    }, {\n      key: \"setOptions\",\n      value: function (options) {\n        var classesUpdated = !1,\n            classes = options && options.classes || directive.options.defaultClass;\n        this._classes !== classes && (this.setClasses(classes), classesUpdated = !0), options = getOptions(options);\n        var needPopperUpdate = !1,\n            needRestart = !1;\n        this.options.offset === options.offset && this.options.placement === options.placement || (needPopperUpdate = !0), (this.options.template !== options.template || this.options.trigger !== options.trigger || this.options.container !== options.container || classesUpdated) && (needRestart = !0);\n\n        for (var key in options) this.options[key] = options[key];\n\n        if (this._tooltipNode) if (needRestart) {\n          var isOpen = this._isOpen;\n          this.dispose(), this._init(), isOpen && this.show();\n        } else needPopperUpdate && this.popperInstance.update();\n      }\n    }, {\n      key: \"_init\",\n      value: function () {\n        var events = \"string\" == typeof this.options.trigger ? this.options.trigger.split(\" \").filter(function (trigger) {\n          return -1 !== [\"click\", \"hover\", \"focus\"].indexOf(trigger);\n        }) : [];\n        this._isDisposed = !1, this._enableDocumentTouch = -1 === events.indexOf(\"manual\"), this._setEventListeners(this.reference, events, this.options);\n      }\n    }, {\n      key: \"_create\",\n      value: function (reference, template) {\n        var tooltipGenerator = window.document.createElement(\"div\");\n        tooltipGenerator.innerHTML = template.trim();\n        var tooltipNode = tooltipGenerator.childNodes[0];\n        return tooltipNode.id = \"tooltip_\" + Math.random().toString(36).substr(2, 10), tooltipNode.setAttribute(\"aria-hidden\", \"true\"), this.options.autoHide && -1 !== this.options.trigger.indexOf(\"hover\") && (tooltipNode.addEventListener(\"mouseenter\", this.hide), tooltipNode.addEventListener(\"click\", this.hide)), tooltipNode;\n      }\n    }, {\n      key: \"_setContent\",\n      value: function (content, options) {\n        var _this = this;\n\n        this.asyncContent = !1, this._applyContent(content, options).then(function () {\n          _this.popperInstance.update();\n        });\n      }\n    }, {\n      key: \"_applyContent\",\n      value: function (title, options) {\n        var _this2 = this;\n\n        return new Promise(function (resolve, reject) {\n          var allowHtml = options.html,\n              rootNode = _this2._tooltipNode,\n              titleNode = rootNode.querySelector(_this2.options.innerSelector);\n\n          if (1 === title.nodeType) {\n            if (allowHtml) {\n              for (; titleNode.firstChild;) titleNode.removeChild(titleNode.firstChild);\n\n              titleNode.appendChild(title);\n            }\n          } else {\n            if (\"function\" == typeof title) {\n              var result = title();\n              return void (result && \"function\" == typeof result.then ? (_this2.asyncContent = !0, options.loadingClass && addClasses(rootNode, options.loadingClass), options.loadingContent && _this2._applyContent(options.loadingContent, options), result.then(function (asyncResult) {\n                return options.loadingClass && removeClasses(rootNode, options.loadingClass), _this2._applyContent(asyncResult, options);\n              }).then(resolve).catch(reject)) : _this2._applyContent(result, options).then(resolve).catch(reject));\n            }\n\n            allowHtml ? titleNode.innerHTML = title : titleNode.innerText = title;\n          }\n\n          resolve();\n        });\n      }\n    }, {\n      key: \"_show\",\n      value: function (reference, options) {\n        if (options && \"string\" == typeof options.container) {\n          if (!document.querySelector(options.container)) return;\n        }\n\n        clearTimeout(this._disposeTimer), options = Object.assign({}, options), delete options.offset;\n        var updateClasses = !0;\n        this._tooltipNode && (addClasses(this._tooltipNode, this._classes), updateClasses = !1);\n\n        var result = this._ensureShown(reference, options);\n\n        return updateClasses && this._tooltipNode && addClasses(this._tooltipNode, this._classes), addClasses(reference, [\"v-tooltip-open\"]), result;\n      }\n    }, {\n      key: \"_ensureShown\",\n      value: function (reference, options) {\n        var _this3 = this;\n\n        if (this._isOpen) return this;\n        if (this._isOpen = !0, openTooltips.push(this), this._tooltipNode) return this._tooltipNode.style.display = \"\", this._tooltipNode.setAttribute(\"aria-hidden\", \"false\"), this.popperInstance.enableEventListeners(), this.popperInstance.update(), this.asyncContent && this._setContent(options.title, options), this;\n        var title = reference.getAttribute(\"title\") || options.title;\n        if (!title) return this;\n\n        var tooltipNode = this._create(reference, options.template);\n\n        this._tooltipNode = tooltipNode, this._setContent(title, options), reference.setAttribute(\"aria-describedby\", tooltipNode.id);\n\n        var container = this._findContainer(options.container, reference);\n\n        this._append(tooltipNode, container);\n\n        var popperOptions = _extends$1({}, options.popperOptions, {\n          placement: options.placement\n        });\n\n        return popperOptions.modifiers = _extends$1({}, popperOptions.modifiers, {\n          arrow: {\n            element: this.options.arrowSelector\n          }\n        }), options.boundariesElement && (popperOptions.modifiers.preventOverflow = {\n          boundariesElement: options.boundariesElement\n        }), this.popperInstance = new Popper(reference, tooltipNode, popperOptions), requestAnimationFrame(function () {\n          !_this3._isDisposed && _this3.popperInstance ? (_this3.popperInstance.update(), requestAnimationFrame(function () {\n            _this3._isDisposed ? _this3.dispose() : _this3._isOpen && tooltipNode.setAttribute(\"aria-hidden\", \"false\");\n          })) : _this3.dispose();\n        }), this;\n      }\n    }, {\n      key: \"_noLongerOpen\",\n      value: function () {\n        var index = openTooltips.indexOf(this);\n        -1 !== index && openTooltips.splice(index, 1);\n      }\n    }, {\n      key: \"_hide\",\n      value: function () {\n        var _this4 = this;\n\n        if (!this._isOpen) return this;\n        this._isOpen = !1, this._noLongerOpen(), this._tooltipNode.style.display = \"none\", this._tooltipNode.setAttribute(\"aria-hidden\", \"true\"), this.popperInstance.disableEventListeners(), clearTimeout(this._disposeTimer);\n        var disposeTime = directive.options.disposeTimeout;\n        return null !== disposeTime && (this._disposeTimer = setTimeout(function () {\n          _this4._tooltipNode && (_this4._tooltipNode.removeEventListener(\"mouseenter\", _this4.hide), _this4._tooltipNode.removeEventListener(\"click\", _this4.hide), _this4._tooltipNode.parentNode.removeChild(_this4._tooltipNode), _this4._tooltipNode = null);\n        }, disposeTime)), removeClasses(this.reference, [\"v-tooltip-open\"]), this;\n      }\n    }, {\n      key: \"_dispose\",\n      value: function () {\n        var _this5 = this;\n\n        return this._isDisposed = !0, this._events.forEach(function (_ref) {\n          var func = _ref.func,\n              event = _ref.event;\n\n          _this5.reference.removeEventListener(event, func);\n        }), this._events = [], this._tooltipNode ? (this._hide(), this._tooltipNode.removeEventListener(\"mouseenter\", this.hide), this._tooltipNode.removeEventListener(\"click\", this.hide), this.popperInstance.destroy(), this.popperInstance.options.removeOnDestroy || (this._tooltipNode.parentNode.removeChild(this._tooltipNode), this._tooltipNode = null)) : this._noLongerOpen(), this;\n      }\n    }, {\n      key: \"_findContainer\",\n      value: function (container, reference) {\n        return \"string\" == typeof container ? container = window.document.querySelector(container) : !1 === container && (container = reference.parentNode), container;\n      }\n    }, {\n      key: \"_append\",\n      value: function (tooltipNode, container) {\n        container.appendChild(tooltipNode);\n      }\n    }, {\n      key: \"_setEventListeners\",\n      value: function (reference, events, options) {\n        var _this6 = this,\n            directEvents = [],\n            oppositeEvents = [];\n\n        events.forEach(function (event) {\n          switch (event) {\n            case \"hover\":\n              directEvents.push(\"mouseenter\"), oppositeEvents.push(\"mouseleave\"), _this6.options.hideOnTargetClick && oppositeEvents.push(\"click\");\n              break;\n\n            case \"focus\":\n              directEvents.push(\"focus\"), oppositeEvents.push(\"blur\"), _this6.options.hideOnTargetClick && oppositeEvents.push(\"click\");\n              break;\n\n            case \"click\":\n              directEvents.push(\"click\"), oppositeEvents.push(\"click\");\n          }\n        }), directEvents.forEach(function (event) {\n          var func = function (evt) {\n            !0 !== _this6._isOpen && (evt.usedByTooltip = !0, _this6._scheduleShow(reference, options.delay, options, evt));\n          };\n\n          _this6._events.push({\n            event: event,\n            func: func\n          }), reference.addEventListener(event, func);\n        }), oppositeEvents.forEach(function (event) {\n          var func = function (evt) {\n            !0 !== evt.usedByTooltip && _this6._scheduleHide(reference, options.delay, options, evt);\n          };\n\n          _this6._events.push({\n            event: event,\n            func: func\n          }), reference.addEventListener(event, func);\n        });\n      }\n    }, {\n      key: \"_onDocumentTouch\",\n      value: function (event) {\n        this._enableDocumentTouch && this._scheduleHide(this.reference, this.options.delay, this.options, event);\n      }\n    }, {\n      key: \"_scheduleShow\",\n      value: function (reference, delay, options) {\n        var _this7 = this,\n            computedDelay = delay && delay.show || delay || 0;\n\n        clearTimeout(this._scheduleTimer), this._scheduleTimer = window.setTimeout(function () {\n          return _this7._show(reference, options);\n        }, computedDelay);\n      }\n    }, {\n      key: \"_scheduleHide\",\n      value: function (reference, delay, options, evt) {\n        var _this8 = this,\n            computedDelay = delay && delay.hide || delay || 0;\n\n        clearTimeout(this._scheduleTimer), this._scheduleTimer = window.setTimeout(function () {\n          if (!1 !== _this8._isOpen && document.body.contains(_this8._tooltipNode)) {\n            if (\"mouseleave\" === evt.type) {\n              if (_this8._setTooltipNodeEvent(evt, reference, delay, options)) return;\n            }\n\n            _this8._hide(reference, options);\n          }\n        }, computedDelay);\n      }\n    }]), Tooltip;\n  }(),\n      _initialiseProps = function () {\n    var _this9 = this;\n\n    this.show = function () {\n      _this9._show(_this9.reference, _this9.options);\n    }, this.hide = function () {\n      _this9._hide();\n    }, this.dispose = function () {\n      _this9._dispose();\n    }, this.toggle = function () {\n      return _this9._isOpen ? _this9.hide() : _this9.show();\n    }, this._events = [], this._setTooltipNodeEvent = function (evt, reference, delay, options) {\n      var relatedreference = evt.relatedreference || evt.toElement || evt.relatedTarget,\n          callback = function callback(evt2) {\n        var relatedreference2 = evt2.relatedreference || evt2.toElement || evt2.relatedTarget;\n        _this9._tooltipNode.removeEventListener(evt.type, callback), reference.contains(relatedreference2) || _this9._scheduleHide(reference, options.delay, options, evt2);\n      };\n\n      return !!_this9._tooltipNode.contains(relatedreference) && (_this9._tooltipNode.addEventListener(evt.type, callback), !0);\n    };\n  };\n\n  \"undefined\" != typeof document && document.addEventListener(\"touchstart\", function (event) {\n    for (var i = 0; i < openTooltips.length; i++) openTooltips[i]._onDocumentTouch(event);\n  }, !supportsPassive || {\n    passive: !0,\n    capture: !0\n  });\n  var state = {\n    enabled: !0\n  },\n      positions = [\"top\", \"top-start\", \"top-end\", \"right\", \"right-start\", \"right-end\", \"bottom\", \"bottom-start\", \"bottom-end\", \"left\", \"left-start\", \"left-end\"],\n      defaultOptions = {\n    defaultPlacement: \"top\",\n    defaultClass: \"vue-tooltip-theme\",\n    defaultTargetClass: \"has-tooltip\",\n    defaultHtml: !0,\n    defaultTemplate: '<div class=\"tooltip\" role=\"tooltip\"><div class=\"tooltip-arrow\"></div><div class=\"tooltip-inner\"></div></div>',\n    defaultArrowSelector: \".tooltip-arrow, .tooltip__arrow\",\n    defaultInnerSelector: \".tooltip-inner, .tooltip__inner\",\n    defaultDelay: 0,\n    defaultTrigger: \"hover focus\",\n    defaultOffset: 0,\n    defaultContainer: \"body\",\n    defaultBoundariesElement: void 0,\n    defaultPopperOptions: {},\n    defaultLoadingClass: \"tooltip-loading\",\n    defaultLoadingContent: \"...\",\n    autoHide: !0,\n    defaultHideOnTargetClick: !0,\n    disposeTimeout: 5e3,\n    popover: {\n      defaultPlacement: \"bottom\",\n      defaultClass: \"vue-popover-theme\",\n      defaultBaseClass: \"tooltip popover\",\n      defaultWrapperClass: \"wrapper\",\n      defaultInnerClass: \"tooltip-inner popover-inner\",\n      defaultArrowClass: \"tooltip-arrow popover-arrow\",\n      defaultDelay: 0,\n      defaultTrigger: \"click\",\n      defaultOffset: 0,\n      defaultContainer: \"body\",\n      defaultBoundariesElement: void 0,\n      defaultPopperOptions: {},\n      defaultAutoHide: !0,\n      defaultHandleResize: !0\n    }\n  },\n      directive = {\n    options: defaultOptions,\n    bind: bind,\n    update: bind,\n    unbind: function (el) {\n      destroyTooltip(el);\n    }\n  },\n      vclosepopover = {\n    bind: function (el, _ref) {\n      var value = _ref.value,\n          modifiers = _ref.modifiers;\n      el.$_closePopoverModifiers = modifiers, (void 0 === value || value) && addListeners(el);\n    },\n    update: function (el, _ref2) {\n      var value = _ref2.value,\n          oldValue = _ref2.oldValue,\n          modifiers = _ref2.modifiers;\n      el.$_closePopoverModifiers = modifiers, value !== oldValue && (void 0 === value || value ? addListeners(el) : removeListeners(el));\n    },\n    unbind: function (el) {\n      removeListeners(el);\n    }\n  },\n      isIE$1 = void 0,\n      ResizeObserver = {\n    render: function () {\n      var _vm = this,\n          _h = _vm.$createElement;\n\n      return (_vm._self._c || _h)(\"div\", {\n        staticClass: \"resize-observer\",\n        attrs: {\n          tabindex: \"-1\"\n        }\n      });\n    },\n    staticRenderFns: [],\n    _scopeId: \"data-v-b329ee4c\",\n    name: \"resize-observer\",\n    methods: {\n      notify: function () {\n        this.$emit(\"notify\");\n      },\n      addResizeHandlers: function () {\n        this._resizeObject.contentDocument.defaultView.addEventListener(\"resize\", this.notify), this._w === this.$el.offsetWidth && this._h === this.$el.offsetHeight || this.notify();\n      },\n      removeResizeHandlers: function () {\n        this._resizeObject && this._resizeObject.onload && (!isIE$1 && this._resizeObject.contentDocument && this._resizeObject.contentDocument.defaultView.removeEventListener(\"resize\", this.notify), delete this._resizeObject.onload);\n      }\n    },\n    mounted: function () {\n      var _this = this;\n\n      initCompat(), this.$nextTick(function () {\n        _this._w = _this.$el.offsetWidth, _this._h = _this.$el.offsetHeight;\n      });\n      var object = document.createElement(\"object\");\n      this._resizeObject = object, object.setAttribute(\"style\", \"display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; pointer-events: none; z-index: -1;\"), object.setAttribute(\"aria-hidden\", \"true\"), object.setAttribute(\"tabindex\", -1), object.onload = this.addResizeHandlers, object.type = \"text/html\", isIE$1 && this.$el.appendChild(object), object.data = \"about:blank\", isIE$1 || this.$el.appendChild(object);\n    },\n    beforeDestroy: function () {\n      this.removeResizeHandlers();\n    }\n  },\n      plugin$2 = {\n    version: \"0.4.4\",\n    install: install$1\n  },\n      GlobalVue$1 = null;\n  \"undefined\" != typeof window ? GlobalVue$1 = window.Vue : \"undefined\" != typeof global && (GlobalVue$1 = global.Vue), GlobalVue$1 && GlobalVue$1.use(plugin$2);\n  var isIOS = !1;\n  \"undefined\" != typeof window && \"undefined\" != typeof navigator && (isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream);\n\n  var openPopovers = [],\n      Element = function () {};\n\n  \"undefined\" != typeof window && (Element = window.Element);\n  var Popover = {\n    render: function () {\n      var _vm = this,\n          _h = _vm.$createElement,\n          _c = _vm._self._c || _h;\n\n      return _c(\"div\", {\n        staticClass: \"v-popover\",\n        class: _vm.cssClass\n      }, [_c(\"span\", {\n        ref: \"trigger\",\n        staticClass: \"trigger\",\n        staticStyle: {\n          display: \"inline-block\"\n        },\n        attrs: {\n          \"aria-describedby\": _vm.popoverId,\n          tabindex: -1 !== _vm.trigger.indexOf(\"focus\") ? 0 : -1\n        }\n      }, [_vm._t(\"default\")], 2), _vm._v(\" \"), _c(\"div\", {\n        ref: \"popover\",\n        class: [_vm.popoverBaseClass, _vm.popoverClass, _vm.cssClass],\n        style: {\n          visibility: _vm.isOpen ? \"visible\" : \"hidden\"\n        },\n        attrs: {\n          id: _vm.popoverId,\n          \"aria-hidden\": _vm.isOpen ? \"false\" : \"true\"\n        }\n      }, [_c(\"div\", {\n        class: _vm.popoverWrapperClass\n      }, [_c(\"div\", {\n        ref: \"inner\",\n        class: _vm.popoverInnerClass,\n        staticStyle: {\n          position: \"relative\"\n        }\n      }, [_c(\"div\", [_vm._t(\"popover\")], 2), _vm._v(\" \"), _vm.handleResize ? _c(\"ResizeObserver\", {\n        on: {\n          notify: _vm.$_handleResize\n        }\n      }) : _vm._e()], 1), _vm._v(\" \"), _c(\"div\", {\n        ref: \"arrow\",\n        class: _vm.popoverArrowClass\n      })])])]);\n    },\n    staticRenderFns: [],\n    name: \"VPopover\",\n    components: {\n      ResizeObserver: ResizeObserver\n    },\n    props: {\n      open: {\n        type: Boolean,\n        default: !1\n      },\n      disabled: {\n        type: Boolean,\n        default: !1\n      },\n      placement: {\n        type: String,\n        default: function () {\n          return getDefault(\"defaultPlacement\");\n        }\n      },\n      delay: {\n        type: [String, Number, Object],\n        default: function () {\n          return getDefault(\"defaultDelay\");\n        }\n      },\n      offset: {\n        type: [String, Number],\n        default: function () {\n          return getDefault(\"defaultOffset\");\n        }\n      },\n      trigger: {\n        type: String,\n        default: function () {\n          return getDefault(\"defaultTrigger\");\n        }\n      },\n      container: {\n        type: [String, Object, Element],\n        default: function () {\n          return getDefault(\"defaultContainer\");\n        }\n      },\n      boundariesElement: {\n        type: Element,\n        default: function () {\n          return getDefault(\"defaultBoundariesElement\");\n        }\n      },\n      popperOptions: {\n        type: Object,\n        default: function () {\n          return getDefault(\"defaultPopperOptions\");\n        }\n      },\n      popoverClass: {\n        type: [String, Array],\n        default: function () {\n          return getDefault(\"defaultClass\");\n        }\n      },\n      popoverBaseClass: {\n        type: [String, Array],\n        default: function () {\n          return directive.options.popover.defaultBaseClass;\n        }\n      },\n      popoverInnerClass: {\n        type: [String, Array],\n        default: function () {\n          return directive.options.popover.defaultInnerClass;\n        }\n      },\n      popoverWrapperClass: {\n        type: [String, Array],\n        default: function () {\n          return directive.options.popover.defaultWrapperClass;\n        }\n      },\n      popoverArrowClass: {\n        type: [String, Array],\n        default: function () {\n          return directive.options.popover.defaultArrowClass;\n        }\n      },\n      autoHide: {\n        type: Boolean,\n        default: function () {\n          return directive.options.popover.defaultAutoHide;\n        }\n      },\n      handleResize: {\n        type: Boolean,\n        default: function () {\n          return directive.options.popover.defaultHandleResize;\n        }\n      },\n      openGroup: {\n        type: String,\n        default: null\n      }\n    },\n    data: function () {\n      return {\n        isOpen: !1,\n        id: Math.random().toString(36).substr(2, 10)\n      };\n    },\n    computed: {\n      cssClass: function () {\n        return {\n          open: this.isOpen\n        };\n      },\n      popoverId: function () {\n        return \"popover_\" + this.id;\n      }\n    },\n    watch: {\n      open: function (val) {\n        val ? this.show() : this.hide();\n      },\n      disabled: function (val, oldVal) {\n        val !== oldVal && (val ? this.hide() : this.open && this.show());\n      },\n      container: function (val) {\n        if (this.isOpen && this.popperInstance) {\n          var popoverNode = this.$refs.popover,\n              reference = this.$refs.trigger,\n              container = this.$_findContainer(this.container, reference);\n          if (!container) return void console.warn(\"No container for popover\", this);\n          container.appendChild(popoverNode), this.popperInstance.scheduleUpdate();\n        }\n      },\n      trigger: function (val) {\n        this.$_removeEventListeners(), this.$_addEventListeners();\n      },\n      placement: function (val) {\n        var _this = this;\n\n        this.$_updatePopper(function () {\n          _this.popperInstance.options.placement = val;\n        });\n      },\n      offset: \"$_restartPopper\",\n      boundariesElement: \"$_restartPopper\",\n      popperOptions: {\n        handler: \"$_restartPopper\",\n        deep: !0\n      }\n    },\n    created: function () {\n      this.$_isDisposed = !1, this.$_mounted = !1, this.$_events = [], this.$_preventOpen = !1;\n    },\n    mounted: function () {\n      var popoverNode = this.$refs.popover;\n      popoverNode.parentNode && popoverNode.parentNode.removeChild(popoverNode), this.$_init(), this.open && this.show();\n    },\n    beforeDestroy: function () {\n      this.dispose();\n    },\n    methods: {\n      show: function () {\n        var _this2 = this,\n            _ref = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},\n            event = _ref.event,\n            _ref$force = (_ref.skipDelay, _ref.force);\n\n        !(void 0 !== _ref$force && _ref$force) && this.disabled || (this.$_scheduleShow(event), this.$emit(\"show\")), this.$emit(\"update:open\", !0), this.$_beingShowed = !0, requestAnimationFrame(function () {\n          _this2.$_beingShowed = !1;\n        });\n      },\n      hide: function () {\n        var _ref2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},\n            event = _ref2.event;\n\n        _ref2.skipDelay;\n        this.$_scheduleHide(event), this.$emit(\"hide\"), this.$emit(\"update:open\", !1);\n      },\n      dispose: function () {\n        if (this.$_isDisposed = !0, this.$_removeEventListeners(), this.hide({\n          skipDelay: !0\n        }), this.popperInstance && (this.popperInstance.destroy(), !this.popperInstance.options.removeOnDestroy)) {\n          var popoverNode = this.$refs.popover;\n          popoverNode.parentNode && popoverNode.parentNode.removeChild(popoverNode);\n        }\n\n        this.$_mounted = !1, this.popperInstance = null, this.isOpen = !1, this.$emit(\"dispose\");\n      },\n      $_init: function () {\n        -1 === this.trigger.indexOf(\"manual\") && this.$_addEventListeners();\n      },\n      $_show: function () {\n        var _this3 = this,\n            reference = this.$refs.trigger,\n            popoverNode = this.$refs.popover;\n\n        if (clearTimeout(this.$_disposeTimer), !this.isOpen) {\n          if (this.popperInstance && (this.isOpen = !0, this.popperInstance.enableEventListeners(), this.popperInstance.scheduleUpdate()), !this.$_mounted) {\n            var container = this.$_findContainer(this.container, reference);\n            if (!container) return void console.warn(\"No container for popover\", this);\n            container.appendChild(popoverNode), this.$_mounted = !0;\n          }\n\n          if (!this.popperInstance) {\n            var popperOptions = _extends$1({}, this.popperOptions, {\n              placement: this.placement\n            });\n\n            if (popperOptions.modifiers = _extends$1({}, popperOptions.modifiers, {\n              arrow: {\n                element: this.$refs.arrow\n              }\n            }), this.offset) {\n              var offset = this.$_getOffset();\n              popperOptions.modifiers.offset = {\n                offset: offset\n              };\n            }\n\n            this.boundariesElement && (popperOptions.modifiers.preventOverflow = {\n              boundariesElement: this.boundariesElement\n            }), this.popperInstance = new Popper(reference, popoverNode, popperOptions), requestAnimationFrame(function () {\n              !_this3.$_isDisposed && _this3.popperInstance ? (_this3.popperInstance.scheduleUpdate(), requestAnimationFrame(function () {\n                _this3.$_isDisposed ? _this3.dispose() : _this3.isOpen = !0;\n              })) : _this3.dispose();\n            });\n          }\n\n          var openGroup = this.openGroup;\n          if (openGroup) for (var popover = void 0, i = 0; i < openPopovers.length; i++) popover = openPopovers[i], popover.openGroup !== openGroup && (popover.hide(), popover.$emit(\"close-group\"));\n          openPopovers.push(this), this.$emit(\"apply-show\");\n        }\n      },\n      $_hide: function () {\n        var _this4 = this;\n\n        if (this.isOpen) {\n          var index = openPopovers.indexOf(this);\n          -1 !== index && openPopovers.splice(index, 1), this.isOpen = !1, this.popperInstance && this.popperInstance.disableEventListeners(), clearTimeout(this.$_disposeTimer);\n          var disposeTime = directive.options.popover.disposeTimeout || directive.options.disposeTimeout;\n          null !== disposeTime && (this.$_disposeTimer = setTimeout(function () {\n            var popoverNode = _this4.$refs.popover;\n            popoverNode && (popoverNode.parentNode && popoverNode.parentNode.removeChild(popoverNode), _this4.$_mounted = !1);\n          }, disposeTime)), this.$emit(\"apply-hide\");\n        }\n      },\n      $_findContainer: function (container, reference) {\n        return \"string\" == typeof container ? container = window.document.querySelector(container) : !1 === container && (container = reference.parentNode), container;\n      },\n      $_getOffset: function () {\n        var typeofOffset = _typeof(this.offset),\n            offset = this.offset;\n\n        return (\"number\" === typeofOffset || \"string\" === typeofOffset && -1 === offset.indexOf(\",\")) && (offset = \"0, \" + offset), offset;\n      },\n      $_addEventListeners: function () {\n        var _this5 = this,\n            reference = this.$refs.trigger,\n            directEvents = [],\n            oppositeEvents = [];\n\n        (\"string\" == typeof this.trigger ? this.trigger.split(\" \").filter(function (trigger) {\n          return -1 !== [\"click\", \"hover\", \"focus\"].indexOf(trigger);\n        }) : []).forEach(function (event) {\n          switch (event) {\n            case \"hover\":\n              directEvents.push(\"mouseenter\"), oppositeEvents.push(\"mouseleave\");\n              break;\n\n            case \"focus\":\n              directEvents.push(\"focus\"), oppositeEvents.push(\"blur\");\n              break;\n\n            case \"click\":\n              directEvents.push(\"click\"), oppositeEvents.push(\"click\");\n          }\n        }), directEvents.forEach(function (event) {\n          var func = function (event) {\n            _this5.isOpen || (event.usedByTooltip = !0, !_this5.$_preventOpen && _this5.show({\n              event: event\n            }));\n          };\n\n          _this5.$_events.push({\n            event: event,\n            func: func\n          }), reference.addEventListener(event, func);\n        }), oppositeEvents.forEach(function (event) {\n          var func = function (event) {\n            event.usedByTooltip || _this5.hide({\n              event: event\n            });\n          };\n\n          _this5.$_events.push({\n            event: event,\n            func: func\n          }), reference.addEventListener(event, func);\n        });\n      },\n      $_scheduleShow: function () {\n        var skipDelay = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];\n        if (clearTimeout(this.$_scheduleTimer), skipDelay) this.$_show();else {\n          var computedDelay = parseInt(this.delay && this.delay.show || this.delay || 0);\n          this.$_scheduleTimer = setTimeout(this.$_show.bind(this), computedDelay);\n        }\n      },\n      $_scheduleHide: function () {\n        var _this6 = this,\n            event = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,\n            skipDelay = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];\n\n        if (clearTimeout(this.$_scheduleTimer), skipDelay) this.$_hide();else {\n          var computedDelay = parseInt(this.delay && this.delay.hide || this.delay || 0);\n          this.$_scheduleTimer = setTimeout(function () {\n            if (_this6.isOpen) {\n              if (event && \"mouseleave\" === event.type) {\n                if (_this6.$_setTooltipNodeEvent(event)) return;\n              }\n\n              _this6.$_hide();\n            }\n          }, computedDelay);\n        }\n      },\n      $_setTooltipNodeEvent: function (event) {\n        var _this7 = this,\n            reference = this.$refs.trigger,\n            popoverNode = this.$refs.popover,\n            relatedreference = event.relatedreference || event.toElement || event.relatedTarget,\n            callback = function callback(event2) {\n          var relatedreference2 = event2.relatedreference || event2.toElement || event2.relatedTarget;\n          popoverNode.removeEventListener(event.type, callback), reference.contains(relatedreference2) || _this7.hide({\n            event: event2\n          });\n        };\n\n        return !!popoverNode.contains(relatedreference) && (popoverNode.addEventListener(event.type, callback), !0);\n      },\n      $_removeEventListeners: function () {\n        var reference = this.$refs.trigger;\n        this.$_events.forEach(function (_ref3) {\n          var func = _ref3.func,\n              event = _ref3.event;\n          reference.removeEventListener(event, func);\n        }), this.$_events = [];\n      },\n      $_updatePopper: function (cb) {\n        this.popperInstance && (cb(), this.isOpen && this.popperInstance.scheduleUpdate());\n      },\n      $_restartPopper: function () {\n        if (this.popperInstance) {\n          var isOpen = this.isOpen;\n          this.dispose(), this.$_isDisposed = !1, this.$_init(), isOpen && this.show({\n            skipDelay: !0,\n            force: !0\n          });\n        }\n      },\n      $_handleGlobalClose: function (event) {\n        var _this8 = this,\n            touch = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];\n\n        this.$_beingShowed || (this.hide({\n          event: event\n        }), event.closePopover ? this.$emit(\"close-directive\") : this.$emit(\"auto-hide\"), touch && (this.$_preventOpen = !0, setTimeout(function () {\n          _this8.$_preventOpen = !1;\n        }, 300)));\n      },\n      $_handleResize: function () {\n        this.isOpen && this.popperInstance && (this.popperInstance.scheduleUpdate(), this.$emit(\"resize\"));\n      }\n    }\n  };\n  \"undefined\" != typeof document && \"undefined\" != typeof window && (isIOS ? document.addEventListener(\"touchend\", handleGlobalTouchend, !supportsPassive || {\n    passive: !0,\n    capture: !0\n  }) : window.addEventListener(\"click\", handleGlobalClick, !0));\n\n  var commonjsGlobal = \"undefined\" != typeof window ? window : \"undefined\" != typeof global ? global : \"undefined\" != typeof self ? self : {},\n      lodash_merge = function (fn, module) {\n    return module = {\n      exports: {}\n    }, fn(module, module.exports), module.exports;\n  }(function (module, exports) {\n    function apply(func, thisArg, args) {\n      switch (args.length) {\n        case 0:\n          return func.call(thisArg);\n\n        case 1:\n          return func.call(thisArg, args[0]);\n\n        case 2:\n          return func.call(thisArg, args[0], args[1]);\n\n        case 3:\n          return func.call(thisArg, args[0], args[1], args[2]);\n      }\n\n      return func.apply(thisArg, args);\n    }\n\n    function baseTimes(n, iteratee) {\n      for (var index = -1, result = Array(n); ++index < n;) result[index] = iteratee(index);\n\n      return result;\n    }\n\n    function getValue(object, key) {\n      return null == object ? void 0 : object[key];\n    }\n\n    function safeGet(object, key) {\n      return \"__proto__\" == key ? void 0 : object[key];\n    }\n\n    function Hash(entries) {\n      var index = -1,\n          length = null == entries ? 0 : entries.length;\n\n      for (this.clear(); ++index < length;) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n\n    function hashClear() {\n      this.__data__ = nativeCreate ? nativeCreate(null) : {}, this.size = 0;\n    }\n\n    function hashDelete(key) {\n      var result = this.has(key) && delete this.__data__[key];\n      return this.size -= result ? 1 : 0, result;\n    }\n\n    function hashGet(key) {\n      var data = this.__data__;\n\n      if (nativeCreate) {\n        var result = data[key];\n        return result === HASH_UNDEFINED ? void 0 : result;\n      }\n\n      return hasOwnProperty.call(data, key) ? data[key] : void 0;\n    }\n\n    function hashHas(key) {\n      var data = this.__data__;\n      return nativeCreate ? void 0 !== data[key] : hasOwnProperty.call(data, key);\n    }\n\n    function hashSet(key, value) {\n      var data = this.__data__;\n      return this.size += this.has(key) ? 0 : 1, data[key] = nativeCreate && void 0 === value ? HASH_UNDEFINED : value, this;\n    }\n\n    function ListCache(entries) {\n      var index = -1,\n          length = null == entries ? 0 : entries.length;\n\n      for (this.clear(); ++index < length;) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n\n    function listCacheClear() {\n      this.__data__ = [], this.size = 0;\n    }\n\n    function listCacheDelete(key) {\n      var data = this.__data__,\n          index = assocIndexOf(data, key);\n      return !(index < 0) && (index == data.length - 1 ? data.pop() : splice.call(data, index, 1), --this.size, !0);\n    }\n\n    function listCacheGet(key) {\n      var data = this.__data__,\n          index = assocIndexOf(data, key);\n      return index < 0 ? void 0 : data[index][1];\n    }\n\n    function listCacheHas(key) {\n      return assocIndexOf(this.__data__, key) > -1;\n    }\n\n    function listCacheSet(key, value) {\n      var data = this.__data__,\n          index = assocIndexOf(data, key);\n      return index < 0 ? (++this.size, data.push([key, value])) : data[index][1] = value, this;\n    }\n\n    function MapCache(entries) {\n      var index = -1,\n          length = null == entries ? 0 : entries.length;\n\n      for (this.clear(); ++index < length;) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n\n    function mapCacheClear() {\n      this.size = 0, this.__data__ = {\n        hash: new Hash(),\n        map: new (Map || ListCache)(),\n        string: new Hash()\n      };\n    }\n\n    function mapCacheDelete(key) {\n      var result = getMapData(this, key).delete(key);\n      return this.size -= result ? 1 : 0, result;\n    }\n\n    function mapCacheGet(key) {\n      return getMapData(this, key).get(key);\n    }\n\n    function mapCacheHas(key) {\n      return getMapData(this, key).has(key);\n    }\n\n    function mapCacheSet(key, value) {\n      var data = getMapData(this, key),\n          size = data.size;\n      return data.set(key, value), this.size += data.size == size ? 0 : 1, this;\n    }\n\n    function Stack(entries) {\n      var data = this.__data__ = new ListCache(entries);\n      this.size = data.size;\n    }\n\n    function stackClear() {\n      this.__data__ = new ListCache(), this.size = 0;\n    }\n\n    function stackDelete(key) {\n      var data = this.__data__,\n          result = data.delete(key);\n      return this.size = data.size, result;\n    }\n\n    function stackGet(key) {\n      return this.__data__.get(key);\n    }\n\n    function stackHas(key) {\n      return this.__data__.has(key);\n    }\n\n    function stackSet(key, value) {\n      var data = this.__data__;\n\n      if (data instanceof ListCache) {\n        var pairs = data.__data__;\n        if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) return pairs.push([key, value]), this.size = ++data.size, this;\n        data = this.__data__ = new MapCache(pairs);\n      }\n\n      return data.set(key, value), this.size = data.size, this;\n    }\n\n    function arrayLikeKeys(value, inherited) {\n      var isArr = isArray(value),\n          isArg = !isArr && isArguments(value),\n          isBuff = !isArr && !isArg && isBuffer(value),\n          isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n          skipIndexes = isArr || isArg || isBuff || isType,\n          result = skipIndexes ? baseTimes(value.length, String) : [],\n          length = result.length;\n\n      for (var key in value) !inherited && !hasOwnProperty.call(value, key) || skipIndexes && (\"length\" == key || isBuff && (\"offset\" == key || \"parent\" == key) || isType && (\"buffer\" == key || \"byteLength\" == key || \"byteOffset\" == key) || isIndex(key, length)) || result.push(key);\n\n      return result;\n    }\n\n    function assignMergeValue(object, key, value) {\n      (void 0 === value || eq(object[key], value)) && (void 0 !== value || key in object) || baseAssignValue(object, key, value);\n    }\n\n    function assignValue(object, key, value) {\n      var objValue = object[key];\n      hasOwnProperty.call(object, key) && eq(objValue, value) && (void 0 !== value || key in object) || baseAssignValue(object, key, value);\n    }\n\n    function assocIndexOf(array, key) {\n      for (var length = array.length; length--;) if (eq(array[length][0], key)) return length;\n\n      return -1;\n    }\n\n    function baseAssignValue(object, key, value) {\n      \"__proto__\" == key && defineProperty ? defineProperty(object, key, {\n        configurable: !0,\n        enumerable: !0,\n        value: value,\n        writable: !0\n      }) : object[key] = value;\n    }\n\n    function baseGetTag(value) {\n      return null == value ? void 0 === value ? undefinedTag : nullTag : symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);\n    }\n\n    function baseIsArguments(value) {\n      return isObjectLike(value) && baseGetTag(value) == argsTag;\n    }\n\n    function baseIsNative(value) {\n      return !(!isObject(value) || isMasked(value)) && (isFunction(value) ? reIsNative : reIsHostCtor).test(toSource(value));\n    }\n\n    function baseIsTypedArray(value) {\n      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n    }\n\n    function baseKeysIn(object) {\n      if (!isObject(object)) return nativeKeysIn(object);\n      var isProto = isPrototype(object),\n          result = [];\n\n      for (var key in object) (\"constructor\" != key || !isProto && hasOwnProperty.call(object, key)) && result.push(key);\n\n      return result;\n    }\n\n    function baseMerge(object, source, srcIndex, customizer, stack) {\n      object !== source && baseFor(source, function (srcValue, key) {\n        if (isObject(srcValue)) stack || (stack = new Stack()), baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);else {\n          var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + \"\", object, source, stack) : void 0;\n          void 0 === newValue && (newValue = srcValue), assignMergeValue(object, key, newValue);\n        }\n      }, keysIn);\n    }\n\n    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {\n      var objValue = safeGet(object, key),\n          srcValue = safeGet(source, key),\n          stacked = stack.get(srcValue);\n      if (stacked) return void assignMergeValue(object, key, stacked);\n      var newValue = customizer ? customizer(objValue, srcValue, key + \"\", object, source, stack) : void 0,\n          isCommon = void 0 === newValue;\n\n      if (isCommon) {\n        var isArr = isArray(srcValue),\n            isBuff = !isArr && isBuffer(srcValue),\n            isTyped = !isArr && !isBuff && isTypedArray(srcValue);\n        newValue = srcValue, isArr || isBuff || isTyped ? isArray(objValue) ? newValue = objValue : isArrayLikeObject(objValue) ? newValue = copyArray(objValue) : isBuff ? (isCommon = !1, newValue = cloneBuffer(srcValue, !0)) : isTyped ? (isCommon = !1, newValue = cloneTypedArray(srcValue, !0)) : newValue = [] : isPlainObject(srcValue) || isArguments(srcValue) ? (newValue = objValue, isArguments(objValue) ? newValue = toPlainObject(objValue) : (!isObject(objValue) || srcIndex && isFunction(objValue)) && (newValue = initCloneObject(srcValue))) : isCommon = !1;\n      }\n\n      isCommon && (stack.set(srcValue, newValue), mergeFunc(newValue, srcValue, srcIndex, customizer, stack), stack.delete(srcValue)), assignMergeValue(object, key, newValue);\n    }\n\n    function baseRest(func, start) {\n      return setToString(overRest(func, start, identity), func + \"\");\n    }\n\n    function cloneBuffer(buffer, isDeep) {\n      if (isDeep) return buffer.slice();\n      var length = buffer.length,\n          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n      return buffer.copy(result), result;\n    }\n\n    function cloneArrayBuffer(arrayBuffer) {\n      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n      return new Uint8Array(result).set(new Uint8Array(arrayBuffer)), result;\n    }\n\n    function cloneTypedArray(typedArray, isDeep) {\n      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n    }\n\n    function copyArray(source, array) {\n      var index = -1,\n          length = source.length;\n\n      for (array || (array = Array(length)); ++index < length;) array[index] = source[index];\n\n      return array;\n    }\n\n    function copyObject(source, props, object, customizer) {\n      var isNew = !object;\n      object || (object = {});\n\n      for (var index = -1, length = props.length; ++index < length;) {\n        var key = props[index],\n            newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;\n        void 0 === newValue && (newValue = source[key]), isNew ? baseAssignValue(object, key, newValue) : assignValue(object, key, newValue);\n      }\n\n      return object;\n    }\n\n    function getMapData(map, key) {\n      var data = map.__data__;\n      return isKeyable(key) ? data[\"string\" == typeof key ? \"string\" : \"hash\"] : data.map;\n    }\n\n    function getNative(object, key) {\n      var value = getValue(object, key);\n      return baseIsNative(value) ? value : void 0;\n    }\n\n    function getRawTag(value) {\n      var isOwn = hasOwnProperty.call(value, symToStringTag),\n          tag = value[symToStringTag];\n\n      try {\n        value[symToStringTag] = void 0;\n        var unmasked = !0;\n      } catch (e) {}\n\n      var result = nativeObjectToString.call(value);\n      return unmasked && (isOwn ? value[symToStringTag] = tag : delete value[symToStringTag]), result;\n    }\n\n    function initCloneObject(object) {\n      return \"function\" != typeof object.constructor || isPrototype(object) ? {} : baseCreate(getPrototype(object));\n    }\n\n    function isIndex(value, length) {\n      var type = void 0 === value ? \"undefined\" : _typeof2(value);\n      return !!(length = null == length ? MAX_SAFE_INTEGER : length) && (\"number\" == type || \"symbol\" != type && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;\n    }\n\n    function isIterateeCall(value, index, object) {\n      if (!isObject(object)) return !1;\n      var type = void 0 === index ? \"undefined\" : _typeof2(index);\n      return !!(\"number\" == type ? isArrayLike(object) && isIndex(index, object.length) : \"string\" == type && index in object) && eq(object[index], value);\n    }\n\n    function isKeyable(value) {\n      var type = void 0 === value ? \"undefined\" : _typeof2(value);\n      return \"string\" == type || \"number\" == type || \"symbol\" == type || \"boolean\" == type ? \"__proto__\" !== value : null === value;\n    }\n\n    function isMasked(func) {\n      return !!maskSrcKey && maskSrcKey in func;\n    }\n\n    function isPrototype(value) {\n      var Ctor = value && value.constructor;\n      return value === (\"function\" == typeof Ctor && Ctor.prototype || objectProto);\n    }\n\n    function nativeKeysIn(object) {\n      var result = [];\n      if (null != object) for (var key in Object(object)) result.push(key);\n      return result;\n    }\n\n    function objectToString(value) {\n      return nativeObjectToString.call(value);\n    }\n\n    function overRest(func, start, transform) {\n      return start = nativeMax(void 0 === start ? func.length - 1 : start, 0), function () {\n        for (var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length); ++index < length;) array[index] = args[start + index];\n\n        index = -1;\n\n        for (var otherArgs = Array(start + 1); ++index < start;) otherArgs[index] = args[index];\n\n        return otherArgs[start] = transform(array), apply(func, this, otherArgs);\n      };\n    }\n\n    function toSource(func) {\n      if (null != func) {\n        try {\n          return funcToString.call(func);\n        } catch (e) {}\n\n        try {\n          return func + \"\";\n        } catch (e) {}\n      }\n\n      return \"\";\n    }\n\n    function eq(value, other) {\n      return value === other || value !== value && other !== other;\n    }\n\n    function isArrayLike(value) {\n      return null != value && isLength(value.length) && !isFunction(value);\n    }\n\n    function isArrayLikeObject(value) {\n      return isObjectLike(value) && isArrayLike(value);\n    }\n\n    function isFunction(value) {\n      if (!isObject(value)) return !1;\n      var tag = baseGetTag(value);\n      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n    }\n\n    function isLength(value) {\n      return \"number\" == typeof value && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n    }\n\n    function isObject(value) {\n      var type = void 0 === value ? \"undefined\" : _typeof2(value);\n      return null != value && (\"object\" == type || \"function\" == type);\n    }\n\n    function isObjectLike(value) {\n      return null != value && \"object\" == (void 0 === value ? \"undefined\" : _typeof2(value));\n    }\n\n    function isPlainObject(value) {\n      if (!isObjectLike(value) || baseGetTag(value) != objectTag) return !1;\n      var proto = getPrototype(value);\n      if (null === proto) return !0;\n      var Ctor = hasOwnProperty.call(proto, \"constructor\") && proto.constructor;\n      return \"function\" == typeof Ctor && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;\n    }\n\n    function toPlainObject(value) {\n      return copyObject(value, keysIn(value));\n    }\n\n    function keysIn(object) {\n      return isArrayLike(object) ? arrayLikeKeys(object, !0) : baseKeysIn(object);\n    }\n\n    function constant(value) {\n      return function () {\n        return value;\n      };\n    }\n\n    function identity(value) {\n      return value;\n    }\n\n    function stubFalse() {\n      return !1;\n    }\n\n    var LARGE_ARRAY_SIZE = 200,\n        HASH_UNDEFINED = \"__lodash_hash_undefined__\",\n        HOT_COUNT = 800,\n        HOT_SPAN = 16,\n        MAX_SAFE_INTEGER = 9007199254740991,\n        argsTag = \"[object Arguments]\",\n        asyncTag = \"[object AsyncFunction]\",\n        funcTag = \"[object Function]\",\n        genTag = \"[object GeneratorFunction]\",\n        nullTag = \"[object Null]\",\n        objectTag = \"[object Object]\",\n        proxyTag = \"[object Proxy]\",\n        undefinedTag = \"[object Undefined]\",\n        reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g,\n        reIsHostCtor = /^\\[object .+?Constructor\\]$/,\n        reIsUint = /^(?:0|[1-9]\\d*)$/,\n        typedArrayTags = {};\n    typedArrayTags[\"[object Float32Array]\"] = typedArrayTags[\"[object Float64Array]\"] = typedArrayTags[\"[object Int8Array]\"] = typedArrayTags[\"[object Int16Array]\"] = typedArrayTags[\"[object Int32Array]\"] = typedArrayTags[\"[object Uint8Array]\"] = typedArrayTags[\"[object Uint8ClampedArray]\"] = typedArrayTags[\"[object Uint16Array]\"] = typedArrayTags[\"[object Uint32Array]\"] = !0, typedArrayTags[argsTag] = typedArrayTags[\"[object Array]\"] = typedArrayTags[\"[object ArrayBuffer]\"] = typedArrayTags[\"[object Boolean]\"] = typedArrayTags[\"[object DataView]\"] = typedArrayTags[\"[object Date]\"] = typedArrayTags[\"[object Error]\"] = typedArrayTags[funcTag] = typedArrayTags[\"[object Map]\"] = typedArrayTags[\"[object Number]\"] = typedArrayTags[objectTag] = typedArrayTags[\"[object RegExp]\"] = typedArrayTags[\"[object Set]\"] = typedArrayTags[\"[object String]\"] = typedArrayTags[\"[object WeakMap]\"] = !1;\n\n    var freeGlobal = \"object\" == (void 0 === commonjsGlobal ? \"undefined\" : _typeof2(commonjsGlobal)) && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal,\n        freeSelf = \"object\" == (\"undefined\" == typeof self ? \"undefined\" : _typeof2(self)) && self && self.Object === Object && self,\n        root = freeGlobal || freeSelf || Function(\"return this\")(),\n        freeExports = exports && !exports.nodeType && exports,\n        freeModule = freeExports && !0 && module && !module.nodeType && module,\n        moduleExports = freeModule && freeModule.exports === freeExports,\n        freeProcess = moduleExports && freeGlobal.process,\n        nodeUtil = function () {\n      try {\n        return freeProcess && freeProcess.binding && freeProcess.binding(\"util\");\n      } catch (e) {}\n    }(),\n        nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray,\n        arrayProto = Array.prototype,\n        funcProto = Function.prototype,\n        objectProto = Object.prototype,\n        coreJsData = root[\"__core-js_shared__\"],\n        funcToString = funcProto.toString,\n        hasOwnProperty = objectProto.hasOwnProperty,\n        maskSrcKey = function () {\n      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || \"\");\n      return uid ? \"Symbol(src)_1.\" + uid : \"\";\n    }(),\n        nativeObjectToString = objectProto.toString,\n        objectCtorString = funcToString.call(Object),\n        reIsNative = RegExp(\"^\" + funcToString.call(hasOwnProperty).replace(reRegExpChar, \"\\\\$&\").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \"$1.*?\") + \"$\"),\n        Buffer = moduleExports ? root.Buffer : void 0,\n        _Symbol = root.Symbol,\n        Uint8Array = root.Uint8Array,\n        allocUnsafe = Buffer ? Buffer.allocUnsafe : void 0,\n        getPrototype = function (func, transform) {\n      return function (arg) {\n        return func(transform(arg));\n      };\n    }(Object.getPrototypeOf, Object),\n        objectCreate = Object.create,\n        propertyIsEnumerable = objectProto.propertyIsEnumerable,\n        splice = arrayProto.splice,\n        symToStringTag = _Symbol ? _Symbol.toStringTag : void 0,\n        defineProperty = function () {\n      try {\n        var func = getNative(Object, \"defineProperty\");\n        return func({}, \"\", {}), func;\n      } catch (e) {}\n    }(),\n        nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0,\n        nativeMax = Math.max,\n        nativeNow = Date.now,\n        Map = getNative(root, \"Map\"),\n        nativeCreate = getNative(Object, \"create\"),\n        baseCreate = function () {\n      function object() {}\n\n      return function (proto) {\n        if (!isObject(proto)) return {};\n        if (objectCreate) return objectCreate(proto);\n        object.prototype = proto;\n        var result = new object();\n        return object.prototype = void 0, result;\n      };\n    }();\n\n    Hash.prototype.clear = hashClear, Hash.prototype.delete = hashDelete, Hash.prototype.get = hashGet, Hash.prototype.has = hashHas, Hash.prototype.set = hashSet, ListCache.prototype.clear = listCacheClear, ListCache.prototype.delete = listCacheDelete, ListCache.prototype.get = listCacheGet, ListCache.prototype.has = listCacheHas, ListCache.prototype.set = listCacheSet, MapCache.prototype.clear = mapCacheClear, MapCache.prototype.delete = mapCacheDelete, MapCache.prototype.get = mapCacheGet, MapCache.prototype.has = mapCacheHas, MapCache.prototype.set = mapCacheSet, Stack.prototype.clear = stackClear, Stack.prototype.delete = stackDelete, Stack.prototype.get = stackGet, Stack.prototype.has = stackHas, Stack.prototype.set = stackSet;\n\n    var baseFor = function (fromRight) {\n      return function (object, iteratee, keysFunc) {\n        for (var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length; length--;) {\n          var key = props[fromRight ? length : ++index];\n          if (!1 === iteratee(iterable[key], key, iterable)) break;\n        }\n\n        return object;\n      };\n    }(),\n        baseSetToString = defineProperty ? function (func, string) {\n      return defineProperty(func, \"toString\", {\n        configurable: !0,\n        enumerable: !1,\n        value: constant(string),\n        writable: !0\n      });\n    } : identity,\n        setToString = function (func) {\n      var count = 0,\n          lastCalled = 0;\n      return function () {\n        var stamp = nativeNow(),\n            remaining = HOT_SPAN - (stamp - lastCalled);\n\n        if (lastCalled = stamp, remaining > 0) {\n          if (++count >= HOT_COUNT) return arguments[0];\n        } else count = 0;\n\n        return func.apply(void 0, arguments);\n      };\n    }(baseSetToString),\n        isArguments = baseIsArguments(function () {\n      return arguments;\n    }()) ? baseIsArguments : function (value) {\n      return isObjectLike(value) && hasOwnProperty.call(value, \"callee\") && !propertyIsEnumerable.call(value, \"callee\");\n    },\n        isArray = Array.isArray,\n        isBuffer = nativeIsBuffer || stubFalse,\n        isTypedArray = nodeIsTypedArray ? function (func) {\n      return function (value) {\n        return func(value);\n      };\n    }(nodeIsTypedArray) : baseIsTypedArray,\n        merge = function (assigner) {\n      return baseRest(function (object, sources) {\n        var index = -1,\n            length = sources.length,\n            customizer = length > 1 ? sources[length - 1] : void 0,\n            guard = length > 2 ? sources[2] : void 0;\n\n        for (customizer = assigner.length > 3 && \"function\" == typeof customizer ? (length--, customizer) : void 0, guard && isIterateeCall(sources[0], sources[1], guard) && (customizer = length < 3 ? void 0 : customizer, length = 1), object = Object(object); ++index < length;) {\n          var source = sources[index];\n          source && assigner(object, source, index, customizer);\n        }\n\n        return object;\n      });\n    }(function (object, source, srcIndex) {\n      baseMerge(object, source, srcIndex);\n    });\n\n    module.exports = merge;\n  }),\n      VTooltip = directive,\n      plugin = {\n    install: install,\n\n    get enabled() {\n      return state.enabled;\n    },\n\n    set enabled(value) {\n      state.enabled = value;\n    }\n\n  },\n      GlobalVue = null;\n\n  \"undefined\" != typeof window ? GlobalVue = window.Vue : \"undefined\" != typeof global && (GlobalVue = global.Vue), GlobalVue && GlobalVue.use(plugin);\n}, function (module, __webpack_exports__, __webpack_require__) {\n  \"use strict\";\n\n  Object.defineProperty(__webpack_exports__, \"__esModule\", {\n    value: !0\n  });\n\n  var __WEBPACK_IMPORTED_MODULE_0_v_tooltip__ = __webpack_require__(4),\n      __WEBPACK_IMPORTED_MODULE_1__Heatmap__ = __webpack_require__(2),\n      __WEBPACK_IMPORTED_MODULE_2__consts_js__ = __webpack_require__(0);\n\n  __WEBPACK_IMPORTED_MODULE_0_v_tooltip__.a.enabled = window.innerWidth > 768, __webpack_exports__.default = {\n    directives: {\n      tooltip: __WEBPACK_IMPORTED_MODULE_0_v_tooltip__.a\n    },\n    props: {\n      endDate: {\n        required: !0\n      },\n      max: {\n        type: Number\n      },\n      rangeColor: {\n        type: Array,\n        default: function () {\n          return __WEBPACK_IMPORTED_MODULE_2__consts_js__.a;\n        }\n      },\n      values: {\n        required: !0,\n        type: Array\n      },\n      locale: {\n        type: Object\n      },\n      tooltip: {\n        type: Boolean,\n        default: !0\n      },\n      tooltipUnit: {\n        type: String,\n        default: __WEBPACK_IMPORTED_MODULE_2__consts_js__.b\n      },\n      vertical: {\n        type: Boolean,\n        default: !1\n      }\n    },\n    data: function () {\n      return {\n        now: new Date()\n      };\n    },\n    computed: {\n      position: function () {\n        return this.vertical ? \"vertical\" : \"horizontal\";\n      },\n      tooltipTransform: function () {\n        return \"translate(\" + this.tooltipX + \", \" + this.tooltipY + \")\";\n      },\n      heatmap: function () {\n        return new __WEBPACK_IMPORTED_MODULE_1__Heatmap__.a(this.endDate, this.values, this.max);\n      },\n      width: function () {\n        return {\n          horizontal: this.LEFT_SECTION_WIDTH + this.SQUARE_SIZE * this.heatmap.weekCount + this.SQUARE_BORDER_SIZE,\n          vertical: this.LEFT_SECTION_WIDTH + this.SQUARE_SIZE * __WEBPACK_IMPORTED_MODULE_2__consts_js__.c + this.RIGHT_SECTION_WIDTH\n        };\n      },\n      heigth: function () {\n        return {\n          horizontal: this.TOP_SECTION_HEIGTH + this.SQUARE_SIZE * __WEBPACK_IMPORTED_MODULE_2__consts_js__.c + this.SQUARE_BORDER_SIZE + this.BOTTOM_SECTION_HEIGTH,\n          vertical: this.TOP_SECTION_HEIGTH + this.SQUARE_SIZE * this.heatmap.weekCount + this.SQUARE_BORDER_SIZE\n        };\n      },\n      viewbox: function () {\n        return \"0 0 \" + this.width[this.position] + \" \" + this.heigth[this.position];\n      },\n      daysLabelWrapperTransform: function () {\n        return {\n          horizontal: \"translate(0, \" + this.TOP_SECTION_HEIGTH + \")\",\n          vertical: \"translate(\" + this.LEFT_SECTION_WIDTH + \", 0)\"\n        };\n      },\n      monthsLabelWrapperTransform: function () {\n        return {\n          horizontal: \"translate(\" + this.LEFT_SECTION_WIDTH + \", 0)\",\n          vertical: \"translate(0, \" + this.TOP_SECTION_HEIGTH + \")\"\n        };\n      },\n      legendWrapperTransform: function () {\n        return {\n          horizontal: \"translate(\" + (this.width[this.position] - this.SQUARE_SIZE * this.rangeColor.length - 30) + \", \" + (this.heigth[this.position] - this.BOTTOM_SECTION_HEIGTH) + \")\",\n          vertical: \"translate(\" + (this.LEFT_SECTION_WIDTH + this.SQUARE_SIZE * __WEBPACK_IMPORTED_MODULE_2__consts_js__.c) + \", \" + this.TOP_SECTION_HEIGTH + \")\"\n        };\n      },\n      yearWrapperTransform: function () {\n        return \"translate(\" + this.LEFT_SECTION_WIDTH + \", \" + this.TOP_SECTION_HEIGTH + \")\";\n      },\n      SQUARE_BORDER_SIZE: function () {\n        return __WEBPACK_IMPORTED_MODULE_2__consts_js__.d / 5;\n      },\n      SQUARE_SIZE: function () {\n        return __WEBPACK_IMPORTED_MODULE_2__consts_js__.d + this.SQUARE_BORDER_SIZE;\n      },\n      TOP_SECTION_HEIGTH: function () {\n        return __WEBPACK_IMPORTED_MODULE_2__consts_js__.d + __WEBPACK_IMPORTED_MODULE_2__consts_js__.d / 2;\n      },\n      RIGHT_SECTION_WIDTH: function () {\n        return 3 * this.SQUARE_SIZE;\n      },\n      BOTTOM_SECTION_HEIGTH: function () {\n        return __WEBPACK_IMPORTED_MODULE_2__consts_js__.d + __WEBPACK_IMPORTED_MODULE_2__consts_js__.d / 2;\n      },\n      LEFT_SECTION_WIDTH: function () {\n        return Math.ceil(2.5 * __WEBPACK_IMPORTED_MODULE_2__consts_js__.d);\n      },\n      lo: function () {\n        return this.locale ? {\n          months: this.locale.months || __WEBPACK_IMPORTED_MODULE_2__consts_js__.e.months,\n          days: this.locale.days || __WEBPACK_IMPORTED_MODULE_2__consts_js__.e.days,\n          on: this.locale.on || __WEBPACK_IMPORTED_MODULE_2__consts_js__.e.on,\n          less: this.locale.less || __WEBPACK_IMPORTED_MODULE_2__consts_js__.e.less,\n          more: this.locale.more || __WEBPACK_IMPORTED_MODULE_2__consts_js__.e.more\n        } : __WEBPACK_IMPORTED_MODULE_2__consts_js__.e;\n      }\n    },\n    methods: {\n      tooltipOptions: function (day) {\n        return !!this.tooltip && {\n          content: \"<b>\" + day.count + \" \" + this.tooltipUnit + \"</b> \" + this.lo.on + \" \" + this.lo.months[day.date.getMonth()] + \" \" + day.date.getDate() + \", \" + day.date.getFullYear(),\n          delay: {\n            show: 150,\n            hide: 50\n          }\n        };\n      },\n      getWeekPosition: function (index) {\n        return this.vertical ? \"translate(0, \" + (this.SQUARE_SIZE * this.heatmap.weekCount - (index + 1) * this.SQUARE_SIZE) + \")\" : \"translate(\" + index * this.SQUARE_SIZE + \", 0)\";\n      },\n      getDayPosition: function (index) {\n        return this.vertical ? \"translate(\" + index * this.SQUARE_SIZE + \", 0)\" : \"translate(0, \" + index * this.SQUARE_SIZE + \")\";\n      },\n      getMonthLabelPostion: function (month) {\n        var position = {\n          x: 0,\n          y: 0\n        };\n        return position.x = this.vertical ? 3 : this.SQUARE_SIZE * month.index, position.y = this.vertical ? this.SQUARE_SIZE * this.heatmap.weekCount - this.SQUARE_SIZE * month.index - this.SQUARE_SIZE / 4 : this.SQUARE_SIZE - this.SQUARE_BORDER_SIZE, position;\n      }\n    }\n  };\n}, function (module, exports) {}, function (module, exports) {}, function (module, exports) {\n  module.exports = function (rawScriptExports, compiledTemplate, scopeId, cssModules) {\n    var esModule,\n        scriptExports = rawScriptExports = rawScriptExports || {},\n        type = typeof rawScriptExports.default;\n    \"object\" !== type && \"function\" !== type || (esModule = rawScriptExports, scriptExports = rawScriptExports.default);\n    var options = \"function\" == typeof scriptExports ? scriptExports.options : scriptExports;\n\n    if (compiledTemplate && (options.render = compiledTemplate.render, options.staticRenderFns = compiledTemplate.staticRenderFns), scopeId && (options._scopeId = scopeId), cssModules) {\n      var computed = options.computed || (options.computed = {});\n      Object.keys(cssModules).forEach(function (key) {\n        var module = cssModules[key];\n\n        computed[key] = function () {\n          return module;\n        };\n      });\n    }\n\n    return {\n      esModule: esModule,\n      exports: scriptExports,\n      options: options\n    };\n  };\n}, function (module, exports) {\n  module.exports = {\n    render: function () {\n      var _vm = this,\n          _h = _vm.$createElement,\n          _c = _vm._self._c || _h;\n\n      return _c(\"svg\", {\n        staticClass: \"vch__wrapper\",\n        attrs: {\n          viewBox: _vm.viewbox\n        }\n      }, [_c(\"g\", {\n        staticClass: \"vch__months__labels__wrapper\",\n        attrs: {\n          transform: _vm.monthsLabelWrapperTransform[_vm.position]\n        }\n      }, _vm._l(_vm.heatmap.firstFullWeekOfMonths, function (month, index) {\n        return _c(\"text\", {\n          staticClass: \"vch__month__label\",\n          attrs: {\n            x: _vm.getMonthLabelPostion(month).x,\n            y: _vm.getMonthLabelPostion(month).y\n          }\n        }, [_vm._v(_vm._s(_vm.lo.months[month.value]))]);\n      })), _c(\"g\", {\n        staticClass: \"vch__days__labels__wrapper\",\n        attrs: {\n          transform: _vm.daysLabelWrapperTransform[_vm.position]\n        }\n      }, [_c(\"text\", {\n        staticClass: \"vch__day__label\",\n        attrs: {\n          x: _vm.vertical ? 1 * _vm.SQUARE_SIZE : 0,\n          y: _vm.vertical ? _vm.SQUARE_SIZE - _vm.SQUARE_BORDER_SIZE : 20\n        }\n      }, [_vm._v(_vm._s(_vm.lo.days[1]))]), _c(\"text\", {\n        staticClass: \"vch__day__label\",\n        attrs: {\n          x: _vm.vertical ? 3 * _vm.SQUARE_SIZE : 0,\n          y: _vm.vertical ? _vm.SQUARE_SIZE - _vm.SQUARE_BORDER_SIZE : 44\n        }\n      }, [_vm._v(_vm._s(_vm.lo.days[3]))]), _c(\"text\", {\n        staticClass: \"vch__day__label\",\n        attrs: {\n          x: _vm.vertical ? 5 * _vm.SQUARE_SIZE : 0,\n          y: _vm.vertical ? _vm.SQUARE_SIZE - _vm.SQUARE_BORDER_SIZE : 69\n        }\n      }, [_vm._v(_vm._s(_vm.lo.days[5]))])]), _c(\"g\", {\n        staticClass: \"vch__legend__wrapper\",\n        attrs: {\n          transform: _vm.legendWrapperTransform[_vm.position]\n        }\n      }, [_c(\"text\", {\n        attrs: {\n          x: _vm.vertical ? 1.25 * _vm.SQUARE_SIZE : -25,\n          y: _vm.vertical ? 8 : _vm.SQUARE_SIZE + 1\n        }\n      }, [_vm._v(_vm._s(_vm.lo.less))]), _vm._l(_vm.rangeColor, function (color, index) {\n        return _c(\"rect\", {\n          key: index,\n          style: {\n            fill: color\n          },\n          attrs: {\n            width: _vm.SQUARE_SIZE - _vm.SQUARE_BORDER_SIZE,\n            height: _vm.SQUARE_SIZE - _vm.SQUARE_BORDER_SIZE,\n            x: _vm.vertical ? 1.75 * _vm.SQUARE_SIZE : _vm.SQUARE_SIZE * index,\n            y: _vm.vertical ? _vm.SQUARE_SIZE * (index + 1) : 5\n          }\n        });\n      }), _c(\"text\", {\n        attrs: {\n          x: _vm.vertical ? 1.25 * _vm.SQUARE_SIZE : _vm.SQUARE_SIZE * _vm.rangeColor.length + 1,\n          y: _vm.vertical ? _vm.SQUARE_SIZE * (_vm.rangeColor.length + 2) - _vm.SQUARE_BORDER_SIZE : _vm.SQUARE_SIZE + 1\n        }\n      }, [_vm._v(_vm._s(_vm.lo.more))])], 2), _c(\"g\", {\n        staticClass: \"vch__year__wrapper\",\n        attrs: {\n          transform: _vm.yearWrapperTransform\n        }\n      }, _vm._l(_vm.heatmap.calendar, function (week, weekIndex) {\n        return _c(\"g\", {\n          key: weekIndex,\n          staticClass: \"vch__month__wrapper\",\n          attrs: {\n            transform: _vm.getWeekPosition(weekIndex)\n          }\n        }, _vm._l(week, function (day, dayIndex) {\n          return day.date < _vm.now ? _c(\"rect\", {\n            directives: [{\n              name: \"tooltip\",\n              rawName: \"v-tooltip\",\n              value: _vm.tooltipOptions(day),\n              expression: \"tooltipOptions(day)\"\n            }],\n            key: dayIndex,\n            staticClass: \"vch__day__square\",\n            style: {\n              fill: _vm.rangeColor[day.colorIndex]\n            },\n            attrs: {\n              transform: _vm.getDayPosition(dayIndex),\n              width: _vm.SQUARE_SIZE - _vm.SQUARE_BORDER_SIZE,\n              height: _vm.SQUARE_SIZE - _vm.SQUARE_BORDER_SIZE\n            },\n            on: {\n              click: function ($event) {\n                _vm.$emit(\"day-click\", day);\n              }\n            }\n          }) : _vm._e();\n        }));\n      }))]);\n    },\n    staticRenderFns: []\n  };\n}]);","map":null,"metadata":{},"sourceType":"script"}