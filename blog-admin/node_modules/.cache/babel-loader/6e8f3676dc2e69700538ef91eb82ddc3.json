{"ast":null,"code":"var Group = require(\"../container/Group\");\n\nvar ZImage = require(\"../graphic/Image\");\n\nvar Text = require(\"../graphic/Text\");\n\nvar Circle = require(\"../graphic/shape/Circle\");\n\nvar Rect = require(\"../graphic/shape/Rect\");\n\nvar Ellipse = require(\"../graphic/shape/Ellipse\");\n\nvar Line = require(\"../graphic/shape/Line\");\n\nvar Path = require(\"../graphic/Path\");\n\nvar Polygon = require(\"../graphic/shape/Polygon\");\n\nvar Polyline = require(\"../graphic/shape/Polyline\");\n\nvar LinearGradient = require(\"../graphic/LinearGradient\");\n\nvar Style = require(\"../graphic/Style\");\n\nvar matrix = require(\"../core/matrix\");\n\nvar _path = require(\"./path\");\n\nvar createFromString = _path.createFromString;\n\nvar _util = require(\"../core/util\");\n\nvar isString = _util.isString;\nvar extend = _util.extend;\nvar defaults = _util.defaults;\nvar trim = _util.trim;\nvar each = _util.each; // import RadialGradient from '../graphic/RadialGradient';\n// import Pattern from '../graphic/Pattern';\n// import * as vector from '../core/vector';\n// Most of the values can be separated by comma and/or white space.\n\nvar DILIMITER_REG = /[\\s,]+/;\n/**\n * For big svg string, this method might be time consuming.\n *\n * @param {string} svg xml string\n * @return {Object} xml root.\n */\n\nfunction parseXML(svg) {\n  if (isString(svg)) {\n    var parser = new DOMParser();\n    svg = parser.parseFromString(svg, 'text/xml');\n  } // Document node. If using $.get, doc node may be input.\n\n\n  if (svg.nodeType === 9) {\n    svg = svg.firstChild;\n  } // nodeName of <!DOCTYPE svg> is also 'svg'.\n\n\n  while (svg.nodeName.toLowerCase() !== 'svg' || svg.nodeType !== 1) {\n    svg = svg.nextSibling;\n  }\n\n  return svg;\n}\n\nfunction SVGParser() {\n  this._defs = {};\n  this._root = null;\n  this._isDefine = false;\n  this._isText = false;\n}\n\nSVGParser.prototype.parse = function (xml, opt) {\n  opt = opt || {};\n  var svg = parseXML(xml);\n\n  if (!svg) {\n    throw new Error('Illegal svg');\n  }\n\n  var root = new Group();\n  this._root = root; // parse view port\n\n  var viewBox = svg.getAttribute('viewBox') || ''; // If width/height not specified, means \"100%\" of `opt.width/height`.\n  // TODO: Other percent value not supported yet.\n\n  var width = parseFloat(svg.getAttribute('width') || opt.width);\n  var height = parseFloat(svg.getAttribute('height') || opt.height); // If width/height not specified, set as null for output.\n\n  isNaN(width) && (width = null);\n  isNaN(height) && (height = null); // Apply inline style on svg element.\n\n  parseAttributes(svg, root, null, true);\n  var child = svg.firstChild;\n\n  while (child) {\n    this._parseNode(child, root);\n\n    child = child.nextSibling;\n  }\n\n  var viewBoxRect;\n  var viewBoxTransform;\n\n  if (viewBox) {\n    var viewBoxArr = trim(viewBox).split(DILIMITER_REG); // Some invalid case like viewBox: 'none'.\n\n    if (viewBoxArr.length >= 4) {\n      viewBoxRect = {\n        x: parseFloat(viewBoxArr[0] || 0),\n        y: parseFloat(viewBoxArr[1] || 0),\n        width: parseFloat(viewBoxArr[2]),\n        height: parseFloat(viewBoxArr[3])\n      };\n    }\n  }\n\n  if (viewBoxRect && width != null && height != null) {\n    viewBoxTransform = makeViewBoxTransform(viewBoxRect, width, height);\n\n    if (!opt.ignoreViewBox) {\n      // If set transform on the output group, it probably bring trouble when\n      // some users only intend to show the clipped content inside the viewBox,\n      // but not intend to transform the output group. So we keep the output\n      // group no transform. If the user intend to use the viewBox as a\n      // camera, just set `opt.ignoreViewBox` as `true` and set transfrom\n      // manually according to the viewBox info in the output of this method.\n      var elRoot = root;\n      root = new Group();\n      root.add(elRoot);\n      elRoot.scale = viewBoxTransform.scale.slice();\n      elRoot.position = viewBoxTransform.position.slice();\n    }\n  } // Some shapes might be overflow the viewport, which should be\n  // clipped despite whether the viewBox is used, as the SVG does.\n\n\n  if (!opt.ignoreRootClip && width != null && height != null) {\n    root.setClipPath(new Rect({\n      shape: {\n        x: 0,\n        y: 0,\n        width: width,\n        height: height\n      }\n    }));\n  } // Set width/height on group just for output the viewport size.\n\n\n  return {\n    root: root,\n    width: width,\n    height: height,\n    viewBoxRect: viewBoxRect,\n    viewBoxTransform: viewBoxTransform\n  };\n};\n\nSVGParser.prototype._parseNode = function (xmlNode, parentGroup) {\n  var nodeName = xmlNode.nodeName.toLowerCase(); // TODO\n  // support <style>...</style> in svg, where nodeName is 'style',\n  // CSS classes is defined globally wherever the style tags are declared.\n\n  if (nodeName === 'defs') {\n    // define flag\n    this._isDefine = true;\n  } else if (nodeName === 'text') {\n    this._isText = true;\n  }\n\n  var el;\n\n  if (this._isDefine) {\n    var parser = defineParsers[nodeName];\n\n    if (parser) {\n      var def = parser.call(this, xmlNode);\n      var id = xmlNode.getAttribute('id');\n\n      if (id) {\n        this._defs[id] = def;\n      }\n    }\n  } else {\n    var parser = nodeParsers[nodeName];\n\n    if (parser) {\n      el = parser.call(this, xmlNode, parentGroup);\n      parentGroup.add(el);\n    }\n  }\n\n  var child = xmlNode.firstChild;\n\n  while (child) {\n    if (child.nodeType === 1) {\n      this._parseNode(child, el);\n    } // Is text\n\n\n    if (child.nodeType === 3 && this._isText) {\n      this._parseText(child, el);\n    }\n\n    child = child.nextSibling;\n  } // Quit define\n\n\n  if (nodeName === 'defs') {\n    this._isDefine = false;\n  } else if (nodeName === 'text') {\n    this._isText = false;\n  }\n};\n\nSVGParser.prototype._parseText = function (xmlNode, parentGroup) {\n  if (xmlNode.nodeType === 1) {\n    var dx = xmlNode.getAttribute('dx') || 0;\n    var dy = xmlNode.getAttribute('dy') || 0;\n    this._textX += parseFloat(dx);\n    this._textY += parseFloat(dy);\n  }\n\n  var text = new Text({\n    style: {\n      text: xmlNode.textContent,\n      transformText: true\n    },\n    position: [this._textX || 0, this._textY || 0]\n  });\n  inheritStyle(parentGroup, text);\n  parseAttributes(xmlNode, text, this._defs);\n  var fontSize = text.style.fontSize;\n\n  if (fontSize && fontSize < 9) {\n    // PENDING\n    text.style.fontSize = 9;\n    text.scale = text.scale || [1, 1];\n    text.scale[0] *= fontSize / 9;\n    text.scale[1] *= fontSize / 9;\n  }\n\n  var rect = text.getBoundingRect();\n  this._textX += rect.width;\n  parentGroup.add(text);\n  return text;\n};\n\nvar nodeParsers = {\n  'g': function (xmlNode, parentGroup) {\n    var g = new Group();\n    inheritStyle(parentGroup, g);\n    parseAttributes(xmlNode, g, this._defs);\n    return g;\n  },\n  'rect': function (xmlNode, parentGroup) {\n    var rect = new Rect();\n    inheritStyle(parentGroup, rect);\n    parseAttributes(xmlNode, rect, this._defs);\n    rect.setShape({\n      x: parseFloat(xmlNode.getAttribute('x') || 0),\n      y: parseFloat(xmlNode.getAttribute('y') || 0),\n      width: parseFloat(xmlNode.getAttribute('width') || 0),\n      height: parseFloat(xmlNode.getAttribute('height') || 0)\n    }); // console.log(xmlNode.getAttribute('transform'));\n    // console.log(rect.transform);\n\n    return rect;\n  },\n  'circle': function (xmlNode, parentGroup) {\n    var circle = new Circle();\n    inheritStyle(parentGroup, circle);\n    parseAttributes(xmlNode, circle, this._defs);\n    circle.setShape({\n      cx: parseFloat(xmlNode.getAttribute('cx') || 0),\n      cy: parseFloat(xmlNode.getAttribute('cy') || 0),\n      r: parseFloat(xmlNode.getAttribute('r') || 0)\n    });\n    return circle;\n  },\n  'line': function (xmlNode, parentGroup) {\n    var line = new Line();\n    inheritStyle(parentGroup, line);\n    parseAttributes(xmlNode, line, this._defs);\n    line.setShape({\n      x1: parseFloat(xmlNode.getAttribute('x1') || 0),\n      y1: parseFloat(xmlNode.getAttribute('y1') || 0),\n      x2: parseFloat(xmlNode.getAttribute('x2') || 0),\n      y2: parseFloat(xmlNode.getAttribute('y2') || 0)\n    });\n    return line;\n  },\n  'ellipse': function (xmlNode, parentGroup) {\n    var ellipse = new Ellipse();\n    inheritStyle(parentGroup, ellipse);\n    parseAttributes(xmlNode, ellipse, this._defs);\n    ellipse.setShape({\n      cx: parseFloat(xmlNode.getAttribute('cx') || 0),\n      cy: parseFloat(xmlNode.getAttribute('cy') || 0),\n      rx: parseFloat(xmlNode.getAttribute('rx') || 0),\n      ry: parseFloat(xmlNode.getAttribute('ry') || 0)\n    });\n    return ellipse;\n  },\n  'polygon': function (xmlNode, parentGroup) {\n    var points = xmlNode.getAttribute('points');\n\n    if (points) {\n      points = parsePoints(points);\n    }\n\n    var polygon = new Polygon({\n      shape: {\n        points: points || []\n      }\n    });\n    inheritStyle(parentGroup, polygon);\n    parseAttributes(xmlNode, polygon, this._defs);\n    return polygon;\n  },\n  'polyline': function (xmlNode, parentGroup) {\n    var path = new Path();\n    inheritStyle(parentGroup, path);\n    parseAttributes(xmlNode, path, this._defs);\n    var points = xmlNode.getAttribute('points');\n\n    if (points) {\n      points = parsePoints(points);\n    }\n\n    var polyline = new Polyline({\n      shape: {\n        points: points || []\n      }\n    });\n    return polyline;\n  },\n  'image': function (xmlNode, parentGroup) {\n    var img = new ZImage();\n    inheritStyle(parentGroup, img);\n    parseAttributes(xmlNode, img, this._defs);\n    img.setStyle({\n      image: xmlNode.getAttribute('xlink:href'),\n      x: xmlNode.getAttribute('x'),\n      y: xmlNode.getAttribute('y'),\n      width: xmlNode.getAttribute('width'),\n      height: xmlNode.getAttribute('height')\n    });\n    return img;\n  },\n  'text': function (xmlNode, parentGroup) {\n    var x = xmlNode.getAttribute('x') || 0;\n    var y = xmlNode.getAttribute('y') || 0;\n    var dx = xmlNode.getAttribute('dx') || 0;\n    var dy = xmlNode.getAttribute('dy') || 0;\n    this._textX = parseFloat(x) + parseFloat(dx);\n    this._textY = parseFloat(y) + parseFloat(dy);\n    var g = new Group();\n    inheritStyle(parentGroup, g);\n    parseAttributes(xmlNode, g, this._defs);\n    return g;\n  },\n  'tspan': function (xmlNode, parentGroup) {\n    var x = xmlNode.getAttribute('x');\n    var y = xmlNode.getAttribute('y');\n\n    if (x != null) {\n      // new offset x\n      this._textX = parseFloat(x);\n    }\n\n    if (y != null) {\n      // new offset y\n      this._textY = parseFloat(y);\n    }\n\n    var dx = xmlNode.getAttribute('dx') || 0;\n    var dy = xmlNode.getAttribute('dy') || 0;\n    var g = new Group();\n    inheritStyle(parentGroup, g);\n    parseAttributes(xmlNode, g, this._defs);\n    this._textX += dx;\n    this._textY += dy;\n    return g;\n  },\n  'path': function (xmlNode, parentGroup) {\n    // TODO svg fill rule\n    // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill-rule\n    // path.style.globalCompositeOperation = 'xor';\n    var d = xmlNode.getAttribute('d') || ''; // Performance sensitive.\n\n    var path = createFromString(d);\n    inheritStyle(parentGroup, path);\n    parseAttributes(xmlNode, path, this._defs);\n    return path;\n  }\n};\nvar defineParsers = {\n  'lineargradient': function (xmlNode) {\n    var x1 = parseInt(xmlNode.getAttribute('x1') || 0, 10);\n    var y1 = parseInt(xmlNode.getAttribute('y1') || 0, 10);\n    var x2 = parseInt(xmlNode.getAttribute('x2') || 10, 10);\n    var y2 = parseInt(xmlNode.getAttribute('y2') || 0, 10);\n    var gradient = new LinearGradient(x1, y1, x2, y2);\n\n    _parseGradientColorStops(xmlNode, gradient);\n\n    return gradient;\n  },\n  'radialgradient': function (xmlNode) {}\n};\n\nfunction _parseGradientColorStops(xmlNode, gradient) {\n  var stop = xmlNode.firstChild;\n\n  while (stop) {\n    if (stop.nodeType === 1) {\n      var offset = stop.getAttribute('offset');\n\n      if (offset.indexOf('%') > 0) {\n        // percentage\n        offset = parseInt(offset, 10) / 100;\n      } else if (offset) {\n        // number from 0 to 1\n        offset = parseFloat(offset);\n      } else {\n        offset = 0;\n      }\n\n      var stopColor = stop.getAttribute('stop-color') || '#000000';\n      gradient.addColorStop(offset, stopColor);\n    }\n\n    stop = stop.nextSibling;\n  }\n}\n\nfunction inheritStyle(parent, child) {\n  if (parent && parent.__inheritedStyle) {\n    if (!child.__inheritedStyle) {\n      child.__inheritedStyle = {};\n    }\n\n    defaults(child.__inheritedStyle, parent.__inheritedStyle);\n  }\n}\n\nfunction parsePoints(pointsString) {\n  var list = trim(pointsString).split(DILIMITER_REG);\n  var points = [];\n\n  for (var i = 0; i < list.length; i += 2) {\n    var x = parseFloat(list[i]);\n    var y = parseFloat(list[i + 1]);\n    points.push([x, y]);\n  }\n\n  return points;\n}\n\nvar attributesMap = {\n  'fill': 'fill',\n  'stroke': 'stroke',\n  'stroke-width': 'lineWidth',\n  'opacity': 'opacity',\n  'fill-opacity': 'fillOpacity',\n  'stroke-opacity': 'strokeOpacity',\n  'stroke-dasharray': 'lineDash',\n  'stroke-dashoffset': 'lineDashOffset',\n  'stroke-linecap': 'lineCap',\n  'stroke-linejoin': 'lineJoin',\n  'stroke-miterlimit': 'miterLimit',\n  'font-family': 'fontFamily',\n  'font-size': 'fontSize',\n  'font-style': 'fontStyle',\n  'font-weight': 'fontWeight',\n  'text-align': 'textAlign',\n  'alignment-baseline': 'textBaseline'\n};\n\nfunction parseAttributes(xmlNode, el, defs, onlyInlineStyle) {\n  var zrStyle = el.__inheritedStyle || {};\n  var isTextEl = el.type === 'text'; // TODO Shadow\n\n  if (xmlNode.nodeType === 1) {\n    parseTransformAttribute(xmlNode, el);\n    extend(zrStyle, parseStyleAttribute(xmlNode));\n\n    if (!onlyInlineStyle) {\n      for (var svgAttrName in attributesMap) {\n        if (attributesMap.hasOwnProperty(svgAttrName)) {\n          var attrValue = xmlNode.getAttribute(svgAttrName);\n\n          if (attrValue != null) {\n            zrStyle[attributesMap[svgAttrName]] = attrValue;\n          }\n        }\n      }\n    }\n  }\n\n  var elFillProp = isTextEl ? 'textFill' : 'fill';\n  var elStrokeProp = isTextEl ? 'textStroke' : 'stroke';\n  el.style = el.style || new Style();\n  var elStyle = el.style;\n  zrStyle.fill != null && elStyle.set(elFillProp, getPaint(zrStyle.fill, defs));\n  zrStyle.stroke != null && elStyle.set(elStrokeProp, getPaint(zrStyle.stroke, defs));\n  each(['lineWidth', 'opacity', 'fillOpacity', 'strokeOpacity', 'miterLimit', 'fontSize'], function (propName) {\n    var elPropName = propName === 'lineWidth' && isTextEl ? 'textStrokeWidth' : propName;\n    zrStyle[propName] != null && elStyle.set(elPropName, parseFloat(zrStyle[propName]));\n  });\n\n  if (!zrStyle.textBaseline || zrStyle.textBaseline === 'auto') {\n    zrStyle.textBaseline = 'alphabetic';\n  }\n\n  if (zrStyle.textBaseline === 'alphabetic') {\n    zrStyle.textBaseline = 'bottom';\n  }\n\n  if (zrStyle.textAlign === 'start') {\n    zrStyle.textAlign = 'left';\n  }\n\n  if (zrStyle.textAlign === 'end') {\n    zrStyle.textAlign = 'right';\n  }\n\n  each(['lineDashOffset', 'lineCap', 'lineJoin', 'fontWeight', 'fontFamily', 'fontStyle', 'textAlign', 'textBaseline'], function (propName) {\n    zrStyle[propName] != null && elStyle.set(propName, zrStyle[propName]);\n  });\n\n  if (zrStyle.lineDash) {\n    el.style.lineDash = trim(zrStyle.lineDash).split(DILIMITER_REG);\n  }\n\n  if (elStyle[elStrokeProp] && elStyle[elStrokeProp] !== 'none') {\n    // enable stroke\n    el[elStrokeProp] = true;\n  }\n\n  el.__inheritedStyle = zrStyle;\n}\n\nvar urlRegex = /url\\(\\s*#(.*?)\\)/;\n\nfunction getPaint(str, defs) {\n  // if (str === 'none') {\n  //     return;\n  // }\n  var urlMatch = defs && str && str.match(urlRegex);\n\n  if (urlMatch) {\n    var url = trim(urlMatch[1]);\n    var def = defs[url];\n    return def;\n  }\n\n  return str;\n}\n\nvar transformRegex = /(translate|scale|rotate|skewX|skewY|matrix)\\(([\\-\\s0-9\\.e,]*)\\)/g;\n\nfunction parseTransformAttribute(xmlNode, node) {\n  var transform = xmlNode.getAttribute('transform');\n\n  if (transform) {\n    transform = transform.replace(/,/g, ' ');\n    var m = null;\n    var transformOps = [];\n    transform.replace(transformRegex, function (str, type, value) {\n      transformOps.push(type, value);\n    });\n\n    for (var i = transformOps.length - 1; i > 0; i -= 2) {\n      var value = transformOps[i];\n      var type = transformOps[i - 1];\n      m = m || matrix.create();\n\n      switch (type) {\n        case 'translate':\n          value = trim(value).split(DILIMITER_REG);\n          matrix.translate(m, m, [parseFloat(value[0]), parseFloat(value[1] || 0)]);\n          break;\n\n        case 'scale':\n          value = trim(value).split(DILIMITER_REG);\n          matrix.scale(m, m, [parseFloat(value[0]), parseFloat(value[1] || value[0])]);\n          break;\n\n        case 'rotate':\n          value = trim(value).split(DILIMITER_REG);\n          matrix.rotate(m, m, parseFloat(value[0]));\n          break;\n\n        case 'skew':\n          value = trim(value).split(DILIMITER_REG);\n          console.warn('Skew transform is not supported yet');\n          break;\n\n        case 'matrix':\n          var value = trim(value).split(DILIMITER_REG);\n          m[0] = parseFloat(value[0]);\n          m[1] = parseFloat(value[1]);\n          m[2] = parseFloat(value[2]);\n          m[3] = parseFloat(value[3]);\n          m[4] = parseFloat(value[4]);\n          m[5] = parseFloat(value[5]);\n          break;\n      }\n    }\n\n    node.setLocalTransform(m);\n  }\n} // Value may contain space.\n\n\nvar styleRegex = /([^\\s:;]+)\\s*:\\s*([^:;]+)/g;\n\nfunction parseStyleAttribute(xmlNode) {\n  var style = xmlNode.getAttribute('style');\n  var result = {};\n\n  if (!style) {\n    return result;\n  }\n\n  var styleList = {};\n  styleRegex.lastIndex = 0;\n  var styleRegResult;\n\n  while ((styleRegResult = styleRegex.exec(style)) != null) {\n    styleList[styleRegResult[1]] = styleRegResult[2];\n  }\n\n  for (var svgAttrName in attributesMap) {\n    if (attributesMap.hasOwnProperty(svgAttrName) && styleList[svgAttrName] != null) {\n      result[attributesMap[svgAttrName]] = styleList[svgAttrName];\n    }\n  }\n\n  return result;\n}\n/**\n * @param {Array.<number>} viewBoxRect\n * @param {number} width\n * @param {number} height\n * @return {Object} {scale, position}\n */\n\n\nfunction makeViewBoxTransform(viewBoxRect, width, height) {\n  var scaleX = width / viewBoxRect.width;\n  var scaleY = height / viewBoxRect.height;\n  var scale = Math.min(scaleX, scaleY); // preserveAspectRatio 'xMidYMid'\n\n  var viewBoxScale = [scale, scale];\n  var viewBoxPosition = [-(viewBoxRect.x + viewBoxRect.width / 2) * scale + width / 2, -(viewBoxRect.y + viewBoxRect.height / 2) * scale + height / 2];\n  return {\n    scale: viewBoxScale,\n    position: viewBoxPosition\n  };\n}\n/**\n * @param {string|XMLElement} xml\n * @param {Object} [opt]\n * @param {number} [opt.width] Default width if svg width not specified or is a percent value.\n * @param {number} [opt.height] Default height if svg height not specified or is a percent value.\n * @param {boolean} [opt.ignoreViewBox]\n * @param {boolean} [opt.ignoreRootClip]\n * @return {Object} result:\n * {\n *     root: Group, The root of the the result tree of zrender shapes,\n *     width: number, the viewport width of the SVG,\n *     height: number, the viewport height of the SVG,\n *     viewBoxRect: {x, y, width, height}, the declared viewBox rect of the SVG, if exists,\n *     viewBoxTransform: the {scale, position} calculated by viewBox and viewport, is exists.\n * }\n */\n\n\nfunction parseSVG(xml, opt) {\n  var parser = new SVGParser();\n  return parser.parse(xml, opt);\n}\n\nexports.parseXML = parseXML;\nexports.makeViewBoxTransform = makeViewBoxTransform;\nexports.parseSVG = parseSVG;","map":{"version":3,"names":["Group","require","ZImage","Text","Circle","Rect","Ellipse","Line","Path","Polygon","Polyline","LinearGradient","Style","matrix","_path","createFromString","_util","isString","extend","defaults","trim","each","DILIMITER_REG","parseXML","svg","parser","DOMParser","parseFromString","nodeType","firstChild","nodeName","toLowerCase","nextSibling","SVGParser","_defs","_root","_isDefine","_isText","prototype","parse","xml","opt","Error","root","viewBox","getAttribute","width","parseFloat","height","isNaN","parseAttributes","child","_parseNode","viewBoxRect","viewBoxTransform","viewBoxArr","split","length","x","y","makeViewBoxTransform","ignoreViewBox","elRoot","add","scale","slice","position","ignoreRootClip","setClipPath","shape","xmlNode","parentGroup","el","defineParsers","def","call","id","nodeParsers","_parseText","dx","dy","_textX","_textY","text","style","textContent","transformText","inheritStyle","fontSize","rect","getBoundingRect","g","setShape","circle","cx","cy","r","line","x1","y1","x2","y2","ellipse","rx","ry","points","parsePoints","polygon","path","polyline","img","setStyle","image","d","parseInt","gradient","_parseGradientColorStops","stop","offset","indexOf","stopColor","addColorStop","parent","__inheritedStyle","pointsString","list","i","push","attributesMap","defs","onlyInlineStyle","zrStyle","isTextEl","type","parseTransformAttribute","parseStyleAttribute","svgAttrName","hasOwnProperty","attrValue","elFillProp","elStrokeProp","elStyle","fill","set","getPaint","stroke","propName","elPropName","textBaseline","textAlign","lineDash","urlRegex","str","urlMatch","match","url","transformRegex","node","transform","replace","m","transformOps","value","create","translate","rotate","console","warn","setLocalTransform","styleRegex","result","styleList","lastIndex","styleRegResult","exec","scaleX","scaleY","Math","min","viewBoxScale","viewBoxPosition","parseSVG","exports"],"sources":["/Users/lord/Documents/Programmer/vue/VueProjects/cloudycraft-vue/blog-admin/node_modules/zrender/lib/tool/parseSVG.js"],"sourcesContent":["var Group = require(\"../container/Group\");\n\nvar ZImage = require(\"../graphic/Image\");\n\nvar Text = require(\"../graphic/Text\");\n\nvar Circle = require(\"../graphic/shape/Circle\");\n\nvar Rect = require(\"../graphic/shape/Rect\");\n\nvar Ellipse = require(\"../graphic/shape/Ellipse\");\n\nvar Line = require(\"../graphic/shape/Line\");\n\nvar Path = require(\"../graphic/Path\");\n\nvar Polygon = require(\"../graphic/shape/Polygon\");\n\nvar Polyline = require(\"../graphic/shape/Polyline\");\n\nvar LinearGradient = require(\"../graphic/LinearGradient\");\n\nvar Style = require(\"../graphic/Style\");\n\nvar matrix = require(\"../core/matrix\");\n\nvar _path = require(\"./path\");\n\nvar createFromString = _path.createFromString;\n\nvar _util = require(\"../core/util\");\n\nvar isString = _util.isString;\nvar extend = _util.extend;\nvar defaults = _util.defaults;\nvar trim = _util.trim;\nvar each = _util.each;\n// import RadialGradient from '../graphic/RadialGradient';\n// import Pattern from '../graphic/Pattern';\n// import * as vector from '../core/vector';\n// Most of the values can be separated by comma and/or white space.\nvar DILIMITER_REG = /[\\s,]+/;\n/**\n * For big svg string, this method might be time consuming.\n *\n * @param {string} svg xml string\n * @return {Object} xml root.\n */\n\nfunction parseXML(svg) {\n  if (isString(svg)) {\n    var parser = new DOMParser();\n    svg = parser.parseFromString(svg, 'text/xml');\n  } // Document node. If using $.get, doc node may be input.\n\n\n  if (svg.nodeType === 9) {\n    svg = svg.firstChild;\n  } // nodeName of <!DOCTYPE svg> is also 'svg'.\n\n\n  while (svg.nodeName.toLowerCase() !== 'svg' || svg.nodeType !== 1) {\n    svg = svg.nextSibling;\n  }\n\n  return svg;\n}\n\nfunction SVGParser() {\n  this._defs = {};\n  this._root = null;\n  this._isDefine = false;\n  this._isText = false;\n}\n\nSVGParser.prototype.parse = function (xml, opt) {\n  opt = opt || {};\n  var svg = parseXML(xml);\n\n  if (!svg) {\n    throw new Error('Illegal svg');\n  }\n\n  var root = new Group();\n  this._root = root; // parse view port\n\n  var viewBox = svg.getAttribute('viewBox') || ''; // If width/height not specified, means \"100%\" of `opt.width/height`.\n  // TODO: Other percent value not supported yet.\n\n  var width = parseFloat(svg.getAttribute('width') || opt.width);\n  var height = parseFloat(svg.getAttribute('height') || opt.height); // If width/height not specified, set as null for output.\n\n  isNaN(width) && (width = null);\n  isNaN(height) && (height = null); // Apply inline style on svg element.\n\n  parseAttributes(svg, root, null, true);\n  var child = svg.firstChild;\n\n  while (child) {\n    this._parseNode(child, root);\n\n    child = child.nextSibling;\n  }\n\n  var viewBoxRect;\n  var viewBoxTransform;\n\n  if (viewBox) {\n    var viewBoxArr = trim(viewBox).split(DILIMITER_REG); // Some invalid case like viewBox: 'none'.\n\n    if (viewBoxArr.length >= 4) {\n      viewBoxRect = {\n        x: parseFloat(viewBoxArr[0] || 0),\n        y: parseFloat(viewBoxArr[1] || 0),\n        width: parseFloat(viewBoxArr[2]),\n        height: parseFloat(viewBoxArr[3])\n      };\n    }\n  }\n\n  if (viewBoxRect && width != null && height != null) {\n    viewBoxTransform = makeViewBoxTransform(viewBoxRect, width, height);\n\n    if (!opt.ignoreViewBox) {\n      // If set transform on the output group, it probably bring trouble when\n      // some users only intend to show the clipped content inside the viewBox,\n      // but not intend to transform the output group. So we keep the output\n      // group no transform. If the user intend to use the viewBox as a\n      // camera, just set `opt.ignoreViewBox` as `true` and set transfrom\n      // manually according to the viewBox info in the output of this method.\n      var elRoot = root;\n      root = new Group();\n      root.add(elRoot);\n      elRoot.scale = viewBoxTransform.scale.slice();\n      elRoot.position = viewBoxTransform.position.slice();\n    }\n  } // Some shapes might be overflow the viewport, which should be\n  // clipped despite whether the viewBox is used, as the SVG does.\n\n\n  if (!opt.ignoreRootClip && width != null && height != null) {\n    root.setClipPath(new Rect({\n      shape: {\n        x: 0,\n        y: 0,\n        width: width,\n        height: height\n      }\n    }));\n  } // Set width/height on group just for output the viewport size.\n\n\n  return {\n    root: root,\n    width: width,\n    height: height,\n    viewBoxRect: viewBoxRect,\n    viewBoxTransform: viewBoxTransform\n  };\n};\n\nSVGParser.prototype._parseNode = function (xmlNode, parentGroup) {\n  var nodeName = xmlNode.nodeName.toLowerCase(); // TODO\n  // support <style>...</style> in svg, where nodeName is 'style',\n  // CSS classes is defined globally wherever the style tags are declared.\n\n  if (nodeName === 'defs') {\n    // define flag\n    this._isDefine = true;\n  } else if (nodeName === 'text') {\n    this._isText = true;\n  }\n\n  var el;\n\n  if (this._isDefine) {\n    var parser = defineParsers[nodeName];\n\n    if (parser) {\n      var def = parser.call(this, xmlNode);\n      var id = xmlNode.getAttribute('id');\n\n      if (id) {\n        this._defs[id] = def;\n      }\n    }\n  } else {\n    var parser = nodeParsers[nodeName];\n\n    if (parser) {\n      el = parser.call(this, xmlNode, parentGroup);\n      parentGroup.add(el);\n    }\n  }\n\n  var child = xmlNode.firstChild;\n\n  while (child) {\n    if (child.nodeType === 1) {\n      this._parseNode(child, el);\n    } // Is text\n\n\n    if (child.nodeType === 3 && this._isText) {\n      this._parseText(child, el);\n    }\n\n    child = child.nextSibling;\n  } // Quit define\n\n\n  if (nodeName === 'defs') {\n    this._isDefine = false;\n  } else if (nodeName === 'text') {\n    this._isText = false;\n  }\n};\n\nSVGParser.prototype._parseText = function (xmlNode, parentGroup) {\n  if (xmlNode.nodeType === 1) {\n    var dx = xmlNode.getAttribute('dx') || 0;\n    var dy = xmlNode.getAttribute('dy') || 0;\n    this._textX += parseFloat(dx);\n    this._textY += parseFloat(dy);\n  }\n\n  var text = new Text({\n    style: {\n      text: xmlNode.textContent,\n      transformText: true\n    },\n    position: [this._textX || 0, this._textY || 0]\n  });\n  inheritStyle(parentGroup, text);\n  parseAttributes(xmlNode, text, this._defs);\n  var fontSize = text.style.fontSize;\n\n  if (fontSize && fontSize < 9) {\n    // PENDING\n    text.style.fontSize = 9;\n    text.scale = text.scale || [1, 1];\n    text.scale[0] *= fontSize / 9;\n    text.scale[1] *= fontSize / 9;\n  }\n\n  var rect = text.getBoundingRect();\n  this._textX += rect.width;\n  parentGroup.add(text);\n  return text;\n};\n\nvar nodeParsers = {\n  'g': function (xmlNode, parentGroup) {\n    var g = new Group();\n    inheritStyle(parentGroup, g);\n    parseAttributes(xmlNode, g, this._defs);\n    return g;\n  },\n  'rect': function (xmlNode, parentGroup) {\n    var rect = new Rect();\n    inheritStyle(parentGroup, rect);\n    parseAttributes(xmlNode, rect, this._defs);\n    rect.setShape({\n      x: parseFloat(xmlNode.getAttribute('x') || 0),\n      y: parseFloat(xmlNode.getAttribute('y') || 0),\n      width: parseFloat(xmlNode.getAttribute('width') || 0),\n      height: parseFloat(xmlNode.getAttribute('height') || 0)\n    }); // console.log(xmlNode.getAttribute('transform'));\n    // console.log(rect.transform);\n\n    return rect;\n  },\n  'circle': function (xmlNode, parentGroup) {\n    var circle = new Circle();\n    inheritStyle(parentGroup, circle);\n    parseAttributes(xmlNode, circle, this._defs);\n    circle.setShape({\n      cx: parseFloat(xmlNode.getAttribute('cx') || 0),\n      cy: parseFloat(xmlNode.getAttribute('cy') || 0),\n      r: parseFloat(xmlNode.getAttribute('r') || 0)\n    });\n    return circle;\n  },\n  'line': function (xmlNode, parentGroup) {\n    var line = new Line();\n    inheritStyle(parentGroup, line);\n    parseAttributes(xmlNode, line, this._defs);\n    line.setShape({\n      x1: parseFloat(xmlNode.getAttribute('x1') || 0),\n      y1: parseFloat(xmlNode.getAttribute('y1') || 0),\n      x2: parseFloat(xmlNode.getAttribute('x2') || 0),\n      y2: parseFloat(xmlNode.getAttribute('y2') || 0)\n    });\n    return line;\n  },\n  'ellipse': function (xmlNode, parentGroup) {\n    var ellipse = new Ellipse();\n    inheritStyle(parentGroup, ellipse);\n    parseAttributes(xmlNode, ellipse, this._defs);\n    ellipse.setShape({\n      cx: parseFloat(xmlNode.getAttribute('cx') || 0),\n      cy: parseFloat(xmlNode.getAttribute('cy') || 0),\n      rx: parseFloat(xmlNode.getAttribute('rx') || 0),\n      ry: parseFloat(xmlNode.getAttribute('ry') || 0)\n    });\n    return ellipse;\n  },\n  'polygon': function (xmlNode, parentGroup) {\n    var points = xmlNode.getAttribute('points');\n\n    if (points) {\n      points = parsePoints(points);\n    }\n\n    var polygon = new Polygon({\n      shape: {\n        points: points || []\n      }\n    });\n    inheritStyle(parentGroup, polygon);\n    parseAttributes(xmlNode, polygon, this._defs);\n    return polygon;\n  },\n  'polyline': function (xmlNode, parentGroup) {\n    var path = new Path();\n    inheritStyle(parentGroup, path);\n    parseAttributes(xmlNode, path, this._defs);\n    var points = xmlNode.getAttribute('points');\n\n    if (points) {\n      points = parsePoints(points);\n    }\n\n    var polyline = new Polyline({\n      shape: {\n        points: points || []\n      }\n    });\n    return polyline;\n  },\n  'image': function (xmlNode, parentGroup) {\n    var img = new ZImage();\n    inheritStyle(parentGroup, img);\n    parseAttributes(xmlNode, img, this._defs);\n    img.setStyle({\n      image: xmlNode.getAttribute('xlink:href'),\n      x: xmlNode.getAttribute('x'),\n      y: xmlNode.getAttribute('y'),\n      width: xmlNode.getAttribute('width'),\n      height: xmlNode.getAttribute('height')\n    });\n    return img;\n  },\n  'text': function (xmlNode, parentGroup) {\n    var x = xmlNode.getAttribute('x') || 0;\n    var y = xmlNode.getAttribute('y') || 0;\n    var dx = xmlNode.getAttribute('dx') || 0;\n    var dy = xmlNode.getAttribute('dy') || 0;\n    this._textX = parseFloat(x) + parseFloat(dx);\n    this._textY = parseFloat(y) + parseFloat(dy);\n    var g = new Group();\n    inheritStyle(parentGroup, g);\n    parseAttributes(xmlNode, g, this._defs);\n    return g;\n  },\n  'tspan': function (xmlNode, parentGroup) {\n    var x = xmlNode.getAttribute('x');\n    var y = xmlNode.getAttribute('y');\n\n    if (x != null) {\n      // new offset x\n      this._textX = parseFloat(x);\n    }\n\n    if (y != null) {\n      // new offset y\n      this._textY = parseFloat(y);\n    }\n\n    var dx = xmlNode.getAttribute('dx') || 0;\n    var dy = xmlNode.getAttribute('dy') || 0;\n    var g = new Group();\n    inheritStyle(parentGroup, g);\n    parseAttributes(xmlNode, g, this._defs);\n    this._textX += dx;\n    this._textY += dy;\n    return g;\n  },\n  'path': function (xmlNode, parentGroup) {\n    // TODO svg fill rule\n    // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill-rule\n    // path.style.globalCompositeOperation = 'xor';\n    var d = xmlNode.getAttribute('d') || ''; // Performance sensitive.\n\n    var path = createFromString(d);\n    inheritStyle(parentGroup, path);\n    parseAttributes(xmlNode, path, this._defs);\n    return path;\n  }\n};\nvar defineParsers = {\n  'lineargradient': function (xmlNode) {\n    var x1 = parseInt(xmlNode.getAttribute('x1') || 0, 10);\n    var y1 = parseInt(xmlNode.getAttribute('y1') || 0, 10);\n    var x2 = parseInt(xmlNode.getAttribute('x2') || 10, 10);\n    var y2 = parseInt(xmlNode.getAttribute('y2') || 0, 10);\n    var gradient = new LinearGradient(x1, y1, x2, y2);\n\n    _parseGradientColorStops(xmlNode, gradient);\n\n    return gradient;\n  },\n  'radialgradient': function (xmlNode) {}\n};\n\nfunction _parseGradientColorStops(xmlNode, gradient) {\n  var stop = xmlNode.firstChild;\n\n  while (stop) {\n    if (stop.nodeType === 1) {\n      var offset = stop.getAttribute('offset');\n\n      if (offset.indexOf('%') > 0) {\n        // percentage\n        offset = parseInt(offset, 10) / 100;\n      } else if (offset) {\n        // number from 0 to 1\n        offset = parseFloat(offset);\n      } else {\n        offset = 0;\n      }\n\n      var stopColor = stop.getAttribute('stop-color') || '#000000';\n      gradient.addColorStop(offset, stopColor);\n    }\n\n    stop = stop.nextSibling;\n  }\n}\n\nfunction inheritStyle(parent, child) {\n  if (parent && parent.__inheritedStyle) {\n    if (!child.__inheritedStyle) {\n      child.__inheritedStyle = {};\n    }\n\n    defaults(child.__inheritedStyle, parent.__inheritedStyle);\n  }\n}\n\nfunction parsePoints(pointsString) {\n  var list = trim(pointsString).split(DILIMITER_REG);\n  var points = [];\n\n  for (var i = 0; i < list.length; i += 2) {\n    var x = parseFloat(list[i]);\n    var y = parseFloat(list[i + 1]);\n    points.push([x, y]);\n  }\n\n  return points;\n}\n\nvar attributesMap = {\n  'fill': 'fill',\n  'stroke': 'stroke',\n  'stroke-width': 'lineWidth',\n  'opacity': 'opacity',\n  'fill-opacity': 'fillOpacity',\n  'stroke-opacity': 'strokeOpacity',\n  'stroke-dasharray': 'lineDash',\n  'stroke-dashoffset': 'lineDashOffset',\n  'stroke-linecap': 'lineCap',\n  'stroke-linejoin': 'lineJoin',\n  'stroke-miterlimit': 'miterLimit',\n  'font-family': 'fontFamily',\n  'font-size': 'fontSize',\n  'font-style': 'fontStyle',\n  'font-weight': 'fontWeight',\n  'text-align': 'textAlign',\n  'alignment-baseline': 'textBaseline'\n};\n\nfunction parseAttributes(xmlNode, el, defs, onlyInlineStyle) {\n  var zrStyle = el.__inheritedStyle || {};\n  var isTextEl = el.type === 'text'; // TODO Shadow\n\n  if (xmlNode.nodeType === 1) {\n    parseTransformAttribute(xmlNode, el);\n    extend(zrStyle, parseStyleAttribute(xmlNode));\n\n    if (!onlyInlineStyle) {\n      for (var svgAttrName in attributesMap) {\n        if (attributesMap.hasOwnProperty(svgAttrName)) {\n          var attrValue = xmlNode.getAttribute(svgAttrName);\n\n          if (attrValue != null) {\n            zrStyle[attributesMap[svgAttrName]] = attrValue;\n          }\n        }\n      }\n    }\n  }\n\n  var elFillProp = isTextEl ? 'textFill' : 'fill';\n  var elStrokeProp = isTextEl ? 'textStroke' : 'stroke';\n  el.style = el.style || new Style();\n  var elStyle = el.style;\n  zrStyle.fill != null && elStyle.set(elFillProp, getPaint(zrStyle.fill, defs));\n  zrStyle.stroke != null && elStyle.set(elStrokeProp, getPaint(zrStyle.stroke, defs));\n  each(['lineWidth', 'opacity', 'fillOpacity', 'strokeOpacity', 'miterLimit', 'fontSize'], function (propName) {\n    var elPropName = propName === 'lineWidth' && isTextEl ? 'textStrokeWidth' : propName;\n    zrStyle[propName] != null && elStyle.set(elPropName, parseFloat(zrStyle[propName]));\n  });\n\n  if (!zrStyle.textBaseline || zrStyle.textBaseline === 'auto') {\n    zrStyle.textBaseline = 'alphabetic';\n  }\n\n  if (zrStyle.textBaseline === 'alphabetic') {\n    zrStyle.textBaseline = 'bottom';\n  }\n\n  if (zrStyle.textAlign === 'start') {\n    zrStyle.textAlign = 'left';\n  }\n\n  if (zrStyle.textAlign === 'end') {\n    zrStyle.textAlign = 'right';\n  }\n\n  each(['lineDashOffset', 'lineCap', 'lineJoin', 'fontWeight', 'fontFamily', 'fontStyle', 'textAlign', 'textBaseline'], function (propName) {\n    zrStyle[propName] != null && elStyle.set(propName, zrStyle[propName]);\n  });\n\n  if (zrStyle.lineDash) {\n    el.style.lineDash = trim(zrStyle.lineDash).split(DILIMITER_REG);\n  }\n\n  if (elStyle[elStrokeProp] && elStyle[elStrokeProp] !== 'none') {\n    // enable stroke\n    el[elStrokeProp] = true;\n  }\n\n  el.__inheritedStyle = zrStyle;\n}\n\nvar urlRegex = /url\\(\\s*#(.*?)\\)/;\n\nfunction getPaint(str, defs) {\n  // if (str === 'none') {\n  //     return;\n  // }\n  var urlMatch = defs && str && str.match(urlRegex);\n\n  if (urlMatch) {\n    var url = trim(urlMatch[1]);\n    var def = defs[url];\n    return def;\n  }\n\n  return str;\n}\n\nvar transformRegex = /(translate|scale|rotate|skewX|skewY|matrix)\\(([\\-\\s0-9\\.e,]*)\\)/g;\n\nfunction parseTransformAttribute(xmlNode, node) {\n  var transform = xmlNode.getAttribute('transform');\n\n  if (transform) {\n    transform = transform.replace(/,/g, ' ');\n    var m = null;\n    var transformOps = [];\n    transform.replace(transformRegex, function (str, type, value) {\n      transformOps.push(type, value);\n    });\n\n    for (var i = transformOps.length - 1; i > 0; i -= 2) {\n      var value = transformOps[i];\n      var type = transformOps[i - 1];\n      m = m || matrix.create();\n\n      switch (type) {\n        case 'translate':\n          value = trim(value).split(DILIMITER_REG);\n          matrix.translate(m, m, [parseFloat(value[0]), parseFloat(value[1] || 0)]);\n          break;\n\n        case 'scale':\n          value = trim(value).split(DILIMITER_REG);\n          matrix.scale(m, m, [parseFloat(value[0]), parseFloat(value[1] || value[0])]);\n          break;\n\n        case 'rotate':\n          value = trim(value).split(DILIMITER_REG);\n          matrix.rotate(m, m, parseFloat(value[0]));\n          break;\n\n        case 'skew':\n          value = trim(value).split(DILIMITER_REG);\n          console.warn('Skew transform is not supported yet');\n          break;\n\n        case 'matrix':\n          var value = trim(value).split(DILIMITER_REG);\n          m[0] = parseFloat(value[0]);\n          m[1] = parseFloat(value[1]);\n          m[2] = parseFloat(value[2]);\n          m[3] = parseFloat(value[3]);\n          m[4] = parseFloat(value[4]);\n          m[5] = parseFloat(value[5]);\n          break;\n      }\n    }\n\n    node.setLocalTransform(m);\n  }\n} // Value may contain space.\n\n\nvar styleRegex = /([^\\s:;]+)\\s*:\\s*([^:;]+)/g;\n\nfunction parseStyleAttribute(xmlNode) {\n  var style = xmlNode.getAttribute('style');\n  var result = {};\n\n  if (!style) {\n    return result;\n  }\n\n  var styleList = {};\n  styleRegex.lastIndex = 0;\n  var styleRegResult;\n\n  while ((styleRegResult = styleRegex.exec(style)) != null) {\n    styleList[styleRegResult[1]] = styleRegResult[2];\n  }\n\n  for (var svgAttrName in attributesMap) {\n    if (attributesMap.hasOwnProperty(svgAttrName) && styleList[svgAttrName] != null) {\n      result[attributesMap[svgAttrName]] = styleList[svgAttrName];\n    }\n  }\n\n  return result;\n}\n/**\n * @param {Array.<number>} viewBoxRect\n * @param {number} width\n * @param {number} height\n * @return {Object} {scale, position}\n */\n\n\nfunction makeViewBoxTransform(viewBoxRect, width, height) {\n  var scaleX = width / viewBoxRect.width;\n  var scaleY = height / viewBoxRect.height;\n  var scale = Math.min(scaleX, scaleY); // preserveAspectRatio 'xMidYMid'\n\n  var viewBoxScale = [scale, scale];\n  var viewBoxPosition = [-(viewBoxRect.x + viewBoxRect.width / 2) * scale + width / 2, -(viewBoxRect.y + viewBoxRect.height / 2) * scale + height / 2];\n  return {\n    scale: viewBoxScale,\n    position: viewBoxPosition\n  };\n}\n/**\n * @param {string|XMLElement} xml\n * @param {Object} [opt]\n * @param {number} [opt.width] Default width if svg width not specified or is a percent value.\n * @param {number} [opt.height] Default height if svg height not specified or is a percent value.\n * @param {boolean} [opt.ignoreViewBox]\n * @param {boolean} [opt.ignoreRootClip]\n * @return {Object} result:\n * {\n *     root: Group, The root of the the result tree of zrender shapes,\n *     width: number, the viewport width of the SVG,\n *     height: number, the viewport height of the SVG,\n *     viewBoxRect: {x, y, width, height}, the declared viewBox rect of the SVG, if exists,\n *     viewBoxTransform: the {scale, position} calculated by viewBox and viewport, is exists.\n * }\n */\n\n\nfunction parseSVG(xml, opt) {\n  var parser = new SVGParser();\n  return parser.parse(xml, opt);\n}\n\nexports.parseXML = parseXML;\nexports.makeViewBoxTransform = makeViewBoxTransform;\nexports.parseSVG = parseSVG;"],"mappings":"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"},"metadata":{},"sourceType":"script"}