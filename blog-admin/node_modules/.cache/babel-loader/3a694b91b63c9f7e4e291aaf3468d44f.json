{"ast":null,"code":"/* Process inline math */\n\n/*\nLike markdown-it-simplemath, this is a stripped down, simplified version of:\nhttps://github.com/runarberg/markdown-it-math\n\nIt differs in that it takes (a subset of) LaTeX as input and relies on KaTeX\nfor rendering output.\n*/\n\n/*jslint node: true */\n'use strict';\n\nvar katex = require('katex'); // Test if potential opening or closing delimieter\n// Assumes that there is a \"$\" at state.src[pos]\n\n\nfunction isValidDelim(state, pos) {\n  var prevChar,\n      nextChar,\n      max = state.posMax,\n      can_open = true,\n      can_close = true;\n  prevChar = pos > 0 ? state.src.charCodeAt(pos - 1) : -1;\n  nextChar = pos + 1 <= max ? state.src.charCodeAt(pos + 1) : -1; // Check non-whitespace conditions for opening and closing, and\n  // check that closing delimeter isn't followed by a number\n\n  if (prevChar === 0x20\n  /* \" \" */\n  || prevChar === 0x09\n  /* \\t */\n  || nextChar >= 0x30\n  /* \"0\" */\n  && nextChar <= 0x39\n  /* \"9\" */\n  ) {\n    can_close = false;\n  }\n\n  if (nextChar === 0x20\n  /* \" \" */\n  || nextChar === 0x09\n  /* \\t */\n  ) {\n    can_open = false;\n  }\n\n  return {\n    can_open: can_open,\n    can_close: can_close\n  };\n}\n\nfunction math_inline(state, silent) {\n  var start, match, token, res, pos, esc_count;\n\n  if (state.src[state.pos] !== \"$\") {\n    return false;\n  }\n\n  res = isValidDelim(state, state.pos);\n\n  if (!res.can_open) {\n    if (!silent) {\n      state.pending += \"$\";\n    }\n\n    state.pos += 1;\n    return true;\n  } // First check for and bypass all properly escaped delimieters\n  // This loop will assume that the first leading backtick can not\n  // be the first character in state.src, which is known since\n  // we have found an opening delimieter already.\n\n\n  start = state.pos + 1;\n  match = start;\n\n  while ((match = state.src.indexOf(\"$\", match)) !== -1) {\n    // Found potential $, look for escapes, pos will point to\n    // first non escape when complete\n    pos = match - 1;\n\n    while (state.src[pos] === \"\\\\\") {\n      pos -= 1;\n    } // Even number of escapes, potential closing delimiter found\n\n\n    if ((match - pos) % 2 == 1) {\n      break;\n    }\n\n    match += 1;\n  } // No closing delimter found.  Consume $ and continue.\n\n\n  if (match === -1) {\n    if (!silent) {\n      state.pending += \"$\";\n    }\n\n    state.pos = start;\n    return true;\n  } // Check if we have empty content, ie: $$.  Do not parse.\n\n\n  if (match - start === 0) {\n    if (!silent) {\n      state.pending += \"$$\";\n    }\n\n    state.pos = start + 1;\n    return true;\n  } // Check for valid closing delimiter\n\n\n  res = isValidDelim(state, match);\n\n  if (!res.can_close) {\n    if (!silent) {\n      state.pending += \"$\";\n    }\n\n    state.pos = start;\n    return true;\n  }\n\n  if (!silent) {\n    token = state.push('math_inline', 'math', 0);\n    token.markup = \"$\";\n    token.content = state.src.slice(start, match);\n  }\n\n  state.pos = match + 1;\n  return true;\n}\n\nfunction math_block(state, start, end, silent) {\n  var firstLine,\n      lastLine,\n      next,\n      lastPos,\n      found = false,\n      token,\n      pos = state.bMarks[start] + state.tShift[start],\n      max = state.eMarks[start];\n\n  if (pos + 2 > max) {\n    return false;\n  }\n\n  if (state.src.slice(pos, pos + 2) !== '$$') {\n    return false;\n  }\n\n  pos += 2;\n  firstLine = state.src.slice(pos, max);\n\n  if (silent) {\n    return true;\n  }\n\n  if (firstLine.trim().slice(-2) === '$$') {\n    // Single line expression\n    firstLine = firstLine.trim().slice(0, -2);\n    found = true;\n  }\n\n  for (next = start; !found;) {\n    next++;\n\n    if (next >= end) {\n      break;\n    }\n\n    pos = state.bMarks[next] + state.tShift[next];\n    max = state.eMarks[next];\n\n    if (pos < max && state.tShift[next] < state.blkIndent) {\n      // non-empty line with negative indent should stop the list:\n      break;\n    }\n\n    if (state.src.slice(pos, max).trim().slice(-2) === '$$') {\n      lastPos = state.src.slice(0, max).lastIndexOf('$$');\n      lastLine = state.src.slice(pos, lastPos);\n      found = true;\n    }\n  }\n\n  state.line = next + 1;\n  token = state.push('math_block', 'math', 0);\n  token.block = true;\n  token.content = (firstLine && firstLine.trim() ? firstLine + '\\n' : '') + state.getLines(start + 1, next, state.tShift[start], true) + (lastLine && lastLine.trim() ? lastLine : '');\n  token.map = [start, state.line];\n  token.markup = '$$';\n  return true;\n}\n\nfunction escapeHtml(unsafe) {\n  return unsafe.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\").replace(/\"/g, \"&quot;\").replace(/'/g, \"&#039;\");\n}\n\nmodule.exports = function math_plugin(md, options) {\n  // Default options\n  options = options || {}; // set KaTeX as the renderer for markdown-it-simplemath\n\n  var katexInline = function (latex) {\n    options.displayMode = false;\n\n    try {\n      return katex.renderToString(latex, options);\n    } catch (error) {\n      if (options.throwOnError) {\n        console.log(error);\n      }\n\n      return `<span class='katex-error' title='${escapeHtml(error.toString())}'>${escapeHtml(latex)}</span>`;\n    }\n  };\n\n  var inlineRenderer = function (tokens, idx) {\n    return katexInline(tokens[idx].content);\n  };\n\n  var katexBlock = function (latex) {\n    options.displayMode = true;\n\n    try {\n      return \"<p class='katex-block'>\" + katex.renderToString(latex, options) + \"</p>\";\n    } catch (error) {\n      if (options.throwOnError) {\n        console.log(error);\n      }\n\n      return `<p class='katex-block katex-error' title='${escapeHtml(error.toString())}'>${escapeHtml(latex)}</p>`;\n    }\n  };\n\n  var blockRenderer = function (tokens, idx) {\n    return katexBlock(tokens[idx].content) + '\\n';\n  };\n\n  md.inline.ruler.after('escape', 'math_inline', math_inline);\n  md.block.ruler.after('blockquote', 'math_block', math_block, {\n    alt: ['paragraph', 'reference', 'blockquote', 'list']\n  });\n  md.renderer.rules.math_inline = inlineRenderer;\n  md.renderer.rules.math_block = blockRenderer;\n};","map":{"version":3,"names":["katex","require","isValidDelim","state","pos","prevChar","nextChar","max","posMax","can_open","can_close","src","charCodeAt","math_inline","silent","start","match","token","res","esc_count","pending","indexOf","push","markup","content","slice","math_block","end","firstLine","lastLine","next","lastPos","found","bMarks","tShift","eMarks","trim","blkIndent","lastIndexOf","line","block","getLines","map","escapeHtml","unsafe","replace","module","exports","math_plugin","md","options","katexInline","latex","displayMode","renderToString","error","throwOnError","console","log","toString","inlineRenderer","tokens","idx","katexBlock","blockRenderer","inline","ruler","after","alt","renderer","rules"],"sources":["/Users/lord/Documents/Programmer/vue/VueProjects/cloudycraft-vue/blog-admin/node_modules/@iktakahiro/markdown-it-katex/index.js"],"sourcesContent":["/* Process inline math */\n/*\nLike markdown-it-simplemath, this is a stripped down, simplified version of:\nhttps://github.com/runarberg/markdown-it-math\n\nIt differs in that it takes (a subset of) LaTeX as input and relies on KaTeX\nfor rendering output.\n*/\n\n/*jslint node: true */\n'use strict';\n\nvar katex = require('katex');\n\n// Test if potential opening or closing delimieter\n// Assumes that there is a \"$\" at state.src[pos]\nfunction isValidDelim(state, pos) {\n    var prevChar, nextChar,\n        max = state.posMax,\n        can_open = true,\n        can_close = true;\n\n    prevChar = pos > 0 ? state.src.charCodeAt(pos - 1) : -1;\n    nextChar = pos + 1 <= max ? state.src.charCodeAt(pos + 1) : -1;\n\n    // Check non-whitespace conditions for opening and closing, and\n    // check that closing delimeter isn't followed by a number\n    if (prevChar === 0x20/* \" \" */ || prevChar === 0x09/* \\t */ ||\n            (nextChar >= 0x30/* \"0\" */ && nextChar <= 0x39/* \"9\" */)) {\n        can_close = false;\n    }\n    if (nextChar === 0x20/* \" \" */ || nextChar === 0x09/* \\t */) {\n        can_open = false;\n    }\n\n    return {\n        can_open: can_open,\n        can_close: can_close\n    };\n}\n\nfunction math_inline(state, silent) {\n    var start, match, token, res, pos, esc_count;\n\n    if (state.src[state.pos] !== \"$\") { return false; }\n\n    res = isValidDelim(state, state.pos);\n    if (!res.can_open) {\n        if (!silent) { state.pending += \"$\"; }\n        state.pos += 1;\n        return true;\n    }\n\n    // First check for and bypass all properly escaped delimieters\n    // This loop will assume that the first leading backtick can not\n    // be the first character in state.src, which is known since\n    // we have found an opening delimieter already.\n    start = state.pos + 1;\n    match = start;\n    while ( (match = state.src.indexOf(\"$\", match)) !== -1) {\n        // Found potential $, look for escapes, pos will point to\n        // first non escape when complete\n        pos = match - 1;\n        while (state.src[pos] === \"\\\\\") { pos -= 1; }\n\n        // Even number of escapes, potential closing delimiter found\n        if ( ((match - pos) % 2) == 1 ) { break; }\n        match += 1;\n    }\n\n    // No closing delimter found.  Consume $ and continue.\n    if (match === -1) {\n        if (!silent) { state.pending += \"$\"; }\n        state.pos = start;\n        return true;\n    }\n\n    // Check if we have empty content, ie: $$.  Do not parse.\n    if (match - start === 0) {\n        if (!silent) { state.pending += \"$$\"; }\n        state.pos = start + 1;\n        return true;\n    }\n\n    // Check for valid closing delimiter\n    res = isValidDelim(state, match);\n    if (!res.can_close) {\n        if (!silent) { state.pending += \"$\"; }\n        state.pos = start;\n        return true;\n    }\n\n    if (!silent) {\n        token         = state.push('math_inline', 'math', 0);\n        token.markup  = \"$\";\n        token.content = state.src.slice(start, match);\n    }\n\n    state.pos = match + 1;\n    return true;\n}\n\nfunction math_block(state, start, end, silent){\n    var firstLine, lastLine, next, lastPos, found = false, token,\n        pos = state.bMarks[start] + state.tShift[start],\n        max = state.eMarks[start]\n\n    if(pos + 2 > max){ return false; }\n    if(state.src.slice(pos,pos+2)!=='$$'){ return false; }\n\n    pos += 2;\n    firstLine = state.src.slice(pos,max);\n\n    if(silent){ return true; }\n    if(firstLine.trim().slice(-2)==='$$'){\n        // Single line expression\n        firstLine = firstLine.trim().slice(0, -2);\n        found = true;\n    }\n\n    for(next = start; !found; ){\n\n        next++;\n\n        if(next >= end){ break; }\n\n        pos = state.bMarks[next]+state.tShift[next];\n        max = state.eMarks[next];\n\n        if(pos < max && state.tShift[next] < state.blkIndent){\n            // non-empty line with negative indent should stop the list:\n            break;\n        }\n\n        if(state.src.slice(pos,max).trim().slice(-2)==='$$'){\n            lastPos = state.src.slice(0,max).lastIndexOf('$$');\n            lastLine = state.src.slice(pos,lastPos);\n            found = true;\n        }\n\n    }\n\n    state.line = next + 1;\n\n    token = state.push('math_block', 'math', 0);\n    token.block = true;\n    token.content = (firstLine && firstLine.trim() ? firstLine + '\\n' : '')\n    + state.getLines(start + 1, next, state.tShift[start], true)\n    + (lastLine && lastLine.trim() ? lastLine : '');\n    token.map = [ start, state.line ];\n    token.markup = '$$';\n    return true;\n}\n\nfunction escapeHtml(unsafe) {\n    return unsafe\n        .replace(/&/g, \"&amp;\")\n        .replace(/</g, \"&lt;\")\n        .replace(/>/g, \"&gt;\")\n        .replace(/\"/g, \"&quot;\")\n        .replace(/'/g, \"&#039;\");\n}\n\nmodule.exports = function math_plugin(md, options) {\n    // Default options\n\n    options = options || {};\n\n    // set KaTeX as the renderer for markdown-it-simplemath\n    var katexInline = function(latex){\n        options.displayMode = false;\n        try{\n            return katex.renderToString(latex, options);\n        }\n        catch(error){\n            if(options.throwOnError){ console.log(error); }\n            return `<span class='katex-error' title='${escapeHtml(error.toString())}'>${escapeHtml(latex)}</span>`;\n        }\n    };\n\n    var inlineRenderer = function(tokens, idx){\n        return katexInline(tokens[idx].content);\n    };\n\n    var katexBlock = function(latex){\n        options.displayMode = true;\n        try{\n            return \"<p class='katex-block'>\" + katex.renderToString(latex, options) + \"</p>\";\n        }\n        catch(error){\n            if(options.throwOnError){ console.log(error); }\n            return `<p class='katex-block katex-error' title='${escapeHtml(error.toString())}'>${escapeHtml(latex)}</p>`;\n        }\n    }\n\n    var blockRenderer = function(tokens, idx){\n        return  katexBlock(tokens[idx].content) + '\\n';\n    }\n\n    md.inline.ruler.after('escape', 'math_inline', math_inline);\n    md.block.ruler.after('blockquote', 'math_block', math_block, {\n        alt: [ 'paragraph', 'reference', 'blockquote', 'list' ]\n    });\n    md.renderer.rules.math_inline = inlineRenderer;\n    md.renderer.rules.math_block = blockRenderer;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}