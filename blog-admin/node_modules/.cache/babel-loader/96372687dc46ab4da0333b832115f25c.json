{"ast":null,"code":"import echarts from 'echarts/lib/echarts';\nimport debounce from 'lodash/debounce';\nimport { addListener, removeListener } from 'resize-detector';\nconst INIT_TRIGGERS = ['theme', 'initOptions', 'autoresize'];\nconst REWATCH_TRIGGERS = ['manualUpdate', 'watchShallow'];\nexport default {\n  props: {\n    options: Object,\n    theme: [String, Object],\n    initOptions: Object,\n    group: String,\n    autoresize: Boolean,\n    watchShallow: Boolean,\n    manualUpdate: Boolean\n  },\n\n  data() {\n    return {\n      lastArea: 0\n    };\n  },\n\n  watch: {\n    group(group) {\n      this.chart.group = group;\n    }\n\n  },\n  methods: {\n    // provide an explicit merge option method\n    mergeOptions(options, notMerge, lazyUpdate) {\n      if (this.manualUpdate) {\n        this.manualOptions = options;\n      }\n\n      if (!this.chart) {\n        this.init(options);\n      } else {\n        this.delegateMethod('setOption', options, notMerge, lazyUpdate);\n      }\n    },\n\n    // just delegates ECharts methods to Vue component\n    // use explicit params to reduce transpiled size for now\n    appendData(params) {\n      this.delegateMethod('appendData', params);\n    },\n\n    resize(options) {\n      this.delegateMethod('resize', options);\n    },\n\n    dispatchAction(payload) {\n      this.delegateMethod('dispatchAction', payload);\n    },\n\n    convertToPixel(finder, value) {\n      return this.delegateMethod('convertToPixel', finder, value);\n    },\n\n    convertFromPixel(finder, value) {\n      return this.delegateMethod('convertFromPixel', finder, value);\n    },\n\n    containPixel(finder, value) {\n      return this.delegateMethod('containPixel', finder, value);\n    },\n\n    showLoading(type, options) {\n      this.delegateMethod('showLoading', type, options);\n    },\n\n    hideLoading() {\n      this.delegateMethod('hideLoading');\n    },\n\n    getDataURL(options) {\n      return this.delegateMethod('getDataURL', options);\n    },\n\n    getConnectedDataURL(options) {\n      return this.delegateMethod('getConnectedDataURL', options);\n    },\n\n    clear() {\n      this.delegateMethod('clear');\n    },\n\n    dispose() {\n      this.delegateMethod('dispose');\n    },\n\n    delegateMethod(name, ...args) {\n      if (!this.chart) {\n        this.init();\n      }\n\n      return this.chart[name](...args);\n    },\n\n    delegateGet(methodName) {\n      if (!this.chart) {\n        this.init();\n      }\n\n      return this.chart[methodName]();\n    },\n\n    getArea() {\n      return this.$el.offsetWidth * this.$el.offsetHeight;\n    },\n\n    init(options) {\n      if (this.chart) {\n        return;\n      }\n\n      const chart = echarts.init(this.$el, this.theme, this.initOptions);\n\n      if (this.group) {\n        chart.group = this.group;\n      }\n\n      chart.setOption(options || this.manualOptions || this.options || {}, true);\n      Object.keys(this.$listeners).forEach(event => {\n        const handler = this.$listeners[event];\n\n        if (event.indexOf('zr:') === 0) {\n          chart.getZr().on(event.slice(3), handler);\n        } else {\n          chart.on(event, handler);\n        }\n      });\n\n      if (this.autoresize) {\n        this.lastArea = this.getArea();\n        this.__resizeHandler = debounce(() => {\n          if (this.lastArea === 0) {\n            // emulate initial render for initially hidden charts\n            this.mergeOptions({}, true);\n            this.resize();\n            this.mergeOptions(this.options || this.manualOptions || {}, true);\n          } else {\n            this.resize();\n          }\n\n          this.lastArea = this.getArea();\n        }, 100, {\n          leading: true\n        });\n        addListener(this.$el, this.__resizeHandler);\n      }\n\n      Object.defineProperties(this, {\n        // Only recalculated when accessed from JavaScript.\n        // Won't update DOM on value change because getters\n        // don't depend on reactive values\n        width: {\n          configurable: true,\n          get: () => {\n            return this.delegateGet('getWidth');\n          }\n        },\n        height: {\n          configurable: true,\n          get: () => {\n            return this.delegateGet('getHeight');\n          }\n        },\n        isDisposed: {\n          configurable: true,\n          get: () => {\n            return !!this.delegateGet('isDisposed');\n          }\n        },\n        computedOptions: {\n          configurable: true,\n          get: () => {\n            return this.delegateGet('getOption');\n          }\n        }\n      });\n      this.chart = chart;\n    },\n\n    initOptionsWatcher() {\n      if (this.__unwatchOptions) {\n        this.__unwatchOptions();\n\n        this.__unwatchOptions = null;\n      }\n\n      if (!this.manualUpdate) {\n        this.__unwatchOptions = this.$watch('options', (val, oldVal) => {\n          if (!this.chart && val) {\n            this.init();\n          } else {\n            // mutating `options` will lead to merging\n            // replacing it with new reference will lead to not merging\n            // eg.\n            // `this.options = Object.assign({}, this.options, { ... })`\n            // will trigger `this.chart.setOption(val, true)\n            // `this.options.title.text = 'Trends'`\n            // will trigger `this.chart.setOption(val, false)`\n            this.chart.setOption(val, val !== oldVal);\n          }\n        }, {\n          deep: !this.watchShallow\n        });\n      }\n    },\n\n    destroy() {\n      if (this.autoresize) {\n        removeListener(this.$el, this.__resizeHandler);\n      }\n\n      this.dispose();\n      this.chart = null;\n    },\n\n    refresh() {\n      if (this.chart) {\n        this.destroy();\n        this.init();\n      }\n    }\n\n  },\n\n  created() {\n    this.initOptionsWatcher();\n    INIT_TRIGGERS.forEach(prop => {\n      this.$watch(prop, () => {\n        this.refresh();\n      }, {\n        deep: true\n      });\n    });\n    REWATCH_TRIGGERS.forEach(prop => {\n      this.$watch(prop, () => {\n        this.initOptionsWatcher();\n        this.refresh();\n      });\n    });\n  },\n\n  mounted() {\n    // auto init if `options` is already provided\n    if (this.options) {\n      this.init();\n    }\n  },\n\n  activated() {\n    if (this.autoresize) {\n      this.chart && this.chart.resize();\n    }\n  },\n\n  destroyed() {\n    if (this.chart) {\n      this.destroy();\n    }\n  },\n\n  connect(group) {\n    if (typeof group !== 'string') {\n      group = group.map(chart => chart.chart);\n    }\n\n    echarts.connect(group);\n  },\n\n  disconnect(group) {\n    echarts.disConnect(group);\n  },\n\n  registerMap(mapName, geoJSON, specialAreas) {\n    echarts.registerMap(mapName, geoJSON, specialAreas);\n  },\n\n  registerTheme(name, theme) {\n    echarts.registerTheme(name, theme);\n  },\n\n  graphic: echarts.graphic\n};","map":{"version":3,"mappings":"AAYA;AACA;AACA;AAEA;AACA;AAEA;EACAA;IACAC,eADA;IAEAC,uBAFA;IAGAC,mBAHA;IAIAC,aAJA;IAKAC,mBALA;IAMAC,qBANA;IAOAC;EAPA,CADA;;EAUAC;IACA;MACAC;IADA;EAGA,CAdA;;EAeAC;IACAN;MACA;IACA;;EAHA,CAfA;EAoBAO;IACA;IACAC;MACA;QACA;MACA;;MAEA;QACA;MACA,CAFA,MAEA;QACA;MACA;IACA,CAZA;;IAaA;IACA;IACAC;MACA;IACA,CAjBA;;IAkBAC;MACA;IACA,CApBA;;IAqBAC;MACA;IACA,CAvBA;;IAwBAC;MACA;IACA,CA1BA;;IA2BAC;MACA;IACA,CA7BA;;IA8BAC;MACA;IACA,CAhCA;;IAiCAC;MACA;IACA,CAnCA;;IAoCAC;MACA;IACA,CAtCA;;IAuCAC;MACA;IACA,CAzCA;;IA0CAC;MACA;IACA,CA5CA;;IA6CAC;MACA;IACA,CA/CA;;IAgDAC;MACA;IACA,CAlDA;;IAmDAC;MACA;QACA;MACA;;MACA;IACA,CAxDA;;IAyDAC;MACA;QACA;MACA;;MACA;IACA,CA9DA;;IA+DAC;MACA;IACA,CAjEA;;IAkEAC;MACA;QACA;MACA;;MAEA;;MAEA;QACAC;MACA;;MAEAA;MAEAC;QACA;;QAEA;UACAD;QACA,CAFA,MAEA;UACAA;QACA;MACA,CARA;;MAUA;QACA;QACA,gCACA;UACA;YACA;YACA;YACA;YACA;UACA,CALA,MAKA;YACA;UACA;;UACA;QACA,CAXA,EAYA,GAZA,EAaA;UAAAE;QAAA,CAbA;QAeAC;MACA;;MAEAF;QACA;QACA;QACA;QACAG;UACAC,kBADA;UAEAC;YACA;UACA;QAJA,CAJA;QAUAC;UACAF,kBADA;UAEAC;YACA;UACA;QAJA,CAVA;QAgBAE;UACAH,kBADA;UAEAC;YACA;UACA;QAJA,CAhBA;QAsBAG;UACAJ,kBADA;UAEAC;YACA;UACA;QAJA;MAtBA;MA8BA;IACA,CA5IA;;IA6IAI;MACA;QACA;;QACA;MACA;;MAEA;QACA,oCACA,SADA,EAEA;UACA;YACA;UACA,CAFA,MAEA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;UACA;QACA,CAfA,EAgBA;UAAAC;QAAA,CAhBA;MAkBA;IACA,CAvKA;;IAwKAC;MACA;QACAC;MACA;;MACA;MACA;IACA,CA9KA;;IA+KAC;MACA;QACA;QACA;MACA;IACA;;EApLA,CApBA;;EA0MAC;IACA;IAEAC;MACA,YACAC,IADA,EAEA;QACA;MACA,CAJA,EAKA;QAAAN;MAAA,CALA;IAOA,CARA;IAUAO;MACA;QACA;QACA;MACA,CAHA;IAIA,CALA;EAMA,CA7NA;;EA8NAC;IACA;IACA;MACA;IACA;EACA,CAnOA;;EAoOAC;IACA;MACA;IACA;EACA,CAxOA;;EAyOAC;IACA;MACA;IACA;EACA,CA7OA;;EA8OAC;IACA;MACA/C;IACA;;IACAgD;EACA,CAnPA;;EAoPAC;IACAD;EACA,CAtPA;;EAuPAE;IACAF;EACA,CAzPA;;EA0PAG;IACAH;EACA,CA5PA;;EA6PAI;AA7PA","names":["props","options","theme","initOptions","group","autoresize","watchShallow","manualUpdate","data","lastArea","watch","methods","mergeOptions","appendData","resize","dispatchAction","convertToPixel","convertFromPixel","containPixel","showLoading","hideLoading","getDataURL","getConnectedDataURL","clear","dispose","delegateMethod","delegateGet","getArea","init","chart","Object","leading","addListener","width","configurable","get","height","isDisposed","computedOptions","initOptionsWatcher","deep","destroy","removeListener","refresh","created","INIT_TRIGGERS","prop","REWATCH_TRIGGERS","mounted","activated","destroyed","connect","echarts","disconnect","registerMap","registerTheme","graphic"],"sourceRoot":"node_modules/vue-echarts/components","sources":["ECharts.vue"],"sourcesContent":["<template>\n  <div class=\"echarts\" />\n</template>\n\n<style>\n.echarts {\n  width: 600px;\n  height: 400px;\n}\n</style>\n\n<script>\nimport echarts from 'echarts/lib/echarts'\nimport debounce from 'lodash/debounce'\nimport { addListener, removeListener } from 'resize-detector'\n\nconst INIT_TRIGGERS = ['theme', 'initOptions', 'autoresize']\nconst REWATCH_TRIGGERS = ['manualUpdate', 'watchShallow']\n\nexport default {\n  props: {\n    options: Object,\n    theme: [String, Object],\n    initOptions: Object,\n    group: String,\n    autoresize: Boolean,\n    watchShallow: Boolean,\n    manualUpdate: Boolean\n  },\n  data () {\n    return {\n      lastArea: 0\n    }\n  },\n  watch: {\n    group (group) {\n      this.chart.group = group\n    }\n  },\n  methods: {\n    // provide an explicit merge option method\n    mergeOptions (options, notMerge, lazyUpdate) {\n      if (this.manualUpdate) {\n        this.manualOptions = options\n      }\n\n      if (!this.chart) {\n        this.init(options)\n      } else {\n        this.delegateMethod('setOption', options, notMerge, lazyUpdate)\n      }\n    },\n    // just delegates ECharts methods to Vue component\n    // use explicit params to reduce transpiled size for now\n    appendData (params) {\n      this.delegateMethod('appendData', params)\n    },\n    resize (options) {\n      this.delegateMethod('resize', options)\n    },\n    dispatchAction (payload) {\n      this.delegateMethod('dispatchAction', payload)\n    },\n    convertToPixel (finder, value) {\n      return this.delegateMethod('convertToPixel', finder, value)\n    },\n    convertFromPixel (finder, value) {\n      return this.delegateMethod('convertFromPixel', finder, value)\n    },\n    containPixel (finder, value) {\n      return this.delegateMethod('containPixel', finder, value)\n    },\n    showLoading (type, options) {\n      this.delegateMethod('showLoading', type, options)\n    },\n    hideLoading () {\n      this.delegateMethod('hideLoading')\n    },\n    getDataURL (options) {\n      return this.delegateMethod('getDataURL', options)\n    },\n    getConnectedDataURL (options) {\n      return this.delegateMethod('getConnectedDataURL', options)\n    },\n    clear () {\n      this.delegateMethod('clear')\n    },\n    dispose () {\n      this.delegateMethod('dispose')\n    },\n    delegateMethod (name, ...args) {\n      if (!this.chart) {\n        this.init()\n      }\n      return this.chart[name](...args)\n    },\n    delegateGet (methodName) {\n      if (!this.chart) {\n        this.init()\n      }\n      return this.chart[methodName]()\n    },\n    getArea () {\n      return this.$el.offsetWidth * this.$el.offsetHeight\n    },\n    init (options) {\n      if (this.chart) {\n        return\n      }\n\n      const chart = echarts.init(this.$el, this.theme, this.initOptions)\n\n      if (this.group) {\n        chart.group = this.group\n      }\n\n      chart.setOption(options || this.manualOptions || this.options || {}, true)\n\n      Object.keys(this.$listeners).forEach(event => {\n        const handler = this.$listeners[event]\n\n        if (event.indexOf('zr:') === 0) {\n          chart.getZr().on(event.slice(3), handler)\n        } else {\n          chart.on(event, handler)\n        }\n      })\n\n      if (this.autoresize) {\n        this.lastArea = this.getArea()\n        this.__resizeHandler = debounce(\n          () => {\n            if (this.lastArea === 0) {\n              // emulate initial render for initially hidden charts\n              this.mergeOptions({}, true)\n              this.resize()\n              this.mergeOptions(this.options || this.manualOptions || {}, true)\n            } else {\n              this.resize()\n            }\n            this.lastArea = this.getArea()\n          },\n          100,\n          { leading: true }\n        )\n        addListener(this.$el, this.__resizeHandler)\n      }\n\n      Object.defineProperties(this, {\n        // Only recalculated when accessed from JavaScript.\n        // Won't update DOM on value change because getters\n        // don't depend on reactive values\n        width: {\n          configurable: true,\n          get: () => {\n            return this.delegateGet('getWidth')\n          }\n        },\n        height: {\n          configurable: true,\n          get: () => {\n            return this.delegateGet('getHeight')\n          }\n        },\n        isDisposed: {\n          configurable: true,\n          get: () => {\n            return !!this.delegateGet('isDisposed')\n          }\n        },\n        computedOptions: {\n          configurable: true,\n          get: () => {\n            return this.delegateGet('getOption')\n          }\n        }\n      })\n\n      this.chart = chart\n    },\n    initOptionsWatcher () {\n      if (this.__unwatchOptions) {\n        this.__unwatchOptions()\n        this.__unwatchOptions = null\n      }\n\n      if (!this.manualUpdate) {\n        this.__unwatchOptions = this.$watch(\n          'options',\n          (val, oldVal) => {\n            if (!this.chart && val) {\n              this.init()\n            } else {\n              // mutating `options` will lead to merging\n              // replacing it with new reference will lead to not merging\n              // eg.\n              // `this.options = Object.assign({}, this.options, { ... })`\n              // will trigger `this.chart.setOption(val, true)\n              // `this.options.title.text = 'Trends'`\n              // will trigger `this.chart.setOption(val, false)`\n              this.chart.setOption(val, val !== oldVal)\n            }\n          },\n          { deep: !this.watchShallow }\n        )\n      }\n    },\n    destroy () {\n      if (this.autoresize) {\n        removeListener(this.$el, this.__resizeHandler)\n      }\n      this.dispose()\n      this.chart = null\n    },\n    refresh () {\n      if (this.chart) {\n        this.destroy()\n        this.init()\n      }\n    }\n  },\n  created () {\n    this.initOptionsWatcher()\n\n    INIT_TRIGGERS.forEach(prop => {\n      this.$watch(\n        prop,\n        () => {\n          this.refresh()\n        },\n        { deep: true }\n      )\n    })\n\n    REWATCH_TRIGGERS.forEach(prop => {\n      this.$watch(prop, () => {\n        this.initOptionsWatcher()\n        this.refresh()\n      })\n    })\n  },\n  mounted () {\n    // auto init if `options` is already provided\n    if (this.options) {\n      this.init()\n    }\n  },\n  activated () {\n    if (this.autoresize) {\n      this.chart && this.chart.resize()\n    }\n  },\n  destroyed () {\n    if (this.chart) {\n      this.destroy()\n    }\n  },\n  connect (group) {\n    if (typeof group !== 'string') {\n      group = group.map(chart => chart.chart)\n    }\n    echarts.connect(group)\n  },\n  disconnect (group) {\n    echarts.disConnect(group)\n  },\n  registerMap (mapName, geoJSON, specialAreas) {\n    echarts.registerMap(mapName, geoJSON, specialAreas)\n  },\n  registerTheme (name, theme) {\n    echarts.registerTheme(name, theme)\n  },\n  graphic: echarts.graphic\n}\n</script>\n"]},"metadata":{},"sourceType":"module"}