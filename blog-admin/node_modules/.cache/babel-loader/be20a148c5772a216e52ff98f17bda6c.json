{"ast":null,"code":"import * as _ from 'lodash-es';\nexport { crossCount };\n/*\n * A function that takes a layering (an array of layers, each with an array of\n * ordererd nodes) and a graph and returns a weighted crossing count.\n *\n * Pre-conditions:\n *\n *    1. Input graph must be simple (not a multigraph), directed, and include\n *       only simple edges.\n *    2. Edges in the input graph must have assigned weights.\n *\n * Post-conditions:\n *\n *    1. The graph and layering matrix are left unchanged.\n *\n * This algorithm is derived from Barth, et al., \"Bilayer Cross Counting.\"\n */\n\nfunction crossCount(g, layering) {\n  var cc = 0;\n\n  for (var i = 1; i < layering.length; ++i) {\n    cc += twoLayerCrossCount(g, layering[i - 1], layering[i]);\n  }\n\n  return cc;\n}\n\nfunction twoLayerCrossCount(g, northLayer, southLayer) {\n  // Sort all of the edges between the north and south layers by their position\n  // in the north layer and then the south. Map these edges to the position of\n  // their head in the south layer.\n  var southPos = _.zipObject(southLayer, _.map(southLayer, function (v, i) {\n    return i;\n  }));\n\n  var southEntries = _.flatten(_.map(northLayer, function (v) {\n    return _.sortBy(_.map(g.outEdges(v), function (e) {\n      return {\n        pos: southPos[e.w],\n        weight: g.edge(e).weight\n      };\n    }), 'pos');\n  })); // Build the accumulator tree\n\n\n  var firstIndex = 1;\n\n  while (firstIndex < southLayer.length) firstIndex <<= 1;\n\n  var treeSize = 2 * firstIndex - 1;\n  firstIndex -= 1;\n\n  var tree = _.map(new Array(treeSize), function () {\n    return 0;\n  }); // Calculate the weighted crossings\n\n\n  var cc = 0;\n\n  _.forEach( // @ts-expect-error\n  southEntries.forEach(function (entry) {\n    var index = entry.pos + firstIndex;\n    tree[index] += entry.weight;\n    var weightSum = 0; // @ts-expect-error\n\n    while (index > 0) {\n      // @ts-expect-error\n      if (index % 2) {\n        weightSum += tree[index + 1];\n      } // @ts-expect-error\n\n\n      index = index - 1 >> 1;\n      tree[index] += entry.weight;\n    }\n\n    cc += entry.weight * weightSum;\n  }));\n\n  return cc;\n}","map":{"version":3,"names":["_","crossCount","g","layering","cc","i","length","twoLayerCrossCount","northLayer","southLayer","southPos","zipObject","map","v","southEntries","flatten","sortBy","outEdges","e","pos","w","weight","edge","firstIndex","treeSize","tree","Array","forEach","entry","index","weightSum"],"sources":["/Users/lord/Documents/Programmer/vue/VueProjects/blog-vue/blog-admin/node_modules/dagre-d3-es/src/dagre/order/cross-count.js"],"sourcesContent":["import * as _ from 'lodash-es';\n\nexport { crossCount };\n\n/*\n * A function that takes a layering (an array of layers, each with an array of\n * ordererd nodes) and a graph and returns a weighted crossing count.\n *\n * Pre-conditions:\n *\n *    1. Input graph must be simple (not a multigraph), directed, and include\n *       only simple edges.\n *    2. Edges in the input graph must have assigned weights.\n *\n * Post-conditions:\n *\n *    1. The graph and layering matrix are left unchanged.\n *\n * This algorithm is derived from Barth, et al., \"Bilayer Cross Counting.\"\n */\nfunction crossCount(g, layering) {\n  var cc = 0;\n  for (var i = 1; i < layering.length; ++i) {\n    cc += twoLayerCrossCount(g, layering[i - 1], layering[i]);\n  }\n  return cc;\n}\n\nfunction twoLayerCrossCount(g, northLayer, southLayer) {\n  // Sort all of the edges between the north and south layers by their position\n  // in the north layer and then the south. Map these edges to the position of\n  // their head in the south layer.\n  var southPos = _.zipObject(\n    southLayer,\n    _.map(southLayer, function (v, i) {\n      return i;\n    })\n  );\n  var southEntries = _.flatten(\n    _.map(northLayer, function (v) {\n      return _.sortBy(\n        _.map(g.outEdges(v), function (e) {\n          return { pos: southPos[e.w], weight: g.edge(e).weight };\n        }),\n        'pos'\n      );\n    })\n  );\n\n  // Build the accumulator tree\n  var firstIndex = 1;\n  while (firstIndex < southLayer.length) firstIndex <<= 1;\n  var treeSize = 2 * firstIndex - 1;\n  firstIndex -= 1;\n  var tree = _.map(new Array(treeSize), function () {\n    return 0;\n  });\n\n  // Calculate the weighted crossings\n  var cc = 0;\n  _.forEach(\n    // @ts-expect-error\n    southEntries.forEach(function (entry) {\n      var index = entry.pos + firstIndex;\n      tree[index] += entry.weight;\n      var weightSum = 0;\n      // @ts-expect-error\n      while (index > 0) {\n        // @ts-expect-error\n        if (index % 2) {\n          weightSum += tree[index + 1];\n        }\n        // @ts-expect-error\n        index = (index - 1) >> 1;\n        tree[index] += entry.weight;\n      }\n      cc += entry.weight * weightSum;\n    })\n  );\n\n  return cc;\n}\n"],"mappings":"AAAA,OAAO,KAAKA,CAAZ,MAAmB,WAAnB;AAEA,SAASC,UAAT;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASA,UAAT,CAAoBC,CAApB,EAAuBC,QAAvB,EAAiC;EAC/B,IAAIC,EAAE,GAAG,CAAT;;EACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,QAAQ,CAACG,MAA7B,EAAqC,EAAED,CAAvC,EAA0C;IACxCD,EAAE,IAAIG,kBAAkB,CAACL,CAAD,EAAIC,QAAQ,CAACE,CAAC,GAAG,CAAL,CAAZ,EAAqBF,QAAQ,CAACE,CAAD,CAA7B,CAAxB;EACD;;EACD,OAAOD,EAAP;AACD;;AAED,SAASG,kBAAT,CAA4BL,CAA5B,EAA+BM,UAA/B,EAA2CC,UAA3C,EAAuD;EACrD;EACA;EACA;EACA,IAAIC,QAAQ,GAAGV,CAAC,CAACW,SAAF,CACbF,UADa,EAEbT,CAAC,CAACY,GAAF,CAAMH,UAAN,EAAkB,UAAUI,CAAV,EAAaR,CAAb,EAAgB;IAChC,OAAOA,CAAP;EACD,CAFD,CAFa,CAAf;;EAMA,IAAIS,YAAY,GAAGd,CAAC,CAACe,OAAF,CACjBf,CAAC,CAACY,GAAF,CAAMJ,UAAN,EAAkB,UAAUK,CAAV,EAAa;IAC7B,OAAOb,CAAC,CAACgB,MAAF,CACLhB,CAAC,CAACY,GAAF,CAAMV,CAAC,CAACe,QAAF,CAAWJ,CAAX,CAAN,EAAqB,UAAUK,CAAV,EAAa;MAChC,OAAO;QAAEC,GAAG,EAAET,QAAQ,CAACQ,CAAC,CAACE,CAAH,CAAf;QAAsBC,MAAM,EAAEnB,CAAC,CAACoB,IAAF,CAAOJ,CAAP,EAAUG;MAAxC,CAAP;IACD,CAFD,CADK,EAIL,KAJK,CAAP;EAMD,CAPD,CADiB,CAAnB,CAVqD,CAqBrD;;;EACA,IAAIE,UAAU,GAAG,CAAjB;;EACA,OAAOA,UAAU,GAAGd,UAAU,CAACH,MAA/B,EAAuCiB,UAAU,KAAK,CAAf;;EACvC,IAAIC,QAAQ,GAAG,IAAID,UAAJ,GAAiB,CAAhC;EACAA,UAAU,IAAI,CAAd;;EACA,IAAIE,IAAI,GAAGzB,CAAC,CAACY,GAAF,CAAM,IAAIc,KAAJ,CAAUF,QAAV,CAAN,EAA2B,YAAY;IAChD,OAAO,CAAP;EACD,CAFU,CAAX,CA1BqD,CA8BrD;;;EACA,IAAIpB,EAAE,GAAG,CAAT;;EACAJ,CAAC,CAAC2B,OAAF,EACE;EACAb,YAAY,CAACa,OAAb,CAAqB,UAAUC,KAAV,EAAiB;IACpC,IAAIC,KAAK,GAAGD,KAAK,CAACT,GAAN,GAAYI,UAAxB;IACAE,IAAI,CAACI,KAAD,CAAJ,IAAeD,KAAK,CAACP,MAArB;IACA,IAAIS,SAAS,GAAG,CAAhB,CAHoC,CAIpC;;IACA,OAAOD,KAAK,GAAG,CAAf,EAAkB;MAChB;MACA,IAAIA,KAAK,GAAG,CAAZ,EAAe;QACbC,SAAS,IAAIL,IAAI,CAACI,KAAK,GAAG,CAAT,CAAjB;MACD,CAJe,CAKhB;;;MACAA,KAAK,GAAIA,KAAK,GAAG,CAAT,IAAe,CAAvB;MACAJ,IAAI,CAACI,KAAD,CAAJ,IAAeD,KAAK,CAACP,MAArB;IACD;;IACDjB,EAAE,IAAIwB,KAAK,CAACP,MAAN,GAAeS,SAArB;EACD,CAfD,CAFF;;EAoBA,OAAO1B,EAAP;AACD"},"metadata":{},"sourceType":"module"}