{"ast":null,"code":"(function webpackUniversalModuleDefinition(root, factory) {\n  if (typeof exports === 'object' && typeof module === 'object') module.exports = factory(require(\"layout-base\"));else if (typeof define === 'function' && define.amd) define([\"layout-base\"], factory);else if (typeof exports === 'object') exports[\"coseBase\"] = factory(require(\"layout-base\"));else root[\"coseBase\"] = factory(root[\"layoutBase\"]);\n})(this, function (__WEBPACK_EXTERNAL_MODULE_0__) {\n  return (\n    /******/\n    function (modules) {\n      // webpackBootstrap\n\n      /******/\n      // The module cache\n\n      /******/\n      var installedModules = {};\n      /******/\n\n      /******/\n      // The require function\n\n      /******/\n\n      function __webpack_require__(moduleId) {\n        /******/\n\n        /******/\n        // Check if module is in cache\n\n        /******/\n        if (installedModules[moduleId]) {\n          /******/\n          return installedModules[moduleId].exports;\n          /******/\n        }\n        /******/\n        // Create a new module (and put it into the cache)\n\n        /******/\n\n\n        var module = installedModules[moduleId] = {\n          /******/\n          i: moduleId,\n\n          /******/\n          l: false,\n\n          /******/\n          exports: {}\n          /******/\n\n        };\n        /******/\n\n        /******/\n        // Execute the module function\n\n        /******/\n\n        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n        /******/\n\n        /******/\n        // Flag the module as loaded\n\n        /******/\n\n        module.l = true;\n        /******/\n\n        /******/\n        // Return the exports of the module\n\n        /******/\n\n        return module.exports;\n        /******/\n      }\n      /******/\n\n      /******/\n\n      /******/\n      // expose the modules object (__webpack_modules__)\n\n      /******/\n\n\n      __webpack_require__.m = modules;\n      /******/\n\n      /******/\n      // expose the module cache\n\n      /******/\n\n      __webpack_require__.c = installedModules;\n      /******/\n\n      /******/\n      // identity function for calling harmony imports with the correct context\n\n      /******/\n\n      __webpack_require__.i = function (value) {\n        return value;\n      };\n      /******/\n\n      /******/\n      // define getter function for harmony exports\n\n      /******/\n\n\n      __webpack_require__.d = function (exports, name, getter) {\n        /******/\n        if (!__webpack_require__.o(exports, name)) {\n          /******/\n          Object.defineProperty(exports, name, {\n            /******/\n            configurable: false,\n\n            /******/\n            enumerable: true,\n\n            /******/\n            get: getter\n            /******/\n\n          });\n          /******/\n        }\n        /******/\n\n      };\n      /******/\n\n      /******/\n      // getDefaultExport function for compatibility with non-harmony modules\n\n      /******/\n\n\n      __webpack_require__.n = function (module) {\n        /******/\n        var getter = module && module.__esModule ?\n        /******/\n        function getDefault() {\n          return module['default'];\n        } :\n        /******/\n        function getModuleExports() {\n          return module;\n        };\n        /******/\n\n        __webpack_require__.d(getter, 'a', getter);\n        /******/\n\n\n        return getter;\n        /******/\n      };\n      /******/\n\n      /******/\n      // Object.prototype.hasOwnProperty.call\n\n      /******/\n\n\n      __webpack_require__.o = function (object, property) {\n        return Object.prototype.hasOwnProperty.call(object, property);\n      };\n      /******/\n\n      /******/\n      // __webpack_public_path__\n\n      /******/\n\n\n      __webpack_require__.p = \"\";\n      /******/\n\n      /******/\n      // Load entry module and return exports\n\n      /******/\n\n      return __webpack_require__(__webpack_require__.s = 7);\n      /******/\n    }\n    /************************************************************************/\n\n    /******/\n    ([\n    /* 0 */\n\n    /***/\n    function (module, exports) {\n      module.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n      /***/\n    },\n    /* 1 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var FDLayoutConstants = __webpack_require__(0).FDLayoutConstants;\n\n      function CoSEConstants() {} //CoSEConstants inherits static props in FDLayoutConstants\n\n\n      for (var prop in FDLayoutConstants) {\n        CoSEConstants[prop] = FDLayoutConstants[prop];\n      }\n\n      CoSEConstants.DEFAULT_USE_MULTI_LEVEL_SCALING = false;\n      CoSEConstants.DEFAULT_RADIAL_SEPARATION = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n      CoSEConstants.DEFAULT_COMPONENT_SEPERATION = 60;\n      CoSEConstants.TILE = true;\n      CoSEConstants.TILING_PADDING_VERTICAL = 10;\n      CoSEConstants.TILING_PADDING_HORIZONTAL = 10;\n      CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = false; // make this true when cose is used incrementally as a part of other non-incremental layout\n\n      module.exports = CoSEConstants;\n      /***/\n    },\n    /* 2 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var FDLayoutEdge = __webpack_require__(0).FDLayoutEdge;\n\n      function CoSEEdge(source, target, vEdge) {\n        FDLayoutEdge.call(this, source, target, vEdge);\n      }\n\n      CoSEEdge.prototype = Object.create(FDLayoutEdge.prototype);\n\n      for (var prop in FDLayoutEdge) {\n        CoSEEdge[prop] = FDLayoutEdge[prop];\n      }\n\n      module.exports = CoSEEdge;\n      /***/\n    },\n    /* 3 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var LGraph = __webpack_require__(0).LGraph;\n\n      function CoSEGraph(parent, graphMgr, vGraph) {\n        LGraph.call(this, parent, graphMgr, vGraph);\n      }\n\n      CoSEGraph.prototype = Object.create(LGraph.prototype);\n\n      for (var prop in LGraph) {\n        CoSEGraph[prop] = LGraph[prop];\n      }\n\n      module.exports = CoSEGraph;\n      /***/\n    },\n    /* 4 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var LGraphManager = __webpack_require__(0).LGraphManager;\n\n      function CoSEGraphManager(layout) {\n        LGraphManager.call(this, layout);\n      }\n\n      CoSEGraphManager.prototype = Object.create(LGraphManager.prototype);\n\n      for (var prop in LGraphManager) {\n        CoSEGraphManager[prop] = LGraphManager[prop];\n      }\n\n      module.exports = CoSEGraphManager;\n      /***/\n    },\n    /* 5 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var FDLayoutNode = __webpack_require__(0).FDLayoutNode;\n\n      var IMath = __webpack_require__(0).IMath;\n\n      function CoSENode(gm, loc, size, vNode) {\n        FDLayoutNode.call(this, gm, loc, size, vNode);\n      }\n\n      CoSENode.prototype = Object.create(FDLayoutNode.prototype);\n\n      for (var prop in FDLayoutNode) {\n        CoSENode[prop] = FDLayoutNode[prop];\n      }\n\n      CoSENode.prototype.move = function () {\n        var layout = this.graphManager.getLayout();\n        this.displacementX = layout.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.noOfChildren;\n        this.displacementY = layout.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.noOfChildren;\n\n        if (Math.abs(this.displacementX) > layout.coolingFactor * layout.maxNodeDisplacement) {\n          this.displacementX = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementX);\n        }\n\n        if (Math.abs(this.displacementY) > layout.coolingFactor * layout.maxNodeDisplacement) {\n          this.displacementY = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementY);\n        } // a simple node, just move it\n\n\n        if (this.child == null) {\n          this.moveBy(this.displacementX, this.displacementY);\n        } // an empty compound node, again just move it\n        else if (this.child.getNodes().length == 0) {\n          this.moveBy(this.displacementX, this.displacementY);\n        } // non-empty compound node, propogate movement to children as well\n        else {\n          this.propogateDisplacementToChildren(this.displacementX, this.displacementY);\n        }\n\n        layout.totalDisplacement += Math.abs(this.displacementX) + Math.abs(this.displacementY);\n        this.springForceX = 0;\n        this.springForceY = 0;\n        this.repulsionForceX = 0;\n        this.repulsionForceY = 0;\n        this.gravitationForceX = 0;\n        this.gravitationForceY = 0;\n        this.displacementX = 0;\n        this.displacementY = 0;\n      };\n\n      CoSENode.prototype.propogateDisplacementToChildren = function (dX, dY) {\n        var nodes = this.getChild().getNodes();\n        var node;\n\n        for (var i = 0; i < nodes.length; i++) {\n          node = nodes[i];\n\n          if (node.getChild() == null) {\n            node.moveBy(dX, dY);\n            node.displacementX += dX;\n            node.displacementY += dY;\n          } else {\n            node.propogateDisplacementToChildren(dX, dY);\n          }\n        }\n      };\n\n      CoSENode.prototype.setPred1 = function (pred1) {\n        this.pred1 = pred1;\n      };\n\n      CoSENode.prototype.getPred1 = function () {\n        return pred1;\n      };\n\n      CoSENode.prototype.getPred2 = function () {\n        return pred2;\n      };\n\n      CoSENode.prototype.setNext = function (next) {\n        this.next = next;\n      };\n\n      CoSENode.prototype.getNext = function () {\n        return next;\n      };\n\n      CoSENode.prototype.setProcessed = function (processed) {\n        this.processed = processed;\n      };\n\n      CoSENode.prototype.isProcessed = function () {\n        return processed;\n      };\n\n      module.exports = CoSENode;\n      /***/\n    },\n    /* 6 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var FDLayout = __webpack_require__(0).FDLayout;\n\n      var CoSEGraphManager = __webpack_require__(4);\n\n      var CoSEGraph = __webpack_require__(3);\n\n      var CoSENode = __webpack_require__(5);\n\n      var CoSEEdge = __webpack_require__(2);\n\n      var CoSEConstants = __webpack_require__(1);\n\n      var FDLayoutConstants = __webpack_require__(0).FDLayoutConstants;\n\n      var LayoutConstants = __webpack_require__(0).LayoutConstants;\n\n      var Point = __webpack_require__(0).Point;\n\n      var PointD = __webpack_require__(0).PointD;\n\n      var Layout = __webpack_require__(0).Layout;\n\n      var Integer = __webpack_require__(0).Integer;\n\n      var IGeometry = __webpack_require__(0).IGeometry;\n\n      var LGraph = __webpack_require__(0).LGraph;\n\n      var Transform = __webpack_require__(0).Transform;\n\n      function CoSELayout() {\n        FDLayout.call(this);\n        this.toBeTiled = {}; // Memorize if a node is to be tiled or is tiled\n      }\n\n      CoSELayout.prototype = Object.create(FDLayout.prototype);\n\n      for (var prop in FDLayout) {\n        CoSELayout[prop] = FDLayout[prop];\n      }\n\n      CoSELayout.prototype.newGraphManager = function () {\n        var gm = new CoSEGraphManager(this);\n        this.graphManager = gm;\n        return gm;\n      };\n\n      CoSELayout.prototype.newGraph = function (vGraph) {\n        return new CoSEGraph(null, this.graphManager, vGraph);\n      };\n\n      CoSELayout.prototype.newNode = function (vNode) {\n        return new CoSENode(this.graphManager, vNode);\n      };\n\n      CoSELayout.prototype.newEdge = function (vEdge) {\n        return new CoSEEdge(null, null, vEdge);\n      };\n\n      CoSELayout.prototype.initParameters = function () {\n        FDLayout.prototype.initParameters.call(this, arguments);\n\n        if (!this.isSubLayout) {\n          if (CoSEConstants.DEFAULT_EDGE_LENGTH < 10) {\n            this.idealEdgeLength = 10;\n          } else {\n            this.idealEdgeLength = CoSEConstants.DEFAULT_EDGE_LENGTH;\n          }\n\n          this.useSmartIdealEdgeLengthCalculation = CoSEConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION;\n          this.springConstant = FDLayoutConstants.DEFAULT_SPRING_STRENGTH;\n          this.repulsionConstant = FDLayoutConstants.DEFAULT_REPULSION_STRENGTH;\n          this.gravityConstant = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH;\n          this.compoundGravityConstant = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH;\n          this.gravityRangeFactor = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR;\n          this.compoundGravityRangeFactor = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR; // variables for tree reduction support\n\n          this.prunedNodesAll = [];\n          this.growTreeIterations = 0;\n          this.afterGrowthIterations = 0;\n          this.isTreeGrowing = false;\n          this.isGrowthFinished = false; // variables for cooling\n\n          this.coolingCycle = 0;\n          this.maxCoolingCycle = this.maxIterations / FDLayoutConstants.CONVERGENCE_CHECK_PERIOD;\n          this.finalTemperature = FDLayoutConstants.CONVERGENCE_CHECK_PERIOD / this.maxIterations;\n          this.coolingAdjuster = 1;\n        }\n      };\n\n      CoSELayout.prototype.layout = function () {\n        var createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n\n        if (createBendsAsNeeded) {\n          this.createBendpoints();\n          this.graphManager.resetAllEdges();\n        }\n\n        this.level = 0;\n        return this.classicLayout();\n      };\n\n      CoSELayout.prototype.classicLayout = function () {\n        this.nodesWithGravity = this.calculateNodesToApplyGravitationTo();\n        this.graphManager.setAllNodesToApplyGravitation(this.nodesWithGravity);\n        this.calcNoOfChildrenForAllNodes();\n        this.graphManager.calcLowestCommonAncestors();\n        this.graphManager.calcInclusionTreeDepths();\n        this.graphManager.getRoot().calcEstimatedSize();\n        this.calcIdealEdgeLengths();\n\n        if (!this.incremental) {\n          var forest = this.getFlatForest(); // The graph associated with this layout is flat and a forest\n\n          if (forest.length > 0) {\n            this.positionNodesRadially(forest);\n          } // The graph associated with this layout is not flat or a forest\n          else {\n            // Reduce the trees when incremental mode is not enabled and graph is not a forest \n            this.reduceTrees(); // Update nodes that gravity will be applied\n\n            this.graphManager.resetAllNodesToApplyGravitation();\n            var allNodes = new Set(this.getAllNodes());\n            var intersection = this.nodesWithGravity.filter(function (x) {\n              return allNodes.has(x);\n            });\n            this.graphManager.setAllNodesToApplyGravitation(intersection);\n            this.positionNodesRandomly();\n          }\n        } else {\n          if (CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL) {\n            // Reduce the trees in incremental mode if only this constant is set to true \n            this.reduceTrees(); // Update nodes that gravity will be applied\n\n            this.graphManager.resetAllNodesToApplyGravitation();\n            var allNodes = new Set(this.getAllNodes());\n            var intersection = this.nodesWithGravity.filter(function (x) {\n              return allNodes.has(x);\n            });\n            this.graphManager.setAllNodesToApplyGravitation(intersection);\n          }\n        }\n\n        this.initSpringEmbedder();\n        this.runSpringEmbedder();\n        return true;\n      };\n\n      CoSELayout.prototype.tick = function () {\n        this.totalIterations++;\n\n        if (this.totalIterations === this.maxIterations && !this.isTreeGrowing && !this.isGrowthFinished) {\n          if (this.prunedNodesAll.length > 0) {\n            this.isTreeGrowing = true;\n          } else {\n            return true;\n          }\n        }\n\n        if (this.totalIterations % FDLayoutConstants.CONVERGENCE_CHECK_PERIOD == 0 && !this.isTreeGrowing && !this.isGrowthFinished) {\n          if (this.isConverged()) {\n            if (this.prunedNodesAll.length > 0) {\n              this.isTreeGrowing = true;\n            } else {\n              return true;\n            }\n          }\n\n          this.coolingCycle++;\n\n          if (this.layoutQuality == 0) {\n            // quality - \"draft\"\n            this.coolingAdjuster = this.coolingCycle;\n          } else if (this.layoutQuality == 1) {\n            // quality - \"default\"\n            this.coolingAdjuster = this.coolingCycle / 3;\n          } // cooling schedule is based on http://www.btluke.com/simanf1.html -> cooling schedule 3\n\n\n          this.coolingFactor = Math.max(this.initialCoolingFactor - Math.pow(this.coolingCycle, Math.log(100 * (this.initialCoolingFactor - this.finalTemperature)) / Math.log(this.maxCoolingCycle)) / 100 * this.coolingAdjuster, this.finalTemperature);\n          this.animationPeriod = Math.ceil(this.initialAnimationPeriod * Math.sqrt(this.coolingFactor));\n        } // Operations while tree is growing again \n\n\n        if (this.isTreeGrowing) {\n          if (this.growTreeIterations % 10 == 0) {\n            if (this.prunedNodesAll.length > 0) {\n              this.graphManager.updateBounds();\n              this.updateGrid();\n              this.growTree(this.prunedNodesAll); // Update nodes that gravity will be applied\n\n              this.graphManager.resetAllNodesToApplyGravitation();\n              var allNodes = new Set(this.getAllNodes());\n              var intersection = this.nodesWithGravity.filter(function (x) {\n                return allNodes.has(x);\n              });\n              this.graphManager.setAllNodesToApplyGravitation(intersection);\n              this.graphManager.updateBounds();\n              this.updateGrid();\n              this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n            } else {\n              this.isTreeGrowing = false;\n              this.isGrowthFinished = true;\n            }\n          }\n\n          this.growTreeIterations++;\n        } // Operations after growth is finished\n\n\n        if (this.isGrowthFinished) {\n          if (this.isConverged()) {\n            return true;\n          }\n\n          if (this.afterGrowthIterations % 10 == 0) {\n            this.graphManager.updateBounds();\n            this.updateGrid();\n          }\n\n          this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL * ((100 - this.afterGrowthIterations) / 100);\n          this.afterGrowthIterations++;\n        }\n\n        var gridUpdateAllowed = !this.isTreeGrowing && !this.isGrowthFinished;\n        var forceToNodeSurroundingUpdate = this.growTreeIterations % 10 == 1 && this.isTreeGrowing || this.afterGrowthIterations % 10 == 1 && this.isGrowthFinished;\n        this.totalDisplacement = 0;\n        this.graphManager.updateBounds();\n        this.calcSpringForces();\n        this.calcRepulsionForces(gridUpdateAllowed, forceToNodeSurroundingUpdate);\n        this.calcGravitationalForces();\n        this.moveNodes();\n        this.animate();\n        return false; // Layout is not ended yet return false\n      };\n\n      CoSELayout.prototype.getPositionsData = function () {\n        var allNodes = this.graphManager.getAllNodes();\n        var pData = {};\n\n        for (var i = 0; i < allNodes.length; i++) {\n          var rect = allNodes[i].rect;\n          var id = allNodes[i].id;\n          pData[id] = {\n            id: id,\n            x: rect.getCenterX(),\n            y: rect.getCenterY(),\n            w: rect.width,\n            h: rect.height\n          };\n        }\n\n        return pData;\n      };\n\n      CoSELayout.prototype.runSpringEmbedder = function () {\n        this.initialAnimationPeriod = 25;\n        this.animationPeriod = this.initialAnimationPeriod;\n        var layoutEnded = false; // If aminate option is 'during' signal that layout is supposed to start iterating\n\n        if (FDLayoutConstants.ANIMATE === 'during') {\n          this.emit('layoutstarted');\n        } else {\n          // If aminate option is 'during' tick() function will be called on index.js\n          while (!layoutEnded) {\n            layoutEnded = this.tick();\n          }\n\n          this.graphManager.updateBounds();\n        }\n      };\n\n      CoSELayout.prototype.calculateNodesToApplyGravitationTo = function () {\n        var nodeList = [];\n        var graph;\n        var graphs = this.graphManager.getGraphs();\n        var size = graphs.length;\n        var i;\n\n        for (i = 0; i < size; i++) {\n          graph = graphs[i];\n          graph.updateConnected();\n\n          if (!graph.isConnected) {\n            nodeList = nodeList.concat(graph.getNodes());\n          }\n        }\n\n        return nodeList;\n      };\n\n      CoSELayout.prototype.createBendpoints = function () {\n        var edges = [];\n        edges = edges.concat(this.graphManager.getAllEdges());\n        var visited = new Set();\n        var i;\n\n        for (i = 0; i < edges.length; i++) {\n          var edge = edges[i];\n\n          if (!visited.has(edge)) {\n            var source = edge.getSource();\n            var target = edge.getTarget();\n\n            if (source == target) {\n              edge.getBendpoints().push(new PointD());\n              edge.getBendpoints().push(new PointD());\n              this.createDummyNodesForBendpoints(edge);\n              visited.add(edge);\n            } else {\n              var edgeList = [];\n              edgeList = edgeList.concat(source.getEdgeListToNode(target));\n              edgeList = edgeList.concat(target.getEdgeListToNode(source));\n\n              if (!visited.has(edgeList[0])) {\n                if (edgeList.length > 1) {\n                  var k;\n\n                  for (k = 0; k < edgeList.length; k++) {\n                    var multiEdge = edgeList[k];\n                    multiEdge.getBendpoints().push(new PointD());\n                    this.createDummyNodesForBendpoints(multiEdge);\n                  }\n                }\n\n                edgeList.forEach(function (edge) {\n                  visited.add(edge);\n                });\n              }\n            }\n          }\n\n          if (visited.size == edges.length) {\n            break;\n          }\n        }\n      };\n\n      CoSELayout.prototype.positionNodesRadially = function (forest) {\n        // We tile the trees to a grid row by row; first tree starts at (0,0)\n        var currentStartingPoint = new Point(0, 0);\n        var numberOfColumns = Math.ceil(Math.sqrt(forest.length));\n        var height = 0;\n        var currentY = 0;\n        var currentX = 0;\n        var point = new PointD(0, 0);\n\n        for (var i = 0; i < forest.length; i++) {\n          if (i % numberOfColumns == 0) {\n            // Start of a new row, make the x coordinate 0, increment the\n            // y coordinate with the max height of the previous row\n            currentX = 0;\n            currentY = height;\n\n            if (i != 0) {\n              currentY += CoSEConstants.DEFAULT_COMPONENT_SEPERATION;\n            }\n\n            height = 0;\n          }\n\n          var tree = forest[i]; // Find the center of the tree\n\n          var centerNode = Layout.findCenterOfTree(tree); // Set the staring point of the next tree\n\n          currentStartingPoint.x = currentX;\n          currentStartingPoint.y = currentY; // Do a radial layout starting with the center\n\n          point = CoSELayout.radialLayout(tree, centerNode, currentStartingPoint);\n\n          if (point.y > height) {\n            height = Math.floor(point.y);\n          }\n\n          currentX = Math.floor(point.x + CoSEConstants.DEFAULT_COMPONENT_SEPERATION);\n        }\n\n        this.transform(new PointD(LayoutConstants.WORLD_CENTER_X - point.x / 2, LayoutConstants.WORLD_CENTER_Y - point.y / 2));\n      };\n\n      CoSELayout.radialLayout = function (tree, centerNode, startingPoint) {\n        var radialSep = Math.max(this.maxDiagonalInTree(tree), CoSEConstants.DEFAULT_RADIAL_SEPARATION);\n        CoSELayout.branchRadialLayout(centerNode, null, 0, 359, 0, radialSep);\n        var bounds = LGraph.calculateBounds(tree);\n        var transform = new Transform();\n        transform.setDeviceOrgX(bounds.getMinX());\n        transform.setDeviceOrgY(bounds.getMinY());\n        transform.setWorldOrgX(startingPoint.x);\n        transform.setWorldOrgY(startingPoint.y);\n\n        for (var i = 0; i < tree.length; i++) {\n          var node = tree[i];\n          node.transform(transform);\n        }\n\n        var bottomRight = new PointD(bounds.getMaxX(), bounds.getMaxY());\n        return transform.inverseTransformPoint(bottomRight);\n      };\n\n      CoSELayout.branchRadialLayout = function (node, parentOfNode, startAngle, endAngle, distance, radialSeparation) {\n        // First, position this node by finding its angle.\n        var halfInterval = (endAngle - startAngle + 1) / 2;\n\n        if (halfInterval < 0) {\n          halfInterval += 180;\n        }\n\n        var nodeAngle = (halfInterval + startAngle) % 360;\n        var teta = nodeAngle * IGeometry.TWO_PI / 360; // Make polar to java cordinate conversion.\n\n        var cos_teta = Math.cos(teta);\n        var x_ = distance * Math.cos(teta);\n        var y_ = distance * Math.sin(teta);\n        node.setCenter(x_, y_); // Traverse all neighbors of this node and recursively call this\n        // function.\n\n        var neighborEdges = [];\n        neighborEdges = neighborEdges.concat(node.getEdges());\n        var childCount = neighborEdges.length;\n\n        if (parentOfNode != null) {\n          childCount--;\n        }\n\n        var branchCount = 0;\n        var incEdgesCount = neighborEdges.length;\n        var startIndex;\n        var edges = node.getEdgesBetween(parentOfNode); // If there are multiple edges, prune them until there remains only one\n        // edge.\n\n        while (edges.length > 1) {\n          //neighborEdges.remove(edges.remove(0));\n          var temp = edges[0];\n          edges.splice(0, 1);\n          var index = neighborEdges.indexOf(temp);\n\n          if (index >= 0) {\n            neighborEdges.splice(index, 1);\n          }\n\n          incEdgesCount--;\n          childCount--;\n        }\n\n        if (parentOfNode != null) {\n          //assert edges.length == 1;\n          startIndex = (neighborEdges.indexOf(edges[0]) + 1) % incEdgesCount;\n        } else {\n          startIndex = 0;\n        }\n\n        var stepAngle = Math.abs(endAngle - startAngle) / childCount;\n\n        for (var i = startIndex; branchCount != childCount; i = ++i % incEdgesCount) {\n          var currentNeighbor = neighborEdges[i].getOtherEnd(node); // Don't back traverse to root node in current tree.\n\n          if (currentNeighbor == parentOfNode) {\n            continue;\n          }\n\n          var childStartAngle = (startAngle + branchCount * stepAngle) % 360;\n          var childEndAngle = (childStartAngle + stepAngle) % 360;\n          CoSELayout.branchRadialLayout(currentNeighbor, node, childStartAngle, childEndAngle, distance + radialSeparation, radialSeparation);\n          branchCount++;\n        }\n      };\n\n      CoSELayout.maxDiagonalInTree = function (tree) {\n        var maxDiagonal = Integer.MIN_VALUE;\n\n        for (var i = 0; i < tree.length; i++) {\n          var node = tree[i];\n          var diagonal = node.getDiagonal();\n\n          if (diagonal > maxDiagonal) {\n            maxDiagonal = diagonal;\n          }\n        }\n\n        return maxDiagonal;\n      };\n\n      CoSELayout.prototype.calcRepulsionRange = function () {\n        // formula is 2 x (level + 1) x idealEdgeLength\n        return 2 * (this.level + 1) * this.idealEdgeLength;\n      }; // Tiling methods\n      // Group zero degree members whose parents are not to be tiled, create dummy parents where needed and fill memberGroups by their dummp parent id's\n\n\n      CoSELayout.prototype.groupZeroDegreeMembers = function () {\n        var self = this; // array of [parent_id x oneDegreeNode_id]\n\n        var tempMemberGroups = {}; // A temporary map of parent node and its zero degree members\n\n        this.memberGroups = {}; // A map of dummy parent node and its zero degree members whose parents are not to be tiled\n\n        this.idToDummyNode = {}; // A map of id to dummy node \n\n        var zeroDegree = []; // List of zero degree nodes whose parents are not to be tiled\n\n        var allNodes = this.graphManager.getAllNodes(); // Fill zero degree list\n\n        for (var i = 0; i < allNodes.length; i++) {\n          var node = allNodes[i];\n          var parent = node.getParent(); // If a node has zero degree and its parent is not to be tiled if exists add that node to zeroDegres list\n\n          if (this.getNodeDegreeWithChildren(node) === 0 && (parent.id == undefined || !this.getToBeTiled(parent))) {\n            zeroDegree.push(node);\n          }\n        } // Create a map of parent node and its zero degree members\n\n\n        for (var i = 0; i < zeroDegree.length; i++) {\n          var node = zeroDegree[i]; // Zero degree node itself\n\n          var p_id = node.getParent().id; // Parent id\n\n          if (typeof tempMemberGroups[p_id] === \"undefined\") tempMemberGroups[p_id] = [];\n          tempMemberGroups[p_id] = tempMemberGroups[p_id].concat(node); // Push node to the list belongs to its parent in tempMemberGroups\n        } // If there are at least two nodes at a level, create a dummy compound for them\n\n\n        Object.keys(tempMemberGroups).forEach(function (p_id) {\n          if (tempMemberGroups[p_id].length > 1) {\n            var dummyCompoundId = \"DummyCompound_\" + p_id; // The id of dummy compound which will be created soon\n\n            self.memberGroups[dummyCompoundId] = tempMemberGroups[p_id]; // Add dummy compound to memberGroups\n\n            var parent = tempMemberGroups[p_id][0].getParent(); // The parent of zero degree nodes will be the parent of new dummy compound\n            // Create a dummy compound with calculated id\n\n            var dummyCompound = new CoSENode(self.graphManager);\n            dummyCompound.id = dummyCompoundId;\n            dummyCompound.paddingLeft = parent.paddingLeft || 0;\n            dummyCompound.paddingRight = parent.paddingRight || 0;\n            dummyCompound.paddingBottom = parent.paddingBottom || 0;\n            dummyCompound.paddingTop = parent.paddingTop || 0;\n            self.idToDummyNode[dummyCompoundId] = dummyCompound;\n            var dummyParentGraph = self.getGraphManager().add(self.newGraph(), dummyCompound);\n            var parentGraph = parent.getChild(); // Add dummy compound to parent the graph\n\n            parentGraph.add(dummyCompound); // For each zero degree node in this level remove it from its parent graph and add it to the graph of dummy parent\n\n            for (var i = 0; i < tempMemberGroups[p_id].length; i++) {\n              var node = tempMemberGroups[p_id][i];\n              parentGraph.remove(node);\n              dummyParentGraph.add(node);\n            }\n          }\n        });\n      };\n\n      CoSELayout.prototype.clearCompounds = function () {\n        var childGraphMap = {};\n        var idToNode = {}; // Get compound ordering by finding the inner one first\n\n        this.performDFSOnCompounds();\n\n        for (var i = 0; i < this.compoundOrder.length; i++) {\n          idToNode[this.compoundOrder[i].id] = this.compoundOrder[i];\n          childGraphMap[this.compoundOrder[i].id] = [].concat(this.compoundOrder[i].getChild().getNodes()); // Remove children of compounds\n\n          this.graphManager.remove(this.compoundOrder[i].getChild());\n          this.compoundOrder[i].child = null;\n        }\n\n        this.graphManager.resetAllNodes(); // Tile the removed children\n\n        this.tileCompoundMembers(childGraphMap, idToNode);\n      };\n\n      CoSELayout.prototype.clearZeroDegreeMembers = function () {\n        var self = this;\n        var tiledZeroDegreePack = this.tiledZeroDegreePack = [];\n        Object.keys(this.memberGroups).forEach(function (id) {\n          var compoundNode = self.idToDummyNode[id]; // Get the dummy compound\n\n          tiledZeroDegreePack[id] = self.tileNodes(self.memberGroups[id], compoundNode.paddingLeft + compoundNode.paddingRight); // Set the width and height of the dummy compound as calculated\n\n          compoundNode.rect.width = tiledZeroDegreePack[id].width;\n          compoundNode.rect.height = tiledZeroDegreePack[id].height;\n        });\n      };\n\n      CoSELayout.prototype.repopulateCompounds = function () {\n        for (var i = this.compoundOrder.length - 1; i >= 0; i--) {\n          var lCompoundNode = this.compoundOrder[i];\n          var id = lCompoundNode.id;\n          var horizontalMargin = lCompoundNode.paddingLeft;\n          var verticalMargin = lCompoundNode.paddingTop;\n          this.adjustLocations(this.tiledMemberPack[id], lCompoundNode.rect.x, lCompoundNode.rect.y, horizontalMargin, verticalMargin);\n        }\n      };\n\n      CoSELayout.prototype.repopulateZeroDegreeMembers = function () {\n        var self = this;\n        var tiledPack = this.tiledZeroDegreePack;\n        Object.keys(tiledPack).forEach(function (id) {\n          var compoundNode = self.idToDummyNode[id]; // Get the dummy compound by its id\n\n          var horizontalMargin = compoundNode.paddingLeft;\n          var verticalMargin = compoundNode.paddingTop; // Adjust the positions of nodes wrt its compound\n\n          self.adjustLocations(tiledPack[id], compoundNode.rect.x, compoundNode.rect.y, horizontalMargin, verticalMargin);\n        });\n      };\n\n      CoSELayout.prototype.getToBeTiled = function (node) {\n        var id = node.id; //firstly check the previous results\n\n        if (this.toBeTiled[id] != null) {\n          return this.toBeTiled[id];\n        } //only compound nodes are to be tiled\n\n\n        var childGraph = node.getChild();\n\n        if (childGraph == null) {\n          this.toBeTiled[id] = false;\n          return false;\n        }\n\n        var children = childGraph.getNodes(); // Get the children nodes\n        //a compound node is not to be tiled if all of its compound children are not to be tiled\n\n        for (var i = 0; i < children.length; i++) {\n          var theChild = children[i];\n\n          if (this.getNodeDegree(theChild) > 0) {\n            this.toBeTiled[id] = false;\n            return false;\n          } //pass the children not having the compound structure\n\n\n          if (theChild.getChild() == null) {\n            this.toBeTiled[theChild.id] = false;\n            continue;\n          }\n\n          if (!this.getToBeTiled(theChild)) {\n            this.toBeTiled[id] = false;\n            return false;\n          }\n        }\n\n        this.toBeTiled[id] = true;\n        return true;\n      }; // Get degree of a node depending of its edges and independent of its children\n\n\n      CoSELayout.prototype.getNodeDegree = function (node) {\n        var id = node.id;\n        var edges = node.getEdges();\n        var degree = 0; // For the edges connected\n\n        for (var i = 0; i < edges.length; i++) {\n          var edge = edges[i];\n\n          if (edge.getSource().id !== edge.getTarget().id) {\n            degree = degree + 1;\n          }\n        }\n\n        return degree;\n      }; // Get degree of a node with its children\n\n\n      CoSELayout.prototype.getNodeDegreeWithChildren = function (node) {\n        var degree = this.getNodeDegree(node);\n\n        if (node.getChild() == null) {\n          return degree;\n        }\n\n        var children = node.getChild().getNodes();\n\n        for (var i = 0; i < children.length; i++) {\n          var child = children[i];\n          degree += this.getNodeDegreeWithChildren(child);\n        }\n\n        return degree;\n      };\n\n      CoSELayout.prototype.performDFSOnCompounds = function () {\n        this.compoundOrder = [];\n        this.fillCompexOrderByDFS(this.graphManager.getRoot().getNodes());\n      };\n\n      CoSELayout.prototype.fillCompexOrderByDFS = function (children) {\n        for (var i = 0; i < children.length; i++) {\n          var child = children[i];\n\n          if (child.getChild() != null) {\n            this.fillCompexOrderByDFS(child.getChild().getNodes());\n          }\n\n          if (this.getToBeTiled(child)) {\n            this.compoundOrder.push(child);\n          }\n        }\n      };\n      /**\n      * This method places each zero degree member wrt given (x,y) coordinates (top left).\n      */\n\n\n      CoSELayout.prototype.adjustLocations = function (organization, x, y, compoundHorizontalMargin, compoundVerticalMargin) {\n        x += compoundHorizontalMargin;\n        y += compoundVerticalMargin;\n        var left = x;\n\n        for (var i = 0; i < organization.rows.length; i++) {\n          var row = organization.rows[i];\n          x = left;\n          var maxHeight = 0;\n\n          for (var j = 0; j < row.length; j++) {\n            var lnode = row[j];\n            lnode.rect.x = x; // + lnode.rect.width / 2;\n\n            lnode.rect.y = y; // + lnode.rect.height / 2;\n\n            x += lnode.rect.width + organization.horizontalPadding;\n            if (lnode.rect.height > maxHeight) maxHeight = lnode.rect.height;\n          }\n\n          y += maxHeight + organization.verticalPadding;\n        }\n      };\n\n      CoSELayout.prototype.tileCompoundMembers = function (childGraphMap, idToNode) {\n        var self = this;\n        this.tiledMemberPack = [];\n        Object.keys(childGraphMap).forEach(function (id) {\n          // Get the compound node\n          var compoundNode = idToNode[id];\n          self.tiledMemberPack[id] = self.tileNodes(childGraphMap[id], compoundNode.paddingLeft + compoundNode.paddingRight);\n          compoundNode.rect.width = self.tiledMemberPack[id].width;\n          compoundNode.rect.height = self.tiledMemberPack[id].height;\n        });\n      };\n\n      CoSELayout.prototype.tileNodes = function (nodes, minWidth) {\n        var verticalPadding = CoSEConstants.TILING_PADDING_VERTICAL;\n        var horizontalPadding = CoSEConstants.TILING_PADDING_HORIZONTAL;\n        var organization = {\n          rows: [],\n          rowWidth: [],\n          rowHeight: [],\n          width: 0,\n          height: minWidth,\n          // assume minHeight equals to minWidth\n          verticalPadding: verticalPadding,\n          horizontalPadding: horizontalPadding\n        }; // Sort the nodes in ascending order of their areas\n\n        nodes.sort(function (n1, n2) {\n          if (n1.rect.width * n1.rect.height > n2.rect.width * n2.rect.height) return -1;\n          if (n1.rect.width * n1.rect.height < n2.rect.width * n2.rect.height) return 1;\n          return 0;\n        }); // Create the organization -> tile members\n\n        for (var i = 0; i < nodes.length; i++) {\n          var lNode = nodes[i];\n\n          if (organization.rows.length == 0) {\n            this.insertNodeToRow(organization, lNode, 0, minWidth);\n          } else if (this.canAddHorizontal(organization, lNode.rect.width, lNode.rect.height)) {\n            this.insertNodeToRow(organization, lNode, this.getShortestRowIndex(organization), minWidth);\n          } else {\n            this.insertNodeToRow(organization, lNode, organization.rows.length, minWidth);\n          }\n\n          this.shiftToLastRow(organization);\n        }\n\n        return organization;\n      };\n\n      CoSELayout.prototype.insertNodeToRow = function (organization, node, rowIndex, minWidth) {\n        var minCompoundSize = minWidth; // Add new row if needed\n\n        if (rowIndex == organization.rows.length) {\n          var secondDimension = [];\n          organization.rows.push(secondDimension);\n          organization.rowWidth.push(minCompoundSize);\n          organization.rowHeight.push(0);\n        } // Update row width\n\n\n        var w = organization.rowWidth[rowIndex] + node.rect.width;\n\n        if (organization.rows[rowIndex].length > 0) {\n          w += organization.horizontalPadding;\n        }\n\n        organization.rowWidth[rowIndex] = w; // Update compound width\n\n        if (organization.width < w) {\n          organization.width = w;\n        } // Update height\n\n\n        var h = node.rect.height;\n        if (rowIndex > 0) h += organization.verticalPadding;\n        var extraHeight = 0;\n\n        if (h > organization.rowHeight[rowIndex]) {\n          extraHeight = organization.rowHeight[rowIndex];\n          organization.rowHeight[rowIndex] = h;\n          extraHeight = organization.rowHeight[rowIndex] - extraHeight;\n        }\n\n        organization.height += extraHeight; // Insert node\n\n        organization.rows[rowIndex].push(node);\n      }; //Scans the rows of an organization and returns the one with the min width\n\n\n      CoSELayout.prototype.getShortestRowIndex = function (organization) {\n        var r = -1;\n        var min = Number.MAX_VALUE;\n\n        for (var i = 0; i < organization.rows.length; i++) {\n          if (organization.rowWidth[i] < min) {\n            r = i;\n            min = organization.rowWidth[i];\n          }\n        }\n\n        return r;\n      }; //Scans the rows of an organization and returns the one with the max width\n\n\n      CoSELayout.prototype.getLongestRowIndex = function (organization) {\n        var r = -1;\n        var max = Number.MIN_VALUE;\n\n        for (var i = 0; i < organization.rows.length; i++) {\n          if (organization.rowWidth[i] > max) {\n            r = i;\n            max = organization.rowWidth[i];\n          }\n        }\n\n        return r;\n      };\n      /**\n      * This method checks whether adding extra width to the organization violates\n      * the aspect ratio(1) or not.\n      */\n\n\n      CoSELayout.prototype.canAddHorizontal = function (organization, extraWidth, extraHeight) {\n        var sri = this.getShortestRowIndex(organization);\n\n        if (sri < 0) {\n          return true;\n        }\n\n        var min = organization.rowWidth[sri];\n        if (min + organization.horizontalPadding + extraWidth <= organization.width) return true;\n        var hDiff = 0; // Adding to an existing row\n\n        if (organization.rowHeight[sri] < extraHeight) {\n          if (sri > 0) hDiff = extraHeight + organization.verticalPadding - organization.rowHeight[sri];\n        }\n\n        var add_to_row_ratio;\n\n        if (organization.width - min >= extraWidth + organization.horizontalPadding) {\n          add_to_row_ratio = (organization.height + hDiff) / (min + extraWidth + organization.horizontalPadding);\n        } else {\n          add_to_row_ratio = (organization.height + hDiff) / organization.width;\n        } // Adding a new row for this node\n\n\n        hDiff = extraHeight + organization.verticalPadding;\n        var add_new_row_ratio;\n\n        if (organization.width < extraWidth) {\n          add_new_row_ratio = (organization.height + hDiff) / extraWidth;\n        } else {\n          add_new_row_ratio = (organization.height + hDiff) / organization.width;\n        }\n\n        if (add_new_row_ratio < 1) add_new_row_ratio = 1 / add_new_row_ratio;\n        if (add_to_row_ratio < 1) add_to_row_ratio = 1 / add_to_row_ratio;\n        return add_to_row_ratio < add_new_row_ratio;\n      }; //If moving the last node from the longest row and adding it to the last\n      //row makes the bounding box smaller, do it.\n\n\n      CoSELayout.prototype.shiftToLastRow = function (organization) {\n        var longest = this.getLongestRowIndex(organization);\n        var last = organization.rowWidth.length - 1;\n        var row = organization.rows[longest];\n        var node = row[row.length - 1];\n        var diff = node.width + organization.horizontalPadding; // Check if there is enough space on the last row\n\n        if (organization.width - organization.rowWidth[last] > diff && longest != last) {\n          // Remove the last element of the longest row\n          row.splice(-1, 1); // Push it to the last row\n\n          organization.rows[last].push(node);\n          organization.rowWidth[longest] = organization.rowWidth[longest] - diff;\n          organization.rowWidth[last] = organization.rowWidth[last] + diff;\n          organization.width = organization.rowWidth[instance.getLongestRowIndex(organization)]; // Update heights of the organization\n\n          var maxHeight = Number.MIN_VALUE;\n\n          for (var i = 0; i < row.length; i++) {\n            if (row[i].height > maxHeight) maxHeight = row[i].height;\n          }\n\n          if (longest > 0) maxHeight += organization.verticalPadding;\n          var prevTotal = organization.rowHeight[longest] + organization.rowHeight[last];\n          organization.rowHeight[longest] = maxHeight;\n          if (organization.rowHeight[last] < node.height + organization.verticalPadding) organization.rowHeight[last] = node.height + organization.verticalPadding;\n          var finalTotal = organization.rowHeight[longest] + organization.rowHeight[last];\n          organization.height += finalTotal - prevTotal;\n          this.shiftToLastRow(organization);\n        }\n      };\n\n      CoSELayout.prototype.tilingPreLayout = function () {\n        if (CoSEConstants.TILE) {\n          // Find zero degree nodes and create a compound for each level\n          this.groupZeroDegreeMembers(); // Tile and clear children of each compound\n\n          this.clearCompounds(); // Separately tile and clear zero degree nodes for each level\n\n          this.clearZeroDegreeMembers();\n        }\n      };\n\n      CoSELayout.prototype.tilingPostLayout = function () {\n        if (CoSEConstants.TILE) {\n          this.repopulateZeroDegreeMembers();\n          this.repopulateCompounds();\n        }\n      }; // -----------------------------------------------------------------------------\n      // Section: Tree Reduction methods\n      // -----------------------------------------------------------------------------\n      // Reduce trees \n\n\n      CoSELayout.prototype.reduceTrees = function () {\n        var prunedNodesAll = [];\n        var containsLeaf = true;\n        var node;\n\n        while (containsLeaf) {\n          var allNodes = this.graphManager.getAllNodes();\n          var prunedNodesInStepTemp = [];\n          containsLeaf = false;\n\n          for (var i = 0; i < allNodes.length; i++) {\n            node = allNodes[i];\n\n            if (node.getEdges().length == 1 && !node.getEdges()[0].isInterGraph && node.getChild() == null) {\n              prunedNodesInStepTemp.push([node, node.getEdges()[0], node.getOwner()]);\n              containsLeaf = true;\n            }\n          }\n\n          if (containsLeaf == true) {\n            var prunedNodesInStep = [];\n\n            for (var j = 0; j < prunedNodesInStepTemp.length; j++) {\n              if (prunedNodesInStepTemp[j][0].getEdges().length == 1) {\n                prunedNodesInStep.push(prunedNodesInStepTemp[j]);\n                prunedNodesInStepTemp[j][0].getOwner().remove(prunedNodesInStepTemp[j][0]);\n              }\n            }\n\n            prunedNodesAll.push(prunedNodesInStep);\n            this.graphManager.resetAllNodes();\n            this.graphManager.resetAllEdges();\n          }\n        }\n\n        this.prunedNodesAll = prunedNodesAll;\n      }; // Grow tree one step \n\n\n      CoSELayout.prototype.growTree = function (prunedNodesAll) {\n        var lengthOfPrunedNodesInStep = prunedNodesAll.length;\n        var prunedNodesInStep = prunedNodesAll[lengthOfPrunedNodesInStep - 1];\n        var nodeData;\n\n        for (var i = 0; i < prunedNodesInStep.length; i++) {\n          nodeData = prunedNodesInStep[i];\n          this.findPlaceforPrunedNode(nodeData);\n          nodeData[2].add(nodeData[0]);\n          nodeData[2].add(nodeData[1], nodeData[1].source, nodeData[1].target);\n        }\n\n        prunedNodesAll.splice(prunedNodesAll.length - 1, 1);\n        this.graphManager.resetAllNodes();\n        this.graphManager.resetAllEdges();\n      }; // Find an appropriate position to replace pruned node, this method can be improved\n\n\n      CoSELayout.prototype.findPlaceforPrunedNode = function (nodeData) {\n        var gridForPrunedNode;\n        var nodeToConnect;\n        var prunedNode = nodeData[0];\n\n        if (prunedNode == nodeData[1].source) {\n          nodeToConnect = nodeData[1].target;\n        } else {\n          nodeToConnect = nodeData[1].source;\n        }\n\n        var startGridX = nodeToConnect.startX;\n        var finishGridX = nodeToConnect.finishX;\n        var startGridY = nodeToConnect.startY;\n        var finishGridY = nodeToConnect.finishY;\n        var upNodeCount = 0;\n        var downNodeCount = 0;\n        var rightNodeCount = 0;\n        var leftNodeCount = 0;\n        var controlRegions = [upNodeCount, rightNodeCount, downNodeCount, leftNodeCount];\n\n        if (startGridY > 0) {\n          for (var i = startGridX; i <= finishGridX; i++) {\n            controlRegions[0] += this.grid[i][startGridY - 1].length + this.grid[i][startGridY].length - 1;\n          }\n        }\n\n        if (finishGridX < this.grid.length - 1) {\n          for (var i = startGridY; i <= finishGridY; i++) {\n            controlRegions[1] += this.grid[finishGridX + 1][i].length + this.grid[finishGridX][i].length - 1;\n          }\n        }\n\n        if (finishGridY < this.grid[0].length - 1) {\n          for (var i = startGridX; i <= finishGridX; i++) {\n            controlRegions[2] += this.grid[i][finishGridY + 1].length + this.grid[i][finishGridY].length - 1;\n          }\n        }\n\n        if (startGridX > 0) {\n          for (var i = startGridY; i <= finishGridY; i++) {\n            controlRegions[3] += this.grid[startGridX - 1][i].length + this.grid[startGridX][i].length - 1;\n          }\n        }\n\n        var min = Integer.MAX_VALUE;\n        var minCount;\n        var minIndex;\n\n        for (var j = 0; j < controlRegions.length; j++) {\n          if (controlRegions[j] < min) {\n            min = controlRegions[j];\n            minCount = 1;\n            minIndex = j;\n          } else if (controlRegions[j] == min) {\n            minCount++;\n          }\n        }\n\n        if (minCount == 3 && min == 0) {\n          if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[2] == 0) {\n            gridForPrunedNode = 1;\n          } else if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[3] == 0) {\n            gridForPrunedNode = 0;\n          } else if (controlRegions[0] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) {\n            gridForPrunedNode = 3;\n          } else if (controlRegions[1] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) {\n            gridForPrunedNode = 2;\n          }\n        } else if (minCount == 2 && min == 0) {\n          var random = Math.floor(Math.random() * 2);\n\n          if (controlRegions[0] == 0 && controlRegions[1] == 0) {\n            ;\n\n            if (random == 0) {\n              gridForPrunedNode = 0;\n            } else {\n              gridForPrunedNode = 1;\n            }\n          } else if (controlRegions[0] == 0 && controlRegions[2] == 0) {\n            if (random == 0) {\n              gridForPrunedNode = 0;\n            } else {\n              gridForPrunedNode = 2;\n            }\n          } else if (controlRegions[0] == 0 && controlRegions[3] == 0) {\n            if (random == 0) {\n              gridForPrunedNode = 0;\n            } else {\n              gridForPrunedNode = 3;\n            }\n          } else if (controlRegions[1] == 0 && controlRegions[2] == 0) {\n            if (random == 0) {\n              gridForPrunedNode = 1;\n            } else {\n              gridForPrunedNode = 2;\n            }\n          } else if (controlRegions[1] == 0 && controlRegions[3] == 0) {\n            if (random == 0) {\n              gridForPrunedNode = 1;\n            } else {\n              gridForPrunedNode = 3;\n            }\n          } else {\n            if (random == 0) {\n              gridForPrunedNode = 2;\n            } else {\n              gridForPrunedNode = 3;\n            }\n          }\n        } else if (minCount == 4 && min == 0) {\n          var random = Math.floor(Math.random() * 4);\n          gridForPrunedNode = random;\n        } else {\n          gridForPrunedNode = minIndex;\n        }\n\n        if (gridForPrunedNode == 0) {\n          prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() - nodeToConnect.getHeight() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getHeight() / 2);\n        } else if (gridForPrunedNode == 1) {\n          prunedNode.setCenter(nodeToConnect.getCenterX() + nodeToConnect.getWidth() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getWidth() / 2, nodeToConnect.getCenterY());\n        } else if (gridForPrunedNode == 2) {\n          prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() + nodeToConnect.getHeight() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getHeight() / 2);\n        } else {\n          prunedNode.setCenter(nodeToConnect.getCenterX() - nodeToConnect.getWidth() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getWidth() / 2, nodeToConnect.getCenterY());\n        }\n      };\n\n      module.exports = CoSELayout;\n      /***/\n    },\n    /* 7 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var coseBase = {};\n      coseBase.layoutBase = __webpack_require__(0);\n      coseBase.CoSEConstants = __webpack_require__(1);\n      coseBase.CoSEEdge = __webpack_require__(2);\n      coseBase.CoSEGraph = __webpack_require__(3);\n      coseBase.CoSEGraphManager = __webpack_require__(4);\n      coseBase.CoSELayout = __webpack_require__(6);\n      coseBase.CoSENode = __webpack_require__(5);\n      module.exports = coseBase;\n      /***/\n    }\n    /******/\n    ])\n  );\n});","map":null,"metadata":{},"sourceType":"script"}