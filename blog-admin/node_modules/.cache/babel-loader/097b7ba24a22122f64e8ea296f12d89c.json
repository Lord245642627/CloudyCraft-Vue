{"ast":null,"code":"(function webpackUniversalModuleDefinition(root, factory) {\n  if (typeof exports === 'object' && typeof module === 'object') module.exports = factory();else if (typeof define === 'function' && define.amd) define([], factory);else if (typeof exports === 'object') exports[\"layoutBase\"] = factory();else root[\"layoutBase\"] = factory();\n})(this, function () {\n  return (\n    /******/\n    function (modules) {\n      // webpackBootstrap\n\n      /******/\n      // The module cache\n\n      /******/\n      var installedModules = {};\n      /******/\n\n      /******/\n      // The require function\n\n      /******/\n\n      function __webpack_require__(moduleId) {\n        /******/\n\n        /******/\n        // Check if module is in cache\n\n        /******/\n        if (installedModules[moduleId]) {\n          /******/\n          return installedModules[moduleId].exports;\n          /******/\n        }\n        /******/\n        // Create a new module (and put it into the cache)\n\n        /******/\n\n\n        var module = installedModules[moduleId] = {\n          /******/\n          i: moduleId,\n\n          /******/\n          l: false,\n\n          /******/\n          exports: {}\n          /******/\n\n        };\n        /******/\n\n        /******/\n        // Execute the module function\n\n        /******/\n\n        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n        /******/\n\n        /******/\n        // Flag the module as loaded\n\n        /******/\n\n        module.l = true;\n        /******/\n\n        /******/\n        // Return the exports of the module\n\n        /******/\n\n        return module.exports;\n        /******/\n      }\n      /******/\n\n      /******/\n\n      /******/\n      // expose the modules object (__webpack_modules__)\n\n      /******/\n\n\n      __webpack_require__.m = modules;\n      /******/\n\n      /******/\n      // expose the module cache\n\n      /******/\n\n      __webpack_require__.c = installedModules;\n      /******/\n\n      /******/\n      // identity function for calling harmony imports with the correct context\n\n      /******/\n\n      __webpack_require__.i = function (value) {\n        return value;\n      };\n      /******/\n\n      /******/\n      // define getter function for harmony exports\n\n      /******/\n\n\n      __webpack_require__.d = function (exports, name, getter) {\n        /******/\n        if (!__webpack_require__.o(exports, name)) {\n          /******/\n          Object.defineProperty(exports, name, {\n            /******/\n            configurable: false,\n\n            /******/\n            enumerable: true,\n\n            /******/\n            get: getter\n            /******/\n\n          });\n          /******/\n        }\n        /******/\n\n      };\n      /******/\n\n      /******/\n      // getDefaultExport function for compatibility with non-harmony modules\n\n      /******/\n\n\n      __webpack_require__.n = function (module) {\n        /******/\n        var getter = module && module.__esModule ?\n        /******/\n        function getDefault() {\n          return module['default'];\n        } :\n        /******/\n        function getModuleExports() {\n          return module;\n        };\n        /******/\n\n        __webpack_require__.d(getter, 'a', getter);\n        /******/\n\n\n        return getter;\n        /******/\n      };\n      /******/\n\n      /******/\n      // Object.prototype.hasOwnProperty.call\n\n      /******/\n\n\n      __webpack_require__.o = function (object, property) {\n        return Object.prototype.hasOwnProperty.call(object, property);\n      };\n      /******/\n\n      /******/\n      // __webpack_public_path__\n\n      /******/\n\n\n      __webpack_require__.p = \"\";\n      /******/\n\n      /******/\n      // Load entry module and return exports\n\n      /******/\n\n      return __webpack_require__(__webpack_require__.s = 26);\n      /******/\n    }\n    /************************************************************************/\n\n    /******/\n    ([\n    /* 0 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function LayoutConstants() {}\n      /**\r\n       * Layout Quality: 0:draft, 1:default, 2:proof\r\n       */\n\n\n      LayoutConstants.QUALITY = 1;\n      /**\r\n       * Default parameters\r\n       */\n\n      LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED = false;\n      LayoutConstants.DEFAULT_INCREMENTAL = false;\n      LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT = true;\n      LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT = false;\n      LayoutConstants.DEFAULT_ANIMATION_PERIOD = 50;\n      LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES = false; // -----------------------------------------------------------------------------\n      // Section: General other constants\n      // -----------------------------------------------------------------------------\n\n      /*\r\n       * Margins of a graph to be applied on bouding rectangle of its contents. We\r\n       * assume margins on all four sides to be uniform.\r\n       */\n\n      LayoutConstants.DEFAULT_GRAPH_MARGIN = 15;\n      /*\r\n       * Whether to consider labels in node dimensions or not\r\n       */\n\n      LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = false;\n      /*\r\n       * Default dimension of a non-compound node.\r\n       */\n\n      LayoutConstants.SIMPLE_NODE_SIZE = 40;\n      /*\r\n       * Default dimension of a non-compound node.\r\n       */\n\n      LayoutConstants.SIMPLE_NODE_HALF_SIZE = LayoutConstants.SIMPLE_NODE_SIZE / 2;\n      /*\r\n       * Empty compound node size. When a compound node is empty, its both\r\n       * dimensions should be of this value.\r\n       */\n\n      LayoutConstants.EMPTY_COMPOUND_NODE_SIZE = 40;\n      /*\r\n       * Minimum length that an edge should take during layout\r\n       */\n\n      LayoutConstants.MIN_EDGE_LENGTH = 1;\n      /*\r\n       * World boundaries that layout operates on\r\n       */\n\n      LayoutConstants.WORLD_BOUNDARY = 1000000;\n      /*\r\n       * World boundaries that random positioning can be performed with\r\n       */\n\n      LayoutConstants.INITIAL_WORLD_BOUNDARY = LayoutConstants.WORLD_BOUNDARY / 1000;\n      /*\r\n       * Coordinates of the world center\r\n       */\n\n      LayoutConstants.WORLD_CENTER_X = 1200;\n      LayoutConstants.WORLD_CENTER_Y = 900;\n      module.exports = LayoutConstants;\n      /***/\n    },\n    /* 1 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var LGraphObject = __webpack_require__(2);\n\n      var IGeometry = __webpack_require__(8);\n\n      var IMath = __webpack_require__(9);\n\n      function LEdge(source, target, vEdge) {\n        LGraphObject.call(this, vEdge);\n        this.isOverlapingSourceAndTarget = false;\n        this.vGraphObject = vEdge;\n        this.bendpoints = [];\n        this.source = source;\n        this.target = target;\n      }\n\n      LEdge.prototype = Object.create(LGraphObject.prototype);\n\n      for (var prop in LGraphObject) {\n        LEdge[prop] = LGraphObject[prop];\n      }\n\n      LEdge.prototype.getSource = function () {\n        return this.source;\n      };\n\n      LEdge.prototype.getTarget = function () {\n        return this.target;\n      };\n\n      LEdge.prototype.isInterGraph = function () {\n        return this.isInterGraph;\n      };\n\n      LEdge.prototype.getLength = function () {\n        return this.length;\n      };\n\n      LEdge.prototype.isOverlapingSourceAndTarget = function () {\n        return this.isOverlapingSourceAndTarget;\n      };\n\n      LEdge.prototype.getBendpoints = function () {\n        return this.bendpoints;\n      };\n\n      LEdge.prototype.getLca = function () {\n        return this.lca;\n      };\n\n      LEdge.prototype.getSourceInLca = function () {\n        return this.sourceInLca;\n      };\n\n      LEdge.prototype.getTargetInLca = function () {\n        return this.targetInLca;\n      };\n\n      LEdge.prototype.getOtherEnd = function (node) {\n        if (this.source === node) {\n          return this.target;\n        } else if (this.target === node) {\n          return this.source;\n        } else {\n          throw \"Node is not incident with this edge\";\n        }\n      };\n\n      LEdge.prototype.getOtherEndInGraph = function (node, graph) {\n        var otherEnd = this.getOtherEnd(node);\n        var root = graph.getGraphManager().getRoot();\n\n        while (true) {\n          if (otherEnd.getOwner() == graph) {\n            return otherEnd;\n          }\n\n          if (otherEnd.getOwner() == root) {\n            break;\n          }\n\n          otherEnd = otherEnd.getOwner().getParent();\n        }\n\n        return null;\n      };\n\n      LEdge.prototype.updateLength = function () {\n        var clipPointCoordinates = new Array(4);\n        this.isOverlapingSourceAndTarget = IGeometry.getIntersection(this.target.getRect(), this.source.getRect(), clipPointCoordinates);\n\n        if (!this.isOverlapingSourceAndTarget) {\n          this.lengthX = clipPointCoordinates[0] - clipPointCoordinates[2];\n          this.lengthY = clipPointCoordinates[1] - clipPointCoordinates[3];\n\n          if (Math.abs(this.lengthX) < 1.0) {\n            this.lengthX = IMath.sign(this.lengthX);\n          }\n\n          if (Math.abs(this.lengthY) < 1.0) {\n            this.lengthY = IMath.sign(this.lengthY);\n          }\n\n          this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY);\n        }\n      };\n\n      LEdge.prototype.updateLengthSimple = function () {\n        this.lengthX = this.target.getCenterX() - this.source.getCenterX();\n        this.lengthY = this.target.getCenterY() - this.source.getCenterY();\n\n        if (Math.abs(this.lengthX) < 1.0) {\n          this.lengthX = IMath.sign(this.lengthX);\n        }\n\n        if (Math.abs(this.lengthY) < 1.0) {\n          this.lengthY = IMath.sign(this.lengthY);\n        }\n\n        this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY);\n      };\n\n      module.exports = LEdge;\n      /***/\n    },\n    /* 2 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function LGraphObject(vGraphObject) {\n        this.vGraphObject = vGraphObject;\n      }\n\n      module.exports = LGraphObject;\n      /***/\n    },\n    /* 3 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var LGraphObject = __webpack_require__(2);\n\n      var Integer = __webpack_require__(10);\n\n      var RectangleD = __webpack_require__(13);\n\n      var LayoutConstants = __webpack_require__(0);\n\n      var RandomSeed = __webpack_require__(16);\n\n      var PointD = __webpack_require__(4);\n\n      function LNode(gm, loc, size, vNode) {\n        //Alternative constructor 1 : LNode(LGraphManager gm, Point loc, Dimension size, Object vNode)\n        if (size == null && vNode == null) {\n          vNode = loc;\n        }\n\n        LGraphObject.call(this, vNode); //Alternative constructor 2 : LNode(Layout layout, Object vNode)\n\n        if (gm.graphManager != null) gm = gm.graphManager;\n        this.estimatedSize = Integer.MIN_VALUE;\n        this.inclusionTreeDepth = Integer.MAX_VALUE;\n        this.vGraphObject = vNode;\n        this.edges = [];\n        this.graphManager = gm;\n        if (size != null && loc != null) this.rect = new RectangleD(loc.x, loc.y, size.width, size.height);else this.rect = new RectangleD();\n      }\n\n      LNode.prototype = Object.create(LGraphObject.prototype);\n\n      for (var prop in LGraphObject) {\n        LNode[prop] = LGraphObject[prop];\n      }\n\n      LNode.prototype.getEdges = function () {\n        return this.edges;\n      };\n\n      LNode.prototype.getChild = function () {\n        return this.child;\n      };\n\n      LNode.prototype.getOwner = function () {\n        //  if (this.owner != null) {\n        //    if (!(this.owner == null || this.owner.getNodes().indexOf(this) > -1)) {\n        //      throw \"assert failed\";\n        //    }\n        //  }\n        return this.owner;\n      };\n\n      LNode.prototype.getWidth = function () {\n        return this.rect.width;\n      };\n\n      LNode.prototype.setWidth = function (width) {\n        this.rect.width = width;\n      };\n\n      LNode.prototype.getHeight = function () {\n        return this.rect.height;\n      };\n\n      LNode.prototype.setHeight = function (height) {\n        this.rect.height = height;\n      };\n\n      LNode.prototype.getCenterX = function () {\n        return this.rect.x + this.rect.width / 2;\n      };\n\n      LNode.prototype.getCenterY = function () {\n        return this.rect.y + this.rect.height / 2;\n      };\n\n      LNode.prototype.getCenter = function () {\n        return new PointD(this.rect.x + this.rect.width / 2, this.rect.y + this.rect.height / 2);\n      };\n\n      LNode.prototype.getLocation = function () {\n        return new PointD(this.rect.x, this.rect.y);\n      };\n\n      LNode.prototype.getRect = function () {\n        return this.rect;\n      };\n\n      LNode.prototype.getDiagonal = function () {\n        return Math.sqrt(this.rect.width * this.rect.width + this.rect.height * this.rect.height);\n      };\n      /**\n       * This method returns half the diagonal length of this node.\n       */\n\n\n      LNode.prototype.getHalfTheDiagonal = function () {\n        return Math.sqrt(this.rect.height * this.rect.height + this.rect.width * this.rect.width) / 2;\n      };\n\n      LNode.prototype.setRect = function (upperLeft, dimension) {\n        this.rect.x = upperLeft.x;\n        this.rect.y = upperLeft.y;\n        this.rect.width = dimension.width;\n        this.rect.height = dimension.height;\n      };\n\n      LNode.prototype.setCenter = function (cx, cy) {\n        this.rect.x = cx - this.rect.width / 2;\n        this.rect.y = cy - this.rect.height / 2;\n      };\n\n      LNode.prototype.setLocation = function (x, y) {\n        this.rect.x = x;\n        this.rect.y = y;\n      };\n\n      LNode.prototype.moveBy = function (dx, dy) {\n        this.rect.x += dx;\n        this.rect.y += dy;\n      };\n\n      LNode.prototype.getEdgeListToNode = function (to) {\n        var edgeList = [];\n        var edge;\n        var self = this;\n        self.edges.forEach(function (edge) {\n          if (edge.target == to) {\n            if (edge.source != self) throw \"Incorrect edge source!\";\n            edgeList.push(edge);\n          }\n        });\n        return edgeList;\n      };\n\n      LNode.prototype.getEdgesBetween = function (other) {\n        var edgeList = [];\n        var edge;\n        var self = this;\n        self.edges.forEach(function (edge) {\n          if (!(edge.source == self || edge.target == self)) throw \"Incorrect edge source and/or target\";\n\n          if (edge.target == other || edge.source == other) {\n            edgeList.push(edge);\n          }\n        });\n        return edgeList;\n      };\n\n      LNode.prototype.getNeighborsList = function () {\n        var neighbors = new Set();\n        var self = this;\n        self.edges.forEach(function (edge) {\n          if (edge.source == self) {\n            neighbors.add(edge.target);\n          } else {\n            if (edge.target != self) {\n              throw \"Incorrect incidency!\";\n            }\n\n            neighbors.add(edge.source);\n          }\n        });\n        return neighbors;\n      };\n\n      LNode.prototype.withChildren = function () {\n        var withNeighborsList = new Set();\n        var childNode;\n        var children;\n        withNeighborsList.add(this);\n\n        if (this.child != null) {\n          var nodes = this.child.getNodes();\n\n          for (var i = 0; i < nodes.length; i++) {\n            childNode = nodes[i];\n            children = childNode.withChildren();\n            children.forEach(function (node) {\n              withNeighborsList.add(node);\n            });\n          }\n        }\n\n        return withNeighborsList;\n      };\n\n      LNode.prototype.getNoOfChildren = function () {\n        var noOfChildren = 0;\n        var childNode;\n\n        if (this.child == null) {\n          noOfChildren = 1;\n        } else {\n          var nodes = this.child.getNodes();\n\n          for (var i = 0; i < nodes.length; i++) {\n            childNode = nodes[i];\n            noOfChildren += childNode.getNoOfChildren();\n          }\n        }\n\n        if (noOfChildren == 0) {\n          noOfChildren = 1;\n        }\n\n        return noOfChildren;\n      };\n\n      LNode.prototype.getEstimatedSize = function () {\n        if (this.estimatedSize == Integer.MIN_VALUE) {\n          throw \"assert failed\";\n        }\n\n        return this.estimatedSize;\n      };\n\n      LNode.prototype.calcEstimatedSize = function () {\n        if (this.child == null) {\n          return this.estimatedSize = (this.rect.width + this.rect.height) / 2;\n        } else {\n          this.estimatedSize = this.child.calcEstimatedSize();\n          this.rect.width = this.estimatedSize;\n          this.rect.height = this.estimatedSize;\n          return this.estimatedSize;\n        }\n      };\n\n      LNode.prototype.scatter = function () {\n        var randomCenterX;\n        var randomCenterY;\n        var minX = -LayoutConstants.INITIAL_WORLD_BOUNDARY;\n        var maxX = LayoutConstants.INITIAL_WORLD_BOUNDARY;\n        randomCenterX = LayoutConstants.WORLD_CENTER_X + RandomSeed.nextDouble() * (maxX - minX) + minX;\n        var minY = -LayoutConstants.INITIAL_WORLD_BOUNDARY;\n        var maxY = LayoutConstants.INITIAL_WORLD_BOUNDARY;\n        randomCenterY = LayoutConstants.WORLD_CENTER_Y + RandomSeed.nextDouble() * (maxY - minY) + minY;\n        this.rect.x = randomCenterX;\n        this.rect.y = randomCenterY;\n      };\n\n      LNode.prototype.updateBounds = function () {\n        if (this.getChild() == null) {\n          throw \"assert failed\";\n        }\n\n        if (this.getChild().getNodes().length != 0) {\n          // wrap the children nodes by re-arranging the boundaries\n          var childGraph = this.getChild();\n          childGraph.updateBounds(true);\n          this.rect.x = childGraph.getLeft();\n          this.rect.y = childGraph.getTop();\n          this.setWidth(childGraph.getRight() - childGraph.getLeft());\n          this.setHeight(childGraph.getBottom() - childGraph.getTop()); // Update compound bounds considering its label properties    \n\n          if (LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS) {\n            var width = childGraph.getRight() - childGraph.getLeft();\n            var height = childGraph.getBottom() - childGraph.getTop();\n\n            if (this.labelWidth > width) {\n              this.rect.x -= (this.labelWidth - width) / 2;\n              this.setWidth(this.labelWidth);\n            }\n\n            if (this.labelHeight > height) {\n              if (this.labelPos == \"center\") {\n                this.rect.y -= (this.labelHeight - height) / 2;\n              } else if (this.labelPos == \"top\") {\n                this.rect.y -= this.labelHeight - height;\n              }\n\n              this.setHeight(this.labelHeight);\n            }\n          }\n        }\n      };\n\n      LNode.prototype.getInclusionTreeDepth = function () {\n        if (this.inclusionTreeDepth == Integer.MAX_VALUE) {\n          throw \"assert failed\";\n        }\n\n        return this.inclusionTreeDepth;\n      };\n\n      LNode.prototype.transform = function (trans) {\n        var left = this.rect.x;\n\n        if (left > LayoutConstants.WORLD_BOUNDARY) {\n          left = LayoutConstants.WORLD_BOUNDARY;\n        } else if (left < -LayoutConstants.WORLD_BOUNDARY) {\n          left = -LayoutConstants.WORLD_BOUNDARY;\n        }\n\n        var top = this.rect.y;\n\n        if (top > LayoutConstants.WORLD_BOUNDARY) {\n          top = LayoutConstants.WORLD_BOUNDARY;\n        } else if (top < -LayoutConstants.WORLD_BOUNDARY) {\n          top = -LayoutConstants.WORLD_BOUNDARY;\n        }\n\n        var leftTop = new PointD(left, top);\n        var vLeftTop = trans.inverseTransformPoint(leftTop);\n        this.setLocation(vLeftTop.x, vLeftTop.y);\n      };\n\n      LNode.prototype.getLeft = function () {\n        return this.rect.x;\n      };\n\n      LNode.prototype.getRight = function () {\n        return this.rect.x + this.rect.width;\n      };\n\n      LNode.prototype.getTop = function () {\n        return this.rect.y;\n      };\n\n      LNode.prototype.getBottom = function () {\n        return this.rect.y + this.rect.height;\n      };\n\n      LNode.prototype.getParent = function () {\n        if (this.owner == null) {\n          return null;\n        }\n\n        return this.owner.getParent();\n      };\n\n      module.exports = LNode;\n      /***/\n    },\n    /* 4 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function PointD(x, y) {\n        if (x == null && y == null) {\n          this.x = 0;\n          this.y = 0;\n        } else {\n          this.x = x;\n          this.y = y;\n        }\n      }\n\n      PointD.prototype.getX = function () {\n        return this.x;\n      };\n\n      PointD.prototype.getY = function () {\n        return this.y;\n      };\n\n      PointD.prototype.setX = function (x) {\n        this.x = x;\n      };\n\n      PointD.prototype.setY = function (y) {\n        this.y = y;\n      };\n\n      PointD.prototype.getDifference = function (pt) {\n        return new DimensionD(this.x - pt.x, this.y - pt.y);\n      };\n\n      PointD.prototype.getCopy = function () {\n        return new PointD(this.x, this.y);\n      };\n\n      PointD.prototype.translate = function (dim) {\n        this.x += dim.width;\n        this.y += dim.height;\n        return this;\n      };\n\n      module.exports = PointD;\n      /***/\n    },\n    /* 5 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var LGraphObject = __webpack_require__(2);\n\n      var Integer = __webpack_require__(10);\n\n      var LayoutConstants = __webpack_require__(0);\n\n      var LGraphManager = __webpack_require__(6);\n\n      var LNode = __webpack_require__(3);\n\n      var LEdge = __webpack_require__(1);\n\n      var RectangleD = __webpack_require__(13);\n\n      var Point = __webpack_require__(12);\n\n      var LinkedList = __webpack_require__(11);\n\n      function LGraph(parent, obj2, vGraph) {\n        LGraphObject.call(this, vGraph);\n        this.estimatedSize = Integer.MIN_VALUE;\n        this.margin = LayoutConstants.DEFAULT_GRAPH_MARGIN;\n        this.edges = [];\n        this.nodes = [];\n        this.isConnected = false;\n        this.parent = parent;\n\n        if (obj2 != null && obj2 instanceof LGraphManager) {\n          this.graphManager = obj2;\n        } else if (obj2 != null && obj2 instanceof Layout) {\n          this.graphManager = obj2.graphManager;\n        }\n      }\n\n      LGraph.prototype = Object.create(LGraphObject.prototype);\n\n      for (var prop in LGraphObject) {\n        LGraph[prop] = LGraphObject[prop];\n      }\n\n      LGraph.prototype.getNodes = function () {\n        return this.nodes;\n      };\n\n      LGraph.prototype.getEdges = function () {\n        return this.edges;\n      };\n\n      LGraph.prototype.getGraphManager = function () {\n        return this.graphManager;\n      };\n\n      LGraph.prototype.getParent = function () {\n        return this.parent;\n      };\n\n      LGraph.prototype.getLeft = function () {\n        return this.left;\n      };\n\n      LGraph.prototype.getRight = function () {\n        return this.right;\n      };\n\n      LGraph.prototype.getTop = function () {\n        return this.top;\n      };\n\n      LGraph.prototype.getBottom = function () {\n        return this.bottom;\n      };\n\n      LGraph.prototype.isConnected = function () {\n        return this.isConnected;\n      };\n\n      LGraph.prototype.add = function (obj1, sourceNode, targetNode) {\n        if (sourceNode == null && targetNode == null) {\n          var newNode = obj1;\n\n          if (this.graphManager == null) {\n            throw \"Graph has no graph mgr!\";\n          }\n\n          if (this.getNodes().indexOf(newNode) > -1) {\n            throw \"Node already in graph!\";\n          }\n\n          newNode.owner = this;\n          this.getNodes().push(newNode);\n          return newNode;\n        } else {\n          var newEdge = obj1;\n\n          if (!(this.getNodes().indexOf(sourceNode) > -1 && this.getNodes().indexOf(targetNode) > -1)) {\n            throw \"Source or target not in graph!\";\n          }\n\n          if (!(sourceNode.owner == targetNode.owner && sourceNode.owner == this)) {\n            throw \"Both owners must be this graph!\";\n          }\n\n          if (sourceNode.owner != targetNode.owner) {\n            return null;\n          } // set source and target\n\n\n          newEdge.source = sourceNode;\n          newEdge.target = targetNode; // set as intra-graph edge\n\n          newEdge.isInterGraph = false; // add to graph edge list\n\n          this.getEdges().push(newEdge); // add to incidency lists\n\n          sourceNode.edges.push(newEdge);\n\n          if (targetNode != sourceNode) {\n            targetNode.edges.push(newEdge);\n          }\n\n          return newEdge;\n        }\n      };\n\n      LGraph.prototype.remove = function (obj) {\n        var node = obj;\n\n        if (obj instanceof LNode) {\n          if (node == null) {\n            throw \"Node is null!\";\n          }\n\n          if (!(node.owner != null && node.owner == this)) {\n            throw \"Owner graph is invalid!\";\n          }\n\n          if (this.graphManager == null) {\n            throw \"Owner graph manager is invalid!\";\n          } // remove incident edges first (make a copy to do it safely)\n\n\n          var edgesToBeRemoved = node.edges.slice();\n          var edge;\n          var s = edgesToBeRemoved.length;\n\n          for (var i = 0; i < s; i++) {\n            edge = edgesToBeRemoved[i];\n\n            if (edge.isInterGraph) {\n              this.graphManager.remove(edge);\n            } else {\n              edge.source.owner.remove(edge);\n            }\n          } // now the node itself\n\n\n          var index = this.nodes.indexOf(node);\n\n          if (index == -1) {\n            throw \"Node not in owner node list!\";\n          }\n\n          this.nodes.splice(index, 1);\n        } else if (obj instanceof LEdge) {\n          var edge = obj;\n\n          if (edge == null) {\n            throw \"Edge is null!\";\n          }\n\n          if (!(edge.source != null && edge.target != null)) {\n            throw \"Source and/or target is null!\";\n          }\n\n          if (!(edge.source.owner != null && edge.target.owner != null && edge.source.owner == this && edge.target.owner == this)) {\n            throw \"Source and/or target owner is invalid!\";\n          }\n\n          var sourceIndex = edge.source.edges.indexOf(edge);\n          var targetIndex = edge.target.edges.indexOf(edge);\n\n          if (!(sourceIndex > -1 && targetIndex > -1)) {\n            throw \"Source and/or target doesn't know this edge!\";\n          }\n\n          edge.source.edges.splice(sourceIndex, 1);\n\n          if (edge.target != edge.source) {\n            edge.target.edges.splice(targetIndex, 1);\n          }\n\n          var index = edge.source.owner.getEdges().indexOf(edge);\n\n          if (index == -1) {\n            throw \"Not in owner's edge list!\";\n          }\n\n          edge.source.owner.getEdges().splice(index, 1);\n        }\n      };\n\n      LGraph.prototype.updateLeftTop = function () {\n        var top = Integer.MAX_VALUE;\n        var left = Integer.MAX_VALUE;\n        var nodeTop;\n        var nodeLeft;\n        var margin;\n        var nodes = this.getNodes();\n        var s = nodes.length;\n\n        for (var i = 0; i < s; i++) {\n          var lNode = nodes[i];\n          nodeTop = lNode.getTop();\n          nodeLeft = lNode.getLeft();\n\n          if (top > nodeTop) {\n            top = nodeTop;\n          }\n\n          if (left > nodeLeft) {\n            left = nodeLeft;\n          }\n        } // Do we have any nodes in this graph?\n\n\n        if (top == Integer.MAX_VALUE) {\n          return null;\n        }\n\n        if (nodes[0].getParent().paddingLeft != undefined) {\n          margin = nodes[0].getParent().paddingLeft;\n        } else {\n          margin = this.margin;\n        }\n\n        this.left = left - margin;\n        this.top = top - margin; // Apply the margins and return the result\n\n        return new Point(this.left, this.top);\n      };\n\n      LGraph.prototype.updateBounds = function (recursive) {\n        // calculate bounds\n        var left = Integer.MAX_VALUE;\n        var right = -Integer.MAX_VALUE;\n        var top = Integer.MAX_VALUE;\n        var bottom = -Integer.MAX_VALUE;\n        var nodeLeft;\n        var nodeRight;\n        var nodeTop;\n        var nodeBottom;\n        var margin;\n        var nodes = this.nodes;\n        var s = nodes.length;\n\n        for (var i = 0; i < s; i++) {\n          var lNode = nodes[i];\n\n          if (recursive && lNode.child != null) {\n            lNode.updateBounds();\n          }\n\n          nodeLeft = lNode.getLeft();\n          nodeRight = lNode.getRight();\n          nodeTop = lNode.getTop();\n          nodeBottom = lNode.getBottom();\n\n          if (left > nodeLeft) {\n            left = nodeLeft;\n          }\n\n          if (right < nodeRight) {\n            right = nodeRight;\n          }\n\n          if (top > nodeTop) {\n            top = nodeTop;\n          }\n\n          if (bottom < nodeBottom) {\n            bottom = nodeBottom;\n          }\n        }\n\n        var boundingRect = new RectangleD(left, top, right - left, bottom - top);\n\n        if (left == Integer.MAX_VALUE) {\n          this.left = this.parent.getLeft();\n          this.right = this.parent.getRight();\n          this.top = this.parent.getTop();\n          this.bottom = this.parent.getBottom();\n        }\n\n        if (nodes[0].getParent().paddingLeft != undefined) {\n          margin = nodes[0].getParent().paddingLeft;\n        } else {\n          margin = this.margin;\n        }\n\n        this.left = boundingRect.x - margin;\n        this.right = boundingRect.x + boundingRect.width + margin;\n        this.top = boundingRect.y - margin;\n        this.bottom = boundingRect.y + boundingRect.height + margin;\n      };\n\n      LGraph.calculateBounds = function (nodes) {\n        var left = Integer.MAX_VALUE;\n        var right = -Integer.MAX_VALUE;\n        var top = Integer.MAX_VALUE;\n        var bottom = -Integer.MAX_VALUE;\n        var nodeLeft;\n        var nodeRight;\n        var nodeTop;\n        var nodeBottom;\n        var s = nodes.length;\n\n        for (var i = 0; i < s; i++) {\n          var lNode = nodes[i];\n          nodeLeft = lNode.getLeft();\n          nodeRight = lNode.getRight();\n          nodeTop = lNode.getTop();\n          nodeBottom = lNode.getBottom();\n\n          if (left > nodeLeft) {\n            left = nodeLeft;\n          }\n\n          if (right < nodeRight) {\n            right = nodeRight;\n          }\n\n          if (top > nodeTop) {\n            top = nodeTop;\n          }\n\n          if (bottom < nodeBottom) {\n            bottom = nodeBottom;\n          }\n        }\n\n        var boundingRect = new RectangleD(left, top, right - left, bottom - top);\n        return boundingRect;\n      };\n\n      LGraph.prototype.getInclusionTreeDepth = function () {\n        if (this == this.graphManager.getRoot()) {\n          return 1;\n        } else {\n          return this.parent.getInclusionTreeDepth();\n        }\n      };\n\n      LGraph.prototype.getEstimatedSize = function () {\n        if (this.estimatedSize == Integer.MIN_VALUE) {\n          throw \"assert failed\";\n        }\n\n        return this.estimatedSize;\n      };\n\n      LGraph.prototype.calcEstimatedSize = function () {\n        var size = 0;\n        var nodes = this.nodes;\n        var s = nodes.length;\n\n        for (var i = 0; i < s; i++) {\n          var lNode = nodes[i];\n          size += lNode.calcEstimatedSize();\n        }\n\n        if (size == 0) {\n          this.estimatedSize = LayoutConstants.EMPTY_COMPOUND_NODE_SIZE;\n        } else {\n          this.estimatedSize = size / Math.sqrt(this.nodes.length);\n        }\n\n        return this.estimatedSize;\n      };\n\n      LGraph.prototype.updateConnected = function () {\n        var self = this;\n\n        if (this.nodes.length == 0) {\n          this.isConnected = true;\n          return;\n        }\n\n        var queue = new LinkedList();\n        var visited = new Set();\n        var currentNode = this.nodes[0];\n        var neighborEdges;\n        var currentNeighbor;\n        var childrenOfNode = currentNode.withChildren();\n        childrenOfNode.forEach(function (node) {\n          queue.push(node);\n          visited.add(node);\n        });\n\n        while (queue.length !== 0) {\n          currentNode = queue.shift(); // Traverse all neighbors of this node\n\n          neighborEdges = currentNode.getEdges();\n          var size = neighborEdges.length;\n\n          for (var i = 0; i < size; i++) {\n            var neighborEdge = neighborEdges[i];\n            currentNeighbor = neighborEdge.getOtherEndInGraph(currentNode, this); // Add unvisited neighbors to the list to visit\n\n            if (currentNeighbor != null && !visited.has(currentNeighbor)) {\n              var childrenOfNeighbor = currentNeighbor.withChildren();\n              childrenOfNeighbor.forEach(function (node) {\n                queue.push(node);\n                visited.add(node);\n              });\n            }\n          }\n        }\n\n        this.isConnected = false;\n\n        if (visited.size >= this.nodes.length) {\n          var noOfVisitedInThisGraph = 0;\n          visited.forEach(function (visitedNode) {\n            if (visitedNode.owner == self) {\n              noOfVisitedInThisGraph++;\n            }\n          });\n\n          if (noOfVisitedInThisGraph == this.nodes.length) {\n            this.isConnected = true;\n          }\n        }\n      };\n\n      module.exports = LGraph;\n      /***/\n    },\n    /* 6 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var LGraph;\n\n      var LEdge = __webpack_require__(1);\n\n      function LGraphManager(layout) {\n        LGraph = __webpack_require__(5); // It may be better to initilize this out of this function but it gives an error (Right-hand side of 'instanceof' is not callable) now.\n\n        this.layout = layout;\n        this.graphs = [];\n        this.edges = [];\n      }\n\n      LGraphManager.prototype.addRoot = function () {\n        var ngraph = this.layout.newGraph();\n        var nnode = this.layout.newNode(null);\n        var root = this.add(ngraph, nnode);\n        this.setRootGraph(root);\n        return this.rootGraph;\n      };\n\n      LGraphManager.prototype.add = function (newGraph, parentNode, newEdge, sourceNode, targetNode) {\n        //there are just 2 parameters are passed then it adds an LGraph else it adds an LEdge\n        if (newEdge == null && sourceNode == null && targetNode == null) {\n          if (newGraph == null) {\n            throw \"Graph is null!\";\n          }\n\n          if (parentNode == null) {\n            throw \"Parent node is null!\";\n          }\n\n          if (this.graphs.indexOf(newGraph) > -1) {\n            throw \"Graph already in this graph mgr!\";\n          }\n\n          this.graphs.push(newGraph);\n\n          if (newGraph.parent != null) {\n            throw \"Already has a parent!\";\n          }\n\n          if (parentNode.child != null) {\n            throw \"Already has a child!\";\n          }\n\n          newGraph.parent = parentNode;\n          parentNode.child = newGraph;\n          return newGraph;\n        } else {\n          //change the order of the parameters\n          targetNode = newEdge;\n          sourceNode = parentNode;\n          newEdge = newGraph;\n          var sourceGraph = sourceNode.getOwner();\n          var targetGraph = targetNode.getOwner();\n\n          if (!(sourceGraph != null && sourceGraph.getGraphManager() == this)) {\n            throw \"Source not in this graph mgr!\";\n          }\n\n          if (!(targetGraph != null && targetGraph.getGraphManager() == this)) {\n            throw \"Target not in this graph mgr!\";\n          }\n\n          if (sourceGraph == targetGraph) {\n            newEdge.isInterGraph = false;\n            return sourceGraph.add(newEdge, sourceNode, targetNode);\n          } else {\n            newEdge.isInterGraph = true; // set source and target\n\n            newEdge.source = sourceNode;\n            newEdge.target = targetNode; // add edge to inter-graph edge list\n\n            if (this.edges.indexOf(newEdge) > -1) {\n              throw \"Edge already in inter-graph edge list!\";\n            }\n\n            this.edges.push(newEdge); // add edge to source and target incidency lists\n\n            if (!(newEdge.source != null && newEdge.target != null)) {\n              throw \"Edge source and/or target is null!\";\n            }\n\n            if (!(newEdge.source.edges.indexOf(newEdge) == -1 && newEdge.target.edges.indexOf(newEdge) == -1)) {\n              throw \"Edge already in source and/or target incidency list!\";\n            }\n\n            newEdge.source.edges.push(newEdge);\n            newEdge.target.edges.push(newEdge);\n            return newEdge;\n          }\n        }\n      };\n\n      LGraphManager.prototype.remove = function (lObj) {\n        if (lObj instanceof LGraph) {\n          var graph = lObj;\n\n          if (graph.getGraphManager() != this) {\n            throw \"Graph not in this graph mgr\";\n          }\n\n          if (!(graph == this.rootGraph || graph.parent != null && graph.parent.graphManager == this)) {\n            throw \"Invalid parent node!\";\n          } // first the edges (make a copy to do it safely)\n\n\n          var edgesToBeRemoved = [];\n          edgesToBeRemoved = edgesToBeRemoved.concat(graph.getEdges());\n          var edge;\n          var s = edgesToBeRemoved.length;\n\n          for (var i = 0; i < s; i++) {\n            edge = edgesToBeRemoved[i];\n            graph.remove(edge);\n          } // then the nodes (make a copy to do it safely)\n\n\n          var nodesToBeRemoved = [];\n          nodesToBeRemoved = nodesToBeRemoved.concat(graph.getNodes());\n          var node;\n          s = nodesToBeRemoved.length;\n\n          for (var i = 0; i < s; i++) {\n            node = nodesToBeRemoved[i];\n            graph.remove(node);\n          } // check if graph is the root\n\n\n          if (graph == this.rootGraph) {\n            this.setRootGraph(null);\n          } // now remove the graph itself\n\n\n          var index = this.graphs.indexOf(graph);\n          this.graphs.splice(index, 1); // also reset the parent of the graph\n\n          graph.parent = null;\n        } else if (lObj instanceof LEdge) {\n          edge = lObj;\n\n          if (edge == null) {\n            throw \"Edge is null!\";\n          }\n\n          if (!edge.isInterGraph) {\n            throw \"Not an inter-graph edge!\";\n          }\n\n          if (!(edge.source != null && edge.target != null)) {\n            throw \"Source and/or target is null!\";\n          } // remove edge from source and target nodes' incidency lists\n\n\n          if (!(edge.source.edges.indexOf(edge) != -1 && edge.target.edges.indexOf(edge) != -1)) {\n            throw \"Source and/or target doesn't know this edge!\";\n          }\n\n          var index = edge.source.edges.indexOf(edge);\n          edge.source.edges.splice(index, 1);\n          index = edge.target.edges.indexOf(edge);\n          edge.target.edges.splice(index, 1); // remove edge from owner graph manager's inter-graph edge list\n\n          if (!(edge.source.owner != null && edge.source.owner.getGraphManager() != null)) {\n            throw \"Edge owner graph or owner graph manager is null!\";\n          }\n\n          if (edge.source.owner.getGraphManager().edges.indexOf(edge) == -1) {\n            throw \"Not in owner graph manager's edge list!\";\n          }\n\n          var index = edge.source.owner.getGraphManager().edges.indexOf(edge);\n          edge.source.owner.getGraphManager().edges.splice(index, 1);\n        }\n      };\n\n      LGraphManager.prototype.updateBounds = function () {\n        this.rootGraph.updateBounds(true);\n      };\n\n      LGraphManager.prototype.getGraphs = function () {\n        return this.graphs;\n      };\n\n      LGraphManager.prototype.getAllNodes = function () {\n        if (this.allNodes == null) {\n          var nodeList = [];\n          var graphs = this.getGraphs();\n          var s = graphs.length;\n\n          for (var i = 0; i < s; i++) {\n            nodeList = nodeList.concat(graphs[i].getNodes());\n          }\n\n          this.allNodes = nodeList;\n        }\n\n        return this.allNodes;\n      };\n\n      LGraphManager.prototype.resetAllNodes = function () {\n        this.allNodes = null;\n      };\n\n      LGraphManager.prototype.resetAllEdges = function () {\n        this.allEdges = null;\n      };\n\n      LGraphManager.prototype.resetAllNodesToApplyGravitation = function () {\n        this.allNodesToApplyGravitation = null;\n      };\n\n      LGraphManager.prototype.getAllEdges = function () {\n        if (this.allEdges == null) {\n          var edgeList = [];\n          var graphs = this.getGraphs();\n          var s = graphs.length;\n\n          for (var i = 0; i < graphs.length; i++) {\n            edgeList = edgeList.concat(graphs[i].getEdges());\n          }\n\n          edgeList = edgeList.concat(this.edges);\n          this.allEdges = edgeList;\n        }\n\n        return this.allEdges;\n      };\n\n      LGraphManager.prototype.getAllNodesToApplyGravitation = function () {\n        return this.allNodesToApplyGravitation;\n      };\n\n      LGraphManager.prototype.setAllNodesToApplyGravitation = function (nodeList) {\n        if (this.allNodesToApplyGravitation != null) {\n          throw \"assert failed\";\n        }\n\n        this.allNodesToApplyGravitation = nodeList;\n      };\n\n      LGraphManager.prototype.getRoot = function () {\n        return this.rootGraph;\n      };\n\n      LGraphManager.prototype.setRootGraph = function (graph) {\n        if (graph.getGraphManager() != this) {\n          throw \"Root not in this graph mgr!\";\n        }\n\n        this.rootGraph = graph; // root graph must have a root node associated with it for convenience\n\n        if (graph.parent == null) {\n          graph.parent = this.layout.newNode(\"Root node\");\n        }\n      };\n\n      LGraphManager.prototype.getLayout = function () {\n        return this.layout;\n      };\n\n      LGraphManager.prototype.isOneAncestorOfOther = function (firstNode, secondNode) {\n        if (!(firstNode != null && secondNode != null)) {\n          throw \"assert failed\";\n        }\n\n        if (firstNode == secondNode) {\n          return true;\n        } // Is second node an ancestor of the first one?\n\n\n        var ownerGraph = firstNode.getOwner();\n        var parentNode;\n\n        do {\n          parentNode = ownerGraph.getParent();\n\n          if (parentNode == null) {\n            break;\n          }\n\n          if (parentNode == secondNode) {\n            return true;\n          }\n\n          ownerGraph = parentNode.getOwner();\n\n          if (ownerGraph == null) {\n            break;\n          }\n        } while (true); // Is first node an ancestor of the second one?\n\n\n        ownerGraph = secondNode.getOwner();\n\n        do {\n          parentNode = ownerGraph.getParent();\n\n          if (parentNode == null) {\n            break;\n          }\n\n          if (parentNode == firstNode) {\n            return true;\n          }\n\n          ownerGraph = parentNode.getOwner();\n\n          if (ownerGraph == null) {\n            break;\n          }\n        } while (true);\n\n        return false;\n      };\n\n      LGraphManager.prototype.calcLowestCommonAncestors = function () {\n        var edge;\n        var sourceNode;\n        var targetNode;\n        var sourceAncestorGraph;\n        var targetAncestorGraph;\n        var edges = this.getAllEdges();\n        var s = edges.length;\n\n        for (var i = 0; i < s; i++) {\n          edge = edges[i];\n          sourceNode = edge.source;\n          targetNode = edge.target;\n          edge.lca = null;\n          edge.sourceInLca = sourceNode;\n          edge.targetInLca = targetNode;\n\n          if (sourceNode == targetNode) {\n            edge.lca = sourceNode.getOwner();\n            continue;\n          }\n\n          sourceAncestorGraph = sourceNode.getOwner();\n\n          while (edge.lca == null) {\n            edge.targetInLca = targetNode;\n            targetAncestorGraph = targetNode.getOwner();\n\n            while (edge.lca == null) {\n              if (targetAncestorGraph == sourceAncestorGraph) {\n                edge.lca = targetAncestorGraph;\n                break;\n              }\n\n              if (targetAncestorGraph == this.rootGraph) {\n                break;\n              }\n\n              if (edge.lca != null) {\n                throw \"assert failed\";\n              }\n\n              edge.targetInLca = targetAncestorGraph.getParent();\n              targetAncestorGraph = edge.targetInLca.getOwner();\n            }\n\n            if (sourceAncestorGraph == this.rootGraph) {\n              break;\n            }\n\n            if (edge.lca == null) {\n              edge.sourceInLca = sourceAncestorGraph.getParent();\n              sourceAncestorGraph = edge.sourceInLca.getOwner();\n            }\n          }\n\n          if (edge.lca == null) {\n            throw \"assert failed\";\n          }\n        }\n      };\n\n      LGraphManager.prototype.calcLowestCommonAncestor = function (firstNode, secondNode) {\n        if (firstNode == secondNode) {\n          return firstNode.getOwner();\n        }\n\n        var firstOwnerGraph = firstNode.getOwner();\n\n        do {\n          if (firstOwnerGraph == null) {\n            break;\n          }\n\n          var secondOwnerGraph = secondNode.getOwner();\n\n          do {\n            if (secondOwnerGraph == null) {\n              break;\n            }\n\n            if (secondOwnerGraph == firstOwnerGraph) {\n              return secondOwnerGraph;\n            }\n\n            secondOwnerGraph = secondOwnerGraph.getParent().getOwner();\n          } while (true);\n\n          firstOwnerGraph = firstOwnerGraph.getParent().getOwner();\n        } while (true);\n\n        return firstOwnerGraph;\n      };\n\n      LGraphManager.prototype.calcInclusionTreeDepths = function (graph, depth) {\n        if (graph == null && depth == null) {\n          graph = this.rootGraph;\n          depth = 1;\n        }\n\n        var node;\n        var nodes = graph.getNodes();\n        var s = nodes.length;\n\n        for (var i = 0; i < s; i++) {\n          node = nodes[i];\n          node.inclusionTreeDepth = depth;\n\n          if (node.child != null) {\n            this.calcInclusionTreeDepths(node.child, depth + 1);\n          }\n        }\n      };\n\n      LGraphManager.prototype.includesInvalidEdge = function () {\n        var edge;\n        var s = this.edges.length;\n\n        for (var i = 0; i < s; i++) {\n          edge = this.edges[i];\n\n          if (this.isOneAncestorOfOther(edge.source, edge.target)) {\n            return true;\n          }\n        }\n\n        return false;\n      };\n\n      module.exports = LGraphManager;\n      /***/\n    },\n    /* 7 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var LayoutConstants = __webpack_require__(0);\n\n      function FDLayoutConstants() {} //FDLayoutConstants inherits static props in LayoutConstants\n\n\n      for (var prop in LayoutConstants) {\n        FDLayoutConstants[prop] = LayoutConstants[prop];\n      }\n\n      FDLayoutConstants.MAX_ITERATIONS = 2500;\n      FDLayoutConstants.DEFAULT_EDGE_LENGTH = 50;\n      FDLayoutConstants.DEFAULT_SPRING_STRENGTH = 0.45;\n      FDLayoutConstants.DEFAULT_REPULSION_STRENGTH = 4500.0;\n      FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH = 0.4;\n      FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = 1.0;\n      FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR = 3.8;\n      FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = 1.5;\n      FDLayoutConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION = true;\n      FDLayoutConstants.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION = true;\n      FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = 0.3;\n      FDLayoutConstants.COOLING_ADAPTATION_FACTOR = 0.33;\n      FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT = 1000;\n      FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT = 5000;\n      FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL = 100.0;\n      FDLayoutConstants.MAX_NODE_DISPLACEMENT = FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL * 3;\n      FDLayoutConstants.MIN_REPULSION_DIST = FDLayoutConstants.DEFAULT_EDGE_LENGTH / 10.0;\n      FDLayoutConstants.CONVERGENCE_CHECK_PERIOD = 100;\n      FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = 0.1;\n      FDLayoutConstants.MIN_EDGE_LENGTH = 1;\n      FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD = 10;\n      module.exports = FDLayoutConstants;\n      /***/\n    },\n    /* 8 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n      /**\n       * This class maintains a list of static geometry related utility methods.\n       *\n       *\n       * Copyright: i-Vis Research Group, Bilkent University, 2007 - present\n       */\n\n      var Point = __webpack_require__(12);\n\n      function IGeometry() {}\n      /**\n       * This method calculates *half* the amount in x and y directions of the two\n       * input rectangles needed to separate them keeping their respective\n       * positioning, and returns the result in the input array. An input\n       * separation buffer added to the amount in both directions. We assume that\n       * the two rectangles do intersect.\n       */\n\n\n      IGeometry.calcSeparationAmount = function (rectA, rectB, overlapAmount, separationBuffer) {\n        if (!rectA.intersects(rectB)) {\n          throw \"assert failed\";\n        }\n\n        var directions = new Array(2);\n        this.decideDirectionsForOverlappingNodes(rectA, rectB, directions);\n        overlapAmount[0] = Math.min(rectA.getRight(), rectB.getRight()) - Math.max(rectA.x, rectB.x);\n        overlapAmount[1] = Math.min(rectA.getBottom(), rectB.getBottom()) - Math.max(rectA.y, rectB.y); // update the overlapping amounts for the following cases:\n\n        if (rectA.getX() <= rectB.getX() && rectA.getRight() >= rectB.getRight()) {\n          /* Case x.1:\n          *\n          * rectA\n          * \t|                       |\n          * \t|        _________      |\n          * \t|        |       |      |\n          * \t|________|_______|______|\n          * \t\t\t |       |\n          *           |       |\n          *        rectB\n          */\n          overlapAmount[0] += Math.min(rectB.getX() - rectA.getX(), rectA.getRight() - rectB.getRight());\n        } else if (rectB.getX() <= rectA.getX() && rectB.getRight() >= rectA.getRight()) {\n          /* Case x.2:\n          *\n          * rectB\n          * \t|                       |\n          * \t|        _________      |\n          * \t|        |       |      |\n          * \t|________|_______|______|\n          * \t\t\t |       |\n          *           |       |\n          *        rectA\n          */\n          overlapAmount[0] += Math.min(rectA.getX() - rectB.getX(), rectB.getRight() - rectA.getRight());\n        }\n\n        if (rectA.getY() <= rectB.getY() && rectA.getBottom() >= rectB.getBottom()) {\n          /* Case y.1:\n           *          ________ rectA\n           *         |\n           *         |\n           *   ______|____  rectB\n           *         |    |\n           *         |    |\n           *   ______|____|\n           *         |\n           *         |\n           *         |________\n           *\n           */\n          overlapAmount[1] += Math.min(rectB.getY() - rectA.getY(), rectA.getBottom() - rectB.getBottom());\n        } else if (rectB.getY() <= rectA.getY() && rectB.getBottom() >= rectA.getBottom()) {\n          /* Case y.2:\n          *          ________ rectB\n          *         |\n          *         |\n          *   ______|____  rectA\n          *         |    |\n          *         |    |\n          *   ______|____|\n          *         |\n          *         |\n          *         |________\n          *\n          */\n          overlapAmount[1] += Math.min(rectA.getY() - rectB.getY(), rectB.getBottom() - rectA.getBottom());\n        } // find slope of the line passes two centers\n\n\n        var slope = Math.abs((rectB.getCenterY() - rectA.getCenterY()) / (rectB.getCenterX() - rectA.getCenterX())); // if centers are overlapped\n\n        if (rectB.getCenterY() === rectA.getCenterY() && rectB.getCenterX() === rectA.getCenterX()) {\n          // assume the slope is 1 (45 degree)\n          slope = 1.0;\n        }\n\n        var moveByY = slope * overlapAmount[0];\n        var moveByX = overlapAmount[1] / slope;\n\n        if (overlapAmount[0] < moveByX) {\n          moveByX = overlapAmount[0];\n        } else {\n          moveByY = overlapAmount[1];\n        } // return half the amount so that if each rectangle is moved by these\n        // amounts in opposite directions, overlap will be resolved\n\n\n        overlapAmount[0] = -1 * directions[0] * (moveByX / 2 + separationBuffer);\n        overlapAmount[1] = -1 * directions[1] * (moveByY / 2 + separationBuffer);\n      };\n      /**\n       * This method decides the separation direction of overlapping nodes\n       *\n       * if directions[0] = -1, then rectA goes left\n       * if directions[0] = 1,  then rectA goes right\n       * if directions[1] = -1, then rectA goes up\n       * if directions[1] = 1,  then rectA goes down\n       */\n\n\n      IGeometry.decideDirectionsForOverlappingNodes = function (rectA, rectB, directions) {\n        if (rectA.getCenterX() < rectB.getCenterX()) {\n          directions[0] = -1;\n        } else {\n          directions[0] = 1;\n        }\n\n        if (rectA.getCenterY() < rectB.getCenterY()) {\n          directions[1] = -1;\n        } else {\n          directions[1] = 1;\n        }\n      };\n      /**\n       * This method calculates the intersection (clipping) points of the two\n       * input rectangles with line segment defined by the centers of these two\n       * rectangles. The clipping points are saved in the input double array and\n       * whether or not the two rectangles overlap is returned.\n       */\n\n\n      IGeometry.getIntersection2 = function (rectA, rectB, result) {\n        //result[0-1] will contain clipPoint of rectA, result[2-3] will contain clipPoint of rectB\n        var p1x = rectA.getCenterX();\n        var p1y = rectA.getCenterY();\n        var p2x = rectB.getCenterX();\n        var p2y = rectB.getCenterY(); //if two rectangles intersect, then clipping points are centers\n\n        if (rectA.intersects(rectB)) {\n          result[0] = p1x;\n          result[1] = p1y;\n          result[2] = p2x;\n          result[3] = p2y;\n          return true;\n        } //variables for rectA\n\n\n        var topLeftAx = rectA.getX();\n        var topLeftAy = rectA.getY();\n        var topRightAx = rectA.getRight();\n        var bottomLeftAx = rectA.getX();\n        var bottomLeftAy = rectA.getBottom();\n        var bottomRightAx = rectA.getRight();\n        var halfWidthA = rectA.getWidthHalf();\n        var halfHeightA = rectA.getHeightHalf(); //variables for rectB\n\n        var topLeftBx = rectB.getX();\n        var topLeftBy = rectB.getY();\n        var topRightBx = rectB.getRight();\n        var bottomLeftBx = rectB.getX();\n        var bottomLeftBy = rectB.getBottom();\n        var bottomRightBx = rectB.getRight();\n        var halfWidthB = rectB.getWidthHalf();\n        var halfHeightB = rectB.getHeightHalf(); //flag whether clipping points are found\n\n        var clipPointAFound = false;\n        var clipPointBFound = false; // line is vertical\n\n        if (p1x === p2x) {\n          if (p1y > p2y) {\n            result[0] = p1x;\n            result[1] = topLeftAy;\n            result[2] = p2x;\n            result[3] = bottomLeftBy;\n            return false;\n          } else if (p1y < p2y) {\n            result[0] = p1x;\n            result[1] = bottomLeftAy;\n            result[2] = p2x;\n            result[3] = topLeftBy;\n            return false;\n          } else {//not line, return null;\n          }\n        } // line is horizontal\n        else if (p1y === p2y) {\n          if (p1x > p2x) {\n            result[0] = topLeftAx;\n            result[1] = p1y;\n            result[2] = topRightBx;\n            result[3] = p2y;\n            return false;\n          } else if (p1x < p2x) {\n            result[0] = topRightAx;\n            result[1] = p1y;\n            result[2] = topLeftBx;\n            result[3] = p2y;\n            return false;\n          } else {//not valid line, return null;\n          }\n        } else {\n          //slopes of rectA's and rectB's diagonals\n          var slopeA = rectA.height / rectA.width;\n          var slopeB = rectB.height / rectB.width; //slope of line between center of rectA and center of rectB\n\n          var slopePrime = (p2y - p1y) / (p2x - p1x);\n          var cardinalDirectionA = void 0;\n          var cardinalDirectionB = void 0;\n          var tempPointAx = void 0;\n          var tempPointAy = void 0;\n          var tempPointBx = void 0;\n          var tempPointBy = void 0; //determine whether clipping point is the corner of nodeA\n\n          if (-slopeA === slopePrime) {\n            if (p1x > p2x) {\n              result[0] = bottomLeftAx;\n              result[1] = bottomLeftAy;\n              clipPointAFound = true;\n            } else {\n              result[0] = topRightAx;\n              result[1] = topLeftAy;\n              clipPointAFound = true;\n            }\n          } else if (slopeA === slopePrime) {\n            if (p1x > p2x) {\n              result[0] = topLeftAx;\n              result[1] = topLeftAy;\n              clipPointAFound = true;\n            } else {\n              result[0] = bottomRightAx;\n              result[1] = bottomLeftAy;\n              clipPointAFound = true;\n            }\n          } //determine whether clipping point is the corner of nodeB\n\n\n          if (-slopeB === slopePrime) {\n            if (p2x > p1x) {\n              result[2] = bottomLeftBx;\n              result[3] = bottomLeftBy;\n              clipPointBFound = true;\n            } else {\n              result[2] = topRightBx;\n              result[3] = topLeftBy;\n              clipPointBFound = true;\n            }\n          } else if (slopeB === slopePrime) {\n            if (p2x > p1x) {\n              result[2] = topLeftBx;\n              result[3] = topLeftBy;\n              clipPointBFound = true;\n            } else {\n              result[2] = bottomRightBx;\n              result[3] = bottomLeftBy;\n              clipPointBFound = true;\n            }\n          } //if both clipping points are corners\n\n\n          if (clipPointAFound && clipPointBFound) {\n            return false;\n          } //determine Cardinal Direction of rectangles\n\n\n          if (p1x > p2x) {\n            if (p1y > p2y) {\n              cardinalDirectionA = this.getCardinalDirection(slopeA, slopePrime, 4);\n              cardinalDirectionB = this.getCardinalDirection(slopeB, slopePrime, 2);\n            } else {\n              cardinalDirectionA = this.getCardinalDirection(-slopeA, slopePrime, 3);\n              cardinalDirectionB = this.getCardinalDirection(-slopeB, slopePrime, 1);\n            }\n          } else {\n            if (p1y > p2y) {\n              cardinalDirectionA = this.getCardinalDirection(-slopeA, slopePrime, 1);\n              cardinalDirectionB = this.getCardinalDirection(-slopeB, slopePrime, 3);\n            } else {\n              cardinalDirectionA = this.getCardinalDirection(slopeA, slopePrime, 2);\n              cardinalDirectionB = this.getCardinalDirection(slopeB, slopePrime, 4);\n            }\n          } //calculate clipping Point if it is not found before\n\n\n          if (!clipPointAFound) {\n            switch (cardinalDirectionA) {\n              case 1:\n                tempPointAy = topLeftAy;\n                tempPointAx = p1x + -halfHeightA / slopePrime;\n                result[0] = tempPointAx;\n                result[1] = tempPointAy;\n                break;\n\n              case 2:\n                tempPointAx = bottomRightAx;\n                tempPointAy = p1y + halfWidthA * slopePrime;\n                result[0] = tempPointAx;\n                result[1] = tempPointAy;\n                break;\n\n              case 3:\n                tempPointAy = bottomLeftAy;\n                tempPointAx = p1x + halfHeightA / slopePrime;\n                result[0] = tempPointAx;\n                result[1] = tempPointAy;\n                break;\n\n              case 4:\n                tempPointAx = bottomLeftAx;\n                tempPointAy = p1y + -halfWidthA * slopePrime;\n                result[0] = tempPointAx;\n                result[1] = tempPointAy;\n                break;\n            }\n          }\n\n          if (!clipPointBFound) {\n            switch (cardinalDirectionB) {\n              case 1:\n                tempPointBy = topLeftBy;\n                tempPointBx = p2x + -halfHeightB / slopePrime;\n                result[2] = tempPointBx;\n                result[3] = tempPointBy;\n                break;\n\n              case 2:\n                tempPointBx = bottomRightBx;\n                tempPointBy = p2y + halfWidthB * slopePrime;\n                result[2] = tempPointBx;\n                result[3] = tempPointBy;\n                break;\n\n              case 3:\n                tempPointBy = bottomLeftBy;\n                tempPointBx = p2x + halfHeightB / slopePrime;\n                result[2] = tempPointBx;\n                result[3] = tempPointBy;\n                break;\n\n              case 4:\n                tempPointBx = bottomLeftBx;\n                tempPointBy = p2y + -halfWidthB * slopePrime;\n                result[2] = tempPointBx;\n                result[3] = tempPointBy;\n                break;\n            }\n          }\n        }\n\n        return false;\n      };\n      /**\n       * This method returns in which cardinal direction does input point stays\n       * 1: North\n       * 2: East\n       * 3: South\n       * 4: West\n       */\n\n\n      IGeometry.getCardinalDirection = function (slope, slopePrime, line) {\n        if (slope > slopePrime) {\n          return line;\n        } else {\n          return 1 + line % 4;\n        }\n      };\n      /**\n       * This method calculates the intersection of the two lines defined by\n       * point pairs (s1,s2) and (f1,f2).\n       */\n\n\n      IGeometry.getIntersection = function (s1, s2, f1, f2) {\n        if (f2 == null) {\n          return this.getIntersection2(s1, s2, f1);\n        }\n\n        var x1 = s1.x;\n        var y1 = s1.y;\n        var x2 = s2.x;\n        var y2 = s2.y;\n        var x3 = f1.x;\n        var y3 = f1.y;\n        var x4 = f2.x;\n        var y4 = f2.y;\n        var x = void 0,\n            y = void 0; // intersection point\n\n        var a1 = void 0,\n            a2 = void 0,\n            b1 = void 0,\n            b2 = void 0,\n            c1 = void 0,\n            c2 = void 0; // coefficients of line eqns.\n\n        var denom = void 0;\n        a1 = y2 - y1;\n        b1 = x1 - x2;\n        c1 = x2 * y1 - x1 * y2; // { a1*x + b1*y + c1 = 0 is line 1 }\n\n        a2 = y4 - y3;\n        b2 = x3 - x4;\n        c2 = x4 * y3 - x3 * y4; // { a2*x + b2*y + c2 = 0 is line 2 }\n\n        denom = a1 * b2 - a2 * b1;\n\n        if (denom === 0) {\n          return null;\n        }\n\n        x = (b1 * c2 - b2 * c1) / denom;\n        y = (a2 * c1 - a1 * c2) / denom;\n        return new Point(x, y);\n      };\n      /**\n       * This method finds and returns the angle of the vector from the + x-axis\n       * in clockwise direction (compatible w/ Java coordinate system!).\n       */\n\n\n      IGeometry.angleOfVector = function (Cx, Cy, Nx, Ny) {\n        var C_angle = void 0;\n\n        if (Cx !== Nx) {\n          C_angle = Math.atan((Ny - Cy) / (Nx - Cx));\n\n          if (Nx < Cx) {\n            C_angle += Math.PI;\n          } else if (Ny < Cy) {\n            C_angle += this.TWO_PI;\n          }\n        } else if (Ny < Cy) {\n          C_angle = this.ONE_AND_HALF_PI; // 270 degrees\n        } else {\n          C_angle = this.HALF_PI; // 90 degrees\n        }\n\n        return C_angle;\n      };\n      /**\n       * This method checks whether the given two line segments (one with point\n       * p1 and p2, the other with point p3 and p4) intersect at a point other\n       * than these points.\n       */\n\n\n      IGeometry.doIntersect = function (p1, p2, p3, p4) {\n        var a = p1.x;\n        var b = p1.y;\n        var c = p2.x;\n        var d = p2.y;\n        var p = p3.x;\n        var q = p3.y;\n        var r = p4.x;\n        var s = p4.y;\n        var det = (c - a) * (s - q) - (r - p) * (d - b);\n\n        if (det === 0) {\n          return false;\n        } else {\n          var lambda = ((s - q) * (r - a) + (p - r) * (s - b)) / det;\n          var gamma = ((b - d) * (r - a) + (c - a) * (s - b)) / det;\n          return 0 < lambda && lambda < 1 && 0 < gamma && gamma < 1;\n        }\n      }; // -----------------------------------------------------------------------------\n      // Section: Class Constants\n      // -----------------------------------------------------------------------------\n\n      /**\n       * Some useful pre-calculated constants\n       */\n\n\n      IGeometry.HALF_PI = 0.5 * Math.PI;\n      IGeometry.ONE_AND_HALF_PI = 1.5 * Math.PI;\n      IGeometry.TWO_PI = 2.0 * Math.PI;\n      IGeometry.THREE_PI = 3.0 * Math.PI;\n      module.exports = IGeometry;\n      /***/\n    },\n    /* 9 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function IMath() {}\n      /**\n       * This method returns the sign of the input value.\n       */\n\n\n      IMath.sign = function (value) {\n        if (value > 0) {\n          return 1;\n        } else if (value < 0) {\n          return -1;\n        } else {\n          return 0;\n        }\n      };\n\n      IMath.floor = function (value) {\n        return value < 0 ? Math.ceil(value) : Math.floor(value);\n      };\n\n      IMath.ceil = function (value) {\n        return value < 0 ? Math.floor(value) : Math.ceil(value);\n      };\n\n      module.exports = IMath;\n      /***/\n    },\n    /* 10 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function Integer() {}\n\n      Integer.MAX_VALUE = 2147483647;\n      Integer.MIN_VALUE = -2147483648;\n      module.exports = Integer;\n      /***/\n    },\n    /* 11 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n          if (protoProps) defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      var nodeFrom = function nodeFrom(value) {\n        return {\n          value: value,\n          next: null,\n          prev: null\n        };\n      };\n\n      var add = function add(prev, node, next, list) {\n        if (prev !== null) {\n          prev.next = node;\n        } else {\n          list.head = node;\n        }\n\n        if (next !== null) {\n          next.prev = node;\n        } else {\n          list.tail = node;\n        }\n\n        node.prev = prev;\n        node.next = next;\n        list.length++;\n        return node;\n      };\n\n      var _remove = function _remove(node, list) {\n        var prev = node.prev,\n            next = node.next;\n\n        if (prev !== null) {\n          prev.next = next;\n        } else {\n          list.head = next;\n        }\n\n        if (next !== null) {\n          next.prev = prev;\n        } else {\n          list.tail = prev;\n        }\n\n        node.prev = node.next = null;\n        list.length--;\n        return node;\n      };\n\n      var LinkedList = function () {\n        function LinkedList(vals) {\n          var _this = this;\n\n          _classCallCheck(this, LinkedList);\n\n          this.length = 0;\n          this.head = null;\n          this.tail = null;\n\n          if (vals != null) {\n            vals.forEach(function (v) {\n              return _this.push(v);\n            });\n          }\n        }\n\n        _createClass(LinkedList, [{\n          key: \"size\",\n          value: function size() {\n            return this.length;\n          }\n        }, {\n          key: \"insertBefore\",\n          value: function insertBefore(val, otherNode) {\n            return add(otherNode.prev, nodeFrom(val), otherNode, this);\n          }\n        }, {\n          key: \"insertAfter\",\n          value: function insertAfter(val, otherNode) {\n            return add(otherNode, nodeFrom(val), otherNode.next, this);\n          }\n        }, {\n          key: \"insertNodeBefore\",\n          value: function insertNodeBefore(newNode, otherNode) {\n            return add(otherNode.prev, newNode, otherNode, this);\n          }\n        }, {\n          key: \"insertNodeAfter\",\n          value: function insertNodeAfter(newNode, otherNode) {\n            return add(otherNode, newNode, otherNode.next, this);\n          }\n        }, {\n          key: \"push\",\n          value: function push(val) {\n            return add(this.tail, nodeFrom(val), null, this);\n          }\n        }, {\n          key: \"unshift\",\n          value: function unshift(val) {\n            return add(null, nodeFrom(val), this.head, this);\n          }\n        }, {\n          key: \"remove\",\n          value: function remove(node) {\n            return _remove(node, this);\n          }\n        }, {\n          key: \"pop\",\n          value: function pop() {\n            return _remove(this.tail, this).value;\n          }\n        }, {\n          key: \"popNode\",\n          value: function popNode() {\n            return _remove(this.tail, this);\n          }\n        }, {\n          key: \"shift\",\n          value: function shift() {\n            return _remove(this.head, this).value;\n          }\n        }, {\n          key: \"shiftNode\",\n          value: function shiftNode() {\n            return _remove(this.head, this);\n          }\n        }, {\n          key: \"get_object_at\",\n          value: function get_object_at(index) {\n            if (index <= this.length()) {\n              var i = 1;\n              var current = this.head;\n\n              while (i < index) {\n                current = current.next;\n                i++;\n              }\n\n              return current.value;\n            }\n          }\n        }, {\n          key: \"set_object_at\",\n          value: function set_object_at(index, value) {\n            if (index <= this.length()) {\n              var i = 1;\n              var current = this.head;\n\n              while (i < index) {\n                current = current.next;\n                i++;\n              }\n\n              current.value = value;\n            }\n          }\n        }]);\n\n        return LinkedList;\n      }();\n\n      module.exports = LinkedList;\n      /***/\n    },\n    /* 12 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n      /*\r\n       *This class is the javascript implementation of the Point.java class in jdk\r\n       */\n\n      function Point(x, y, p) {\n        this.x = null;\n        this.y = null;\n\n        if (x == null && y == null && p == null) {\n          this.x = 0;\n          this.y = 0;\n        } else if (typeof x == 'number' && typeof y == 'number' && p == null) {\n          this.x = x;\n          this.y = y;\n        } else if (x.constructor.name == 'Point' && y == null && p == null) {\n          p = x;\n          this.x = p.x;\n          this.y = p.y;\n        }\n      }\n\n      Point.prototype.getX = function () {\n        return this.x;\n      };\n\n      Point.prototype.getY = function () {\n        return this.y;\n      };\n\n      Point.prototype.getLocation = function () {\n        return new Point(this.x, this.y);\n      };\n\n      Point.prototype.setLocation = function (x, y, p) {\n        if (x.constructor.name == 'Point' && y == null && p == null) {\n          p = x;\n          this.setLocation(p.x, p.y);\n        } else if (typeof x == 'number' && typeof y == 'number' && p == null) {\n          //if both parameters are integer just move (x,y) location\n          if (parseInt(x) == x && parseInt(y) == y) {\n            this.move(x, y);\n          } else {\n            this.x = Math.floor(x + 0.5);\n            this.y = Math.floor(y + 0.5);\n          }\n        }\n      };\n\n      Point.prototype.move = function (x, y) {\n        this.x = x;\n        this.y = y;\n      };\n\n      Point.prototype.translate = function (dx, dy) {\n        this.x += dx;\n        this.y += dy;\n      };\n\n      Point.prototype.equals = function (obj) {\n        if (obj.constructor.name == \"Point\") {\n          var pt = obj;\n          return this.x == pt.x && this.y == pt.y;\n        }\n\n        return this == obj;\n      };\n\n      Point.prototype.toString = function () {\n        return new Point().constructor.name + \"[x=\" + this.x + \",y=\" + this.y + \"]\";\n      };\n\n      module.exports = Point;\n      /***/\n    },\n    /* 13 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function RectangleD(x, y, width, height) {\n        this.x = 0;\n        this.y = 0;\n        this.width = 0;\n        this.height = 0;\n\n        if (x != null && y != null && width != null && height != null) {\n          this.x = x;\n          this.y = y;\n          this.width = width;\n          this.height = height;\n        }\n      }\n\n      RectangleD.prototype.getX = function () {\n        return this.x;\n      };\n\n      RectangleD.prototype.setX = function (x) {\n        this.x = x;\n      };\n\n      RectangleD.prototype.getY = function () {\n        return this.y;\n      };\n\n      RectangleD.prototype.setY = function (y) {\n        this.y = y;\n      };\n\n      RectangleD.prototype.getWidth = function () {\n        return this.width;\n      };\n\n      RectangleD.prototype.setWidth = function (width) {\n        this.width = width;\n      };\n\n      RectangleD.prototype.getHeight = function () {\n        return this.height;\n      };\n\n      RectangleD.prototype.setHeight = function (height) {\n        this.height = height;\n      };\n\n      RectangleD.prototype.getRight = function () {\n        return this.x + this.width;\n      };\n\n      RectangleD.prototype.getBottom = function () {\n        return this.y + this.height;\n      };\n\n      RectangleD.prototype.intersects = function (a) {\n        if (this.getRight() < a.x) {\n          return false;\n        }\n\n        if (this.getBottom() < a.y) {\n          return false;\n        }\n\n        if (a.getRight() < this.x) {\n          return false;\n        }\n\n        if (a.getBottom() < this.y) {\n          return false;\n        }\n\n        return true;\n      };\n\n      RectangleD.prototype.getCenterX = function () {\n        return this.x + this.width / 2;\n      };\n\n      RectangleD.prototype.getMinX = function () {\n        return this.getX();\n      };\n\n      RectangleD.prototype.getMaxX = function () {\n        return this.getX() + this.width;\n      };\n\n      RectangleD.prototype.getCenterY = function () {\n        return this.y + this.height / 2;\n      };\n\n      RectangleD.prototype.getMinY = function () {\n        return this.getY();\n      };\n\n      RectangleD.prototype.getMaxY = function () {\n        return this.getY() + this.height;\n      };\n\n      RectangleD.prototype.getWidthHalf = function () {\n        return this.width / 2;\n      };\n\n      RectangleD.prototype.getHeightHalf = function () {\n        return this.height / 2;\n      };\n\n      module.exports = RectangleD;\n      /***/\n    },\n    /* 14 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n        return typeof obj;\n      } : function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n\n      function UniqueIDGeneretor() {}\n\n      UniqueIDGeneretor.lastID = 0;\n\n      UniqueIDGeneretor.createID = function (obj) {\n        if (UniqueIDGeneretor.isPrimitive(obj)) {\n          return obj;\n        }\n\n        if (obj.uniqueID != null) {\n          return obj.uniqueID;\n        }\n\n        obj.uniqueID = UniqueIDGeneretor.getString();\n        UniqueIDGeneretor.lastID++;\n        return obj.uniqueID;\n      };\n\n      UniqueIDGeneretor.getString = function (id) {\n        if (id == null) id = UniqueIDGeneretor.lastID;\n        return \"Object#\" + id + \"\";\n      };\n\n      UniqueIDGeneretor.isPrimitive = function (arg) {\n        var type = typeof arg === \"undefined\" ? \"undefined\" : _typeof(arg);\n        return arg == null || type != \"object\" && type != \"function\";\n      };\n\n      module.exports = UniqueIDGeneretor;\n      /***/\n    },\n    /* 15 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _toConsumableArray(arr) {\n        if (Array.isArray(arr)) {\n          for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n            arr2[i] = arr[i];\n          }\n\n          return arr2;\n        } else {\n          return Array.from(arr);\n        }\n      }\n\n      var LayoutConstants = __webpack_require__(0);\n\n      var LGraphManager = __webpack_require__(6);\n\n      var LNode = __webpack_require__(3);\n\n      var LEdge = __webpack_require__(1);\n\n      var LGraph = __webpack_require__(5);\n\n      var PointD = __webpack_require__(4);\n\n      var Transform = __webpack_require__(17);\n\n      var Emitter = __webpack_require__(27);\n\n      function Layout(isRemoteUse) {\n        Emitter.call(this); //Layout Quality: 0:draft, 1:default, 2:proof\n\n        this.layoutQuality = LayoutConstants.QUALITY; //Whether layout should create bendpoints as needed or not\n\n        this.createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED; //Whether layout should be incremental or not\n\n        this.incremental = LayoutConstants.DEFAULT_INCREMENTAL; //Whether we animate from before to after layout node positions\n\n        this.animationOnLayout = LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT; //Whether we animate the layout process or not\n\n        this.animationDuringLayout = LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT; //Number iterations that should be done between two successive animations\n\n        this.animationPeriod = LayoutConstants.DEFAULT_ANIMATION_PERIOD;\n        /**\r\n         * Whether or not leaf nodes (non-compound nodes) are of uniform sizes. When\r\n         * they are, both spring and repulsion forces between two leaf nodes can be\r\n         * calculated without the expensive clipping point calculations, resulting\r\n         * in major speed-up.\r\n         */\n\n        this.uniformLeafNodeSizes = LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES;\n        /**\r\n         * This is used for creation of bendpoints by using dummy nodes and edges.\r\n         * Maps an LEdge to its dummy bendpoint path.\r\n         */\n\n        this.edgeToDummyNodes = new Map();\n        this.graphManager = new LGraphManager(this);\n        this.isLayoutFinished = false;\n        this.isSubLayout = false;\n        this.isRemoteUse = false;\n\n        if (isRemoteUse != null) {\n          this.isRemoteUse = isRemoteUse;\n        }\n      }\n\n      Layout.RANDOM_SEED = 1;\n      Layout.prototype = Object.create(Emitter.prototype);\n\n      Layout.prototype.getGraphManager = function () {\n        return this.graphManager;\n      };\n\n      Layout.prototype.getAllNodes = function () {\n        return this.graphManager.getAllNodes();\n      };\n\n      Layout.prototype.getAllEdges = function () {\n        return this.graphManager.getAllEdges();\n      };\n\n      Layout.prototype.getAllNodesToApplyGravitation = function () {\n        return this.graphManager.getAllNodesToApplyGravitation();\n      };\n\n      Layout.prototype.newGraphManager = function () {\n        var gm = new LGraphManager(this);\n        this.graphManager = gm;\n        return gm;\n      };\n\n      Layout.prototype.newGraph = function (vGraph) {\n        return new LGraph(null, this.graphManager, vGraph);\n      };\n\n      Layout.prototype.newNode = function (vNode) {\n        return new LNode(this.graphManager, vNode);\n      };\n\n      Layout.prototype.newEdge = function (vEdge) {\n        return new LEdge(null, null, vEdge);\n      };\n\n      Layout.prototype.checkLayoutSuccess = function () {\n        return this.graphManager.getRoot() == null || this.graphManager.getRoot().getNodes().length == 0 || this.graphManager.includesInvalidEdge();\n      };\n\n      Layout.prototype.runLayout = function () {\n        this.isLayoutFinished = false;\n\n        if (this.tilingPreLayout) {\n          this.tilingPreLayout();\n        }\n\n        this.initParameters();\n        var isLayoutSuccessfull;\n\n        if (this.checkLayoutSuccess()) {\n          isLayoutSuccessfull = false;\n        } else {\n          isLayoutSuccessfull = this.layout();\n        }\n\n        if (LayoutConstants.ANIMATE === 'during') {\n          // If this is a 'during' layout animation. Layout is not finished yet. \n          // We need to perform these in index.js when layout is really finished.\n          return false;\n        }\n\n        if (isLayoutSuccessfull) {\n          if (!this.isSubLayout) {\n            this.doPostLayout();\n          }\n        }\n\n        if (this.tilingPostLayout) {\n          this.tilingPostLayout();\n        }\n\n        this.isLayoutFinished = true;\n        return isLayoutSuccessfull;\n      };\n      /**\r\n       * This method performs the operations required after layout.\r\n       */\n\n\n      Layout.prototype.doPostLayout = function () {\n        //assert !isSubLayout : \"Should not be called on sub-layout!\";\n        // Propagate geometric changes to v-level objects\n        if (!this.incremental) {\n          this.transform();\n        }\n\n        this.update();\n      };\n      /**\r\n       * This method updates the geometry of the target graph according to\r\n       * calculated layout.\r\n       */\n\n\n      Layout.prototype.update2 = function () {\n        // update bend points\n        if (this.createBendsAsNeeded) {\n          this.createBendpointsFromDummyNodes(); // reset all edges, since the topology has changed\n\n          this.graphManager.resetAllEdges();\n        } // perform edge, node and root updates if layout is not called\n        // remotely\n\n\n        if (!this.isRemoteUse) {\n          // update all edges\n          var edge;\n          var allEdges = this.graphManager.getAllEdges();\n\n          for (var i = 0; i < allEdges.length; i++) {\n            edge = allEdges[i]; //      this.update(edge);\n          } // recursively update nodes\n\n\n          var node;\n          var nodes = this.graphManager.getRoot().getNodes();\n\n          for (var i = 0; i < nodes.length; i++) {\n            node = nodes[i]; //      this.update(node);\n          } // update root graph\n\n\n          this.update(this.graphManager.getRoot());\n        }\n      };\n\n      Layout.prototype.update = function (obj) {\n        if (obj == null) {\n          this.update2();\n        } else if (obj instanceof LNode) {\n          var node = obj;\n\n          if (node.getChild() != null) {\n            // since node is compound, recursively update child nodes\n            var nodes = node.getChild().getNodes();\n\n            for (var i = 0; i < nodes.length; i++) {\n              update(nodes[i]);\n            }\n          } // if the l-level node is associated with a v-level graph object,\n          // then it is assumed that the v-level node implements the\n          // interface Updatable.\n\n\n          if (node.vGraphObject != null) {\n            // cast to Updatable without any type check\n            var vNode = node.vGraphObject; // call the update method of the interface\n\n            vNode.update(node);\n          }\n        } else if (obj instanceof LEdge) {\n          var edge = obj; // if the l-level edge is associated with a v-level graph object,\n          // then it is assumed that the v-level edge implements the\n          // interface Updatable.\n\n          if (edge.vGraphObject != null) {\n            // cast to Updatable without any type check\n            var vEdge = edge.vGraphObject; // call the update method of the interface\n\n            vEdge.update(edge);\n          }\n        } else if (obj instanceof LGraph) {\n          var graph = obj; // if the l-level graph is associated with a v-level graph object,\n          // then it is assumed that the v-level object implements the\n          // interface Updatable.\n\n          if (graph.vGraphObject != null) {\n            // cast to Updatable without any type check\n            var vGraph = graph.vGraphObject; // call the update method of the interface\n\n            vGraph.update(graph);\n          }\n        }\n      };\n      /**\r\n       * This method is used to set all layout parameters to default values\r\n       * determined at compile time.\r\n       */\n\n\n      Layout.prototype.initParameters = function () {\n        if (!this.isSubLayout) {\n          this.layoutQuality = LayoutConstants.QUALITY;\n          this.animationDuringLayout = LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT;\n          this.animationPeriod = LayoutConstants.DEFAULT_ANIMATION_PERIOD;\n          this.animationOnLayout = LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT;\n          this.incremental = LayoutConstants.DEFAULT_INCREMENTAL;\n          this.createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n          this.uniformLeafNodeSizes = LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES;\n        }\n\n        if (this.animationDuringLayout) {\n          this.animationOnLayout = false;\n        }\n      };\n\n      Layout.prototype.transform = function (newLeftTop) {\n        if (newLeftTop == undefined) {\n          this.transform(new PointD(0, 0));\n        } else {\n          // create a transformation object (from Eclipse to layout). When an\n          // inverse transform is applied, we get upper-left coordinate of the\n          // drawing or the root graph at given input coordinate (some margins\n          // already included in calculation of left-top).\n          var trans = new Transform();\n          var leftTop = this.graphManager.getRoot().updateLeftTop();\n\n          if (leftTop != null) {\n            trans.setWorldOrgX(newLeftTop.x);\n            trans.setWorldOrgY(newLeftTop.y);\n            trans.setDeviceOrgX(leftTop.x);\n            trans.setDeviceOrgY(leftTop.y);\n            var nodes = this.getAllNodes();\n            var node;\n\n            for (var i = 0; i < nodes.length; i++) {\n              node = nodes[i];\n              node.transform(trans);\n            }\n          }\n        }\n      };\n\n      Layout.prototype.positionNodesRandomly = function (graph) {\n        if (graph == undefined) {\n          //assert !this.incremental;\n          this.positionNodesRandomly(this.getGraphManager().getRoot());\n          this.getGraphManager().getRoot().updateBounds(true);\n        } else {\n          var lNode;\n          var childGraph;\n          var nodes = graph.getNodes();\n\n          for (var i = 0; i < nodes.length; i++) {\n            lNode = nodes[i];\n            childGraph = lNode.getChild();\n\n            if (childGraph == null) {\n              lNode.scatter();\n            } else if (childGraph.getNodes().length == 0) {\n              lNode.scatter();\n            } else {\n              this.positionNodesRandomly(childGraph);\n              lNode.updateBounds();\n            }\n          }\n        }\n      };\n      /**\r\n       * This method returns a list of trees where each tree is represented as a\r\n       * list of l-nodes. The method returns a list of size 0 when:\r\n       * - The graph is not flat or\r\n       * - One of the component(s) of the graph is not a tree.\r\n       */\n\n\n      Layout.prototype.getFlatForest = function () {\n        var flatForest = [];\n        var isForest = true; // Quick reference for all nodes in the graph manager associated with\n        // this layout. The list should not be changed.\n\n        var allNodes = this.graphManager.getRoot().getNodes(); // First be sure that the graph is flat\n\n        var isFlat = true;\n\n        for (var i = 0; i < allNodes.length; i++) {\n          if (allNodes[i].getChild() != null) {\n            isFlat = false;\n          }\n        } // Return empty forest if the graph is not flat.\n\n\n        if (!isFlat) {\n          return flatForest;\n        } // Run BFS for each component of the graph.\n\n\n        var visited = new Set();\n        var toBeVisited = [];\n        var parents = new Map();\n        var unProcessedNodes = [];\n        unProcessedNodes = unProcessedNodes.concat(allNodes); // Each iteration of this loop finds a component of the graph and\n        // decides whether it is a tree or not. If it is a tree, adds it to the\n        // forest and continued with the next component.\n\n        while (unProcessedNodes.length > 0 && isForest) {\n          toBeVisited.push(unProcessedNodes[0]); // Start the BFS. Each iteration of this loop visits a node in a\n          // BFS manner.\n\n          while (toBeVisited.length > 0 && isForest) {\n            //pool operation\n            var currentNode = toBeVisited[0];\n            toBeVisited.splice(0, 1);\n            visited.add(currentNode); // Traverse all neighbors of this node\n\n            var neighborEdges = currentNode.getEdges();\n\n            for (var i = 0; i < neighborEdges.length; i++) {\n              var currentNeighbor = neighborEdges[i].getOtherEnd(currentNode); // If BFS is not growing from this neighbor.\n\n              if (parents.get(currentNode) != currentNeighbor) {\n                // We haven't previously visited this neighbor.\n                if (!visited.has(currentNeighbor)) {\n                  toBeVisited.push(currentNeighbor);\n                  parents.set(currentNeighbor, currentNode);\n                } // Since we have previously visited this neighbor and\n                // this neighbor is not parent of currentNode, given\n                // graph contains a component that is not tree, hence\n                // it is not a forest.\n                else {\n                  isForest = false;\n                  break;\n                }\n              }\n            }\n          } // The graph contains a component that is not a tree. Empty\n          // previously found trees. The method will end.\n\n\n          if (!isForest) {\n            flatForest = [];\n          } // Save currently visited nodes as a tree in our forest. Reset\n          // visited and parents lists. Continue with the next component of\n          // the graph, if any.\n          else {\n            var temp = [].concat(_toConsumableArray(visited));\n            flatForest.push(temp); //flatForest = flatForest.concat(temp);\n            //unProcessedNodes.removeAll(visited);\n\n            for (var i = 0; i < temp.length; i++) {\n              var value = temp[i];\n              var index = unProcessedNodes.indexOf(value);\n\n              if (index > -1) {\n                unProcessedNodes.splice(index, 1);\n              }\n            }\n\n            visited = new Set();\n            parents = new Map();\n          }\n        }\n\n        return flatForest;\n      };\n      /**\r\n       * This method creates dummy nodes (an l-level node with minimal dimensions)\r\n       * for the given edge (one per bendpoint). The existing l-level structure\r\n       * is updated accordingly.\r\n       */\n\n\n      Layout.prototype.createDummyNodesForBendpoints = function (edge) {\n        var dummyNodes = [];\n        var prev = edge.source;\n        var graph = this.graphManager.calcLowestCommonAncestor(edge.source, edge.target);\n\n        for (var i = 0; i < edge.bendpoints.length; i++) {\n          // create new dummy node\n          var dummyNode = this.newNode(null);\n          dummyNode.setRect(new Point(0, 0), new Dimension(1, 1));\n          graph.add(dummyNode); // create new dummy edge between prev and dummy node\n\n          var dummyEdge = this.newEdge(null);\n          this.graphManager.add(dummyEdge, prev, dummyNode);\n          dummyNodes.add(dummyNode);\n          prev = dummyNode;\n        }\n\n        var dummyEdge = this.newEdge(null);\n        this.graphManager.add(dummyEdge, prev, edge.target);\n        this.edgeToDummyNodes.set(edge, dummyNodes); // remove real edge from graph manager if it is inter-graph\n\n        if (edge.isInterGraph()) {\n          this.graphManager.remove(edge);\n        } // else, remove the edge from the current graph\n        else {\n          graph.remove(edge);\n        }\n\n        return dummyNodes;\n      };\n      /**\r\n       * This method creates bendpoints for edges from the dummy nodes\r\n       * at l-level.\r\n       */\n\n\n      Layout.prototype.createBendpointsFromDummyNodes = function () {\n        var edges = [];\n        edges = edges.concat(this.graphManager.getAllEdges());\n        edges = [].concat(_toConsumableArray(this.edgeToDummyNodes.keys())).concat(edges);\n\n        for (var k = 0; k < edges.length; k++) {\n          var lEdge = edges[k];\n\n          if (lEdge.bendpoints.length > 0) {\n            var path = this.edgeToDummyNodes.get(lEdge);\n\n            for (var i = 0; i < path.length; i++) {\n              var dummyNode = path[i];\n              var p = new PointD(dummyNode.getCenterX(), dummyNode.getCenterY()); // update bendpoint's location according to dummy node\n\n              var ebp = lEdge.bendpoints.get(i);\n              ebp.x = p.x;\n              ebp.y = p.y; // remove the dummy node, dummy edges incident with this\n              // dummy node is also removed (within the remove method)\n\n              dummyNode.getOwner().remove(dummyNode);\n            } // add the real edge to graph\n\n\n            this.graphManager.add(lEdge, lEdge.source, lEdge.target);\n          }\n        }\n      };\n\n      Layout.transform = function (sliderValue, defaultValue, minDiv, maxMul) {\n        if (minDiv != undefined && maxMul != undefined) {\n          var value = defaultValue;\n\n          if (sliderValue <= 50) {\n            var minValue = defaultValue / minDiv;\n            value -= (defaultValue - minValue) / 50 * (50 - sliderValue);\n          } else {\n            var maxValue = defaultValue * maxMul;\n            value += (maxValue - defaultValue) / 50 * (sliderValue - 50);\n          }\n\n          return value;\n        } else {\n          var a, b;\n\n          if (sliderValue <= 50) {\n            a = 9.0 * defaultValue / 500.0;\n            b = defaultValue / 10.0;\n          } else {\n            a = 9.0 * defaultValue / 50.0;\n            b = -8 * defaultValue;\n          }\n\n          return a * sliderValue + b;\n        }\n      };\n      /**\r\n       * This method finds and returns the center of the given nodes, assuming\r\n       * that the given nodes form a tree in themselves.\r\n       */\n\n\n      Layout.findCenterOfTree = function (nodes) {\n        var list = [];\n        list = list.concat(nodes);\n        var removedNodes = [];\n        var remainingDegrees = new Map();\n        var foundCenter = false;\n        var centerNode = null;\n\n        if (list.length == 1 || list.length == 2) {\n          foundCenter = true;\n          centerNode = list[0];\n        }\n\n        for (var i = 0; i < list.length; i++) {\n          var node = list[i];\n          var degree = node.getNeighborsList().size;\n          remainingDegrees.set(node, node.getNeighborsList().size);\n\n          if (degree == 1) {\n            removedNodes.push(node);\n          }\n        }\n\n        var tempList = [];\n        tempList = tempList.concat(removedNodes);\n\n        while (!foundCenter) {\n          var tempList2 = [];\n          tempList2 = tempList2.concat(tempList);\n          tempList = [];\n\n          for (var i = 0; i < list.length; i++) {\n            var node = list[i];\n            var index = list.indexOf(node);\n\n            if (index >= 0) {\n              list.splice(index, 1);\n            }\n\n            var neighbours = node.getNeighborsList();\n            neighbours.forEach(function (neighbour) {\n              if (removedNodes.indexOf(neighbour) < 0) {\n                var otherDegree = remainingDegrees.get(neighbour);\n                var newDegree = otherDegree - 1;\n\n                if (newDegree == 1) {\n                  tempList.push(neighbour);\n                }\n\n                remainingDegrees.set(neighbour, newDegree);\n              }\n            });\n          }\n\n          removedNodes = removedNodes.concat(tempList);\n\n          if (list.length == 1 || list.length == 2) {\n            foundCenter = true;\n            centerNode = list[0];\n          }\n        }\n\n        return centerNode;\n      };\n      /**\r\n       * During the coarsening process, this layout may be referenced by two graph managers\r\n       * this setter function grants access to change the currently being used graph manager\r\n       */\n\n\n      Layout.prototype.setGraphManager = function (gm) {\n        this.graphManager = gm;\n      };\n\n      module.exports = Layout;\n      /***/\n    },\n    /* 16 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function RandomSeed() {} // adapted from: https://stackoverflow.com/a/19303725\n\n\n      RandomSeed.seed = 1;\n      RandomSeed.x = 0;\n\n      RandomSeed.nextDouble = function () {\n        RandomSeed.x = Math.sin(RandomSeed.seed++) * 10000;\n        return RandomSeed.x - Math.floor(RandomSeed.x);\n      };\n\n      module.exports = RandomSeed;\n      /***/\n    },\n    /* 17 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var PointD = __webpack_require__(4);\n\n      function Transform(x, y) {\n        this.lworldOrgX = 0.0;\n        this.lworldOrgY = 0.0;\n        this.ldeviceOrgX = 0.0;\n        this.ldeviceOrgY = 0.0;\n        this.lworldExtX = 1.0;\n        this.lworldExtY = 1.0;\n        this.ldeviceExtX = 1.0;\n        this.ldeviceExtY = 1.0;\n      }\n\n      Transform.prototype.getWorldOrgX = function () {\n        return this.lworldOrgX;\n      };\n\n      Transform.prototype.setWorldOrgX = function (wox) {\n        this.lworldOrgX = wox;\n      };\n\n      Transform.prototype.getWorldOrgY = function () {\n        return this.lworldOrgY;\n      };\n\n      Transform.prototype.setWorldOrgY = function (woy) {\n        this.lworldOrgY = woy;\n      };\n\n      Transform.prototype.getWorldExtX = function () {\n        return this.lworldExtX;\n      };\n\n      Transform.prototype.setWorldExtX = function (wex) {\n        this.lworldExtX = wex;\n      };\n\n      Transform.prototype.getWorldExtY = function () {\n        return this.lworldExtY;\n      };\n\n      Transform.prototype.setWorldExtY = function (wey) {\n        this.lworldExtY = wey;\n      };\n      /* Device related */\n\n\n      Transform.prototype.getDeviceOrgX = function () {\n        return this.ldeviceOrgX;\n      };\n\n      Transform.prototype.setDeviceOrgX = function (dox) {\n        this.ldeviceOrgX = dox;\n      };\n\n      Transform.prototype.getDeviceOrgY = function () {\n        return this.ldeviceOrgY;\n      };\n\n      Transform.prototype.setDeviceOrgY = function (doy) {\n        this.ldeviceOrgY = doy;\n      };\n\n      Transform.prototype.getDeviceExtX = function () {\n        return this.ldeviceExtX;\n      };\n\n      Transform.prototype.setDeviceExtX = function (dex) {\n        this.ldeviceExtX = dex;\n      };\n\n      Transform.prototype.getDeviceExtY = function () {\n        return this.ldeviceExtY;\n      };\n\n      Transform.prototype.setDeviceExtY = function (dey) {\n        this.ldeviceExtY = dey;\n      };\n\n      Transform.prototype.transformX = function (x) {\n        var xDevice = 0.0;\n        var worldExtX = this.lworldExtX;\n\n        if (worldExtX != 0.0) {\n          xDevice = this.ldeviceOrgX + (x - this.lworldOrgX) * this.ldeviceExtX / worldExtX;\n        }\n\n        return xDevice;\n      };\n\n      Transform.prototype.transformY = function (y) {\n        var yDevice = 0.0;\n        var worldExtY = this.lworldExtY;\n\n        if (worldExtY != 0.0) {\n          yDevice = this.ldeviceOrgY + (y - this.lworldOrgY) * this.ldeviceExtY / worldExtY;\n        }\n\n        return yDevice;\n      };\n\n      Transform.prototype.inverseTransformX = function (x) {\n        var xWorld = 0.0;\n        var deviceExtX = this.ldeviceExtX;\n\n        if (deviceExtX != 0.0) {\n          xWorld = this.lworldOrgX + (x - this.ldeviceOrgX) * this.lworldExtX / deviceExtX;\n        }\n\n        return xWorld;\n      };\n\n      Transform.prototype.inverseTransformY = function (y) {\n        var yWorld = 0.0;\n        var deviceExtY = this.ldeviceExtY;\n\n        if (deviceExtY != 0.0) {\n          yWorld = this.lworldOrgY + (y - this.ldeviceOrgY) * this.lworldExtY / deviceExtY;\n        }\n\n        return yWorld;\n      };\n\n      Transform.prototype.inverseTransformPoint = function (inPoint) {\n        var outPoint = new PointD(this.inverseTransformX(inPoint.x), this.inverseTransformY(inPoint.y));\n        return outPoint;\n      };\n\n      module.exports = Transform;\n      /***/\n    },\n    /* 18 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _toConsumableArray(arr) {\n        if (Array.isArray(arr)) {\n          for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n            arr2[i] = arr[i];\n          }\n\n          return arr2;\n        } else {\n          return Array.from(arr);\n        }\n      }\n\n      var Layout = __webpack_require__(15);\n\n      var FDLayoutConstants = __webpack_require__(7);\n\n      var LayoutConstants = __webpack_require__(0);\n\n      var IGeometry = __webpack_require__(8);\n\n      var IMath = __webpack_require__(9);\n\n      function FDLayout() {\n        Layout.call(this);\n        this.useSmartIdealEdgeLengthCalculation = FDLayoutConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION;\n        this.idealEdgeLength = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n        this.springConstant = FDLayoutConstants.DEFAULT_SPRING_STRENGTH;\n        this.repulsionConstant = FDLayoutConstants.DEFAULT_REPULSION_STRENGTH;\n        this.gravityConstant = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH;\n        this.compoundGravityConstant = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH;\n        this.gravityRangeFactor = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR;\n        this.compoundGravityRangeFactor = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR;\n        this.displacementThresholdPerNode = 3.0 * FDLayoutConstants.DEFAULT_EDGE_LENGTH / 100;\n        this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n        this.initialCoolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n        this.totalDisplacement = 0.0;\n        this.oldTotalDisplacement = 0.0;\n        this.maxIterations = FDLayoutConstants.MAX_ITERATIONS;\n      }\n\n      FDLayout.prototype = Object.create(Layout.prototype);\n\n      for (var prop in Layout) {\n        FDLayout[prop] = Layout[prop];\n      }\n\n      FDLayout.prototype.initParameters = function () {\n        Layout.prototype.initParameters.call(this, arguments);\n        this.totalIterations = 0;\n        this.notAnimatedIterations = 0;\n        this.useFRGridVariant = FDLayoutConstants.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION;\n        this.grid = [];\n      };\n\n      FDLayout.prototype.calcIdealEdgeLengths = function () {\n        var edge;\n        var lcaDepth;\n        var source;\n        var target;\n        var sizeOfSourceInLca;\n        var sizeOfTargetInLca;\n        var allEdges = this.getGraphManager().getAllEdges();\n\n        for (var i = 0; i < allEdges.length; i++) {\n          edge = allEdges[i];\n          edge.idealLength = this.idealEdgeLength;\n\n          if (edge.isInterGraph) {\n            source = edge.getSource();\n            target = edge.getTarget();\n            sizeOfSourceInLca = edge.getSourceInLca().getEstimatedSize();\n            sizeOfTargetInLca = edge.getTargetInLca().getEstimatedSize();\n\n            if (this.useSmartIdealEdgeLengthCalculation) {\n              edge.idealLength += sizeOfSourceInLca + sizeOfTargetInLca - 2 * LayoutConstants.SIMPLE_NODE_SIZE;\n            }\n\n            lcaDepth = edge.getLca().getInclusionTreeDepth();\n            edge.idealLength += FDLayoutConstants.DEFAULT_EDGE_LENGTH * FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR * (source.getInclusionTreeDepth() + target.getInclusionTreeDepth() - 2 * lcaDepth);\n          }\n        }\n      };\n\n      FDLayout.prototype.initSpringEmbedder = function () {\n        var s = this.getAllNodes().length;\n\n        if (this.incremental) {\n          if (s > FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) {\n            this.coolingFactor = Math.max(this.coolingFactor * FDLayoutConstants.COOLING_ADAPTATION_FACTOR, this.coolingFactor - (s - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) / (FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) * this.coolingFactor * (1 - FDLayoutConstants.COOLING_ADAPTATION_FACTOR));\n          }\n\n          this.maxNodeDisplacement = FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL;\n        } else {\n          if (s > FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) {\n            this.coolingFactor = Math.max(FDLayoutConstants.COOLING_ADAPTATION_FACTOR, 1.0 - (s - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) / (FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) * (1 - FDLayoutConstants.COOLING_ADAPTATION_FACTOR));\n          } else {\n            this.coolingFactor = 1.0;\n          }\n\n          this.initialCoolingFactor = this.coolingFactor;\n          this.maxNodeDisplacement = FDLayoutConstants.MAX_NODE_DISPLACEMENT;\n        }\n\n        this.maxIterations = Math.max(this.getAllNodes().length * 5, this.maxIterations);\n        this.totalDisplacementThreshold = this.displacementThresholdPerNode * this.getAllNodes().length;\n        this.repulsionRange = this.calcRepulsionRange();\n      };\n\n      FDLayout.prototype.calcSpringForces = function () {\n        var lEdges = this.getAllEdges();\n        var edge;\n\n        for (var i = 0; i < lEdges.length; i++) {\n          edge = lEdges[i];\n          this.calcSpringForce(edge, edge.idealLength);\n        }\n      };\n\n      FDLayout.prototype.calcRepulsionForces = function () {\n        var gridUpdateAllowed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        var forceToNodeSurroundingUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        var i, j;\n        var nodeA, nodeB;\n        var lNodes = this.getAllNodes();\n        var processedNodeSet;\n\n        if (this.useFRGridVariant) {\n          if (this.totalIterations % FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD == 1 && gridUpdateAllowed) {\n            this.updateGrid();\n          }\n\n          processedNodeSet = new Set(); // calculate repulsion forces between each nodes and its surrounding\n\n          for (i = 0; i < lNodes.length; i++) {\n            nodeA = lNodes[i];\n            this.calculateRepulsionForceOfANode(nodeA, processedNodeSet, gridUpdateAllowed, forceToNodeSurroundingUpdate);\n            processedNodeSet.add(nodeA);\n          }\n        } else {\n          for (i = 0; i < lNodes.length; i++) {\n            nodeA = lNodes[i];\n\n            for (j = i + 1; j < lNodes.length; j++) {\n              nodeB = lNodes[j]; // If both nodes are not members of the same graph, skip.\n\n              if (nodeA.getOwner() != nodeB.getOwner()) {\n                continue;\n              }\n\n              this.calcRepulsionForce(nodeA, nodeB);\n            }\n          }\n        }\n      };\n\n      FDLayout.prototype.calcGravitationalForces = function () {\n        var node;\n        var lNodes = this.getAllNodesToApplyGravitation();\n\n        for (var i = 0; i < lNodes.length; i++) {\n          node = lNodes[i];\n          this.calcGravitationalForce(node);\n        }\n      };\n\n      FDLayout.prototype.moveNodes = function () {\n        var lNodes = this.getAllNodes();\n        var node;\n\n        for (var i = 0; i < lNodes.length; i++) {\n          node = lNodes[i];\n          node.move();\n        }\n      };\n\n      FDLayout.prototype.calcSpringForce = function (edge, idealLength) {\n        var sourceNode = edge.getSource();\n        var targetNode = edge.getTarget();\n        var length;\n        var springForce;\n        var springForceX;\n        var springForceY; // Update edge length\n\n        if (this.uniformLeafNodeSizes && sourceNode.getChild() == null && targetNode.getChild() == null) {\n          edge.updateLengthSimple();\n        } else {\n          edge.updateLength();\n\n          if (edge.isOverlapingSourceAndTarget) {\n            return;\n          }\n        }\n\n        length = edge.getLength();\n        if (length == 0) return; // Calculate spring forces\n\n        springForce = this.springConstant * (length - idealLength); // Project force onto x and y axes\n\n        springForceX = springForce * (edge.lengthX / length);\n        springForceY = springForce * (edge.lengthY / length); // Apply forces on the end nodes\n\n        sourceNode.springForceX += springForceX;\n        sourceNode.springForceY += springForceY;\n        targetNode.springForceX -= springForceX;\n        targetNode.springForceY -= springForceY;\n      };\n\n      FDLayout.prototype.calcRepulsionForce = function (nodeA, nodeB) {\n        var rectA = nodeA.getRect();\n        var rectB = nodeB.getRect();\n        var overlapAmount = new Array(2);\n        var clipPoints = new Array(4);\n        var distanceX;\n        var distanceY;\n        var distanceSquared;\n        var distance;\n        var repulsionForce;\n        var repulsionForceX;\n        var repulsionForceY;\n\n        if (rectA.intersects(rectB)) // two nodes overlap\n          {\n            // calculate separation amount in x and y directions\n            IGeometry.calcSeparationAmount(rectA, rectB, overlapAmount, FDLayoutConstants.DEFAULT_EDGE_LENGTH / 2.0);\n            repulsionForceX = 2 * overlapAmount[0];\n            repulsionForceY = 2 * overlapAmount[1];\n            var childrenConstant = nodeA.noOfChildren * nodeB.noOfChildren / (nodeA.noOfChildren + nodeB.noOfChildren); // Apply forces on the two nodes\n\n            nodeA.repulsionForceX -= childrenConstant * repulsionForceX;\n            nodeA.repulsionForceY -= childrenConstant * repulsionForceY;\n            nodeB.repulsionForceX += childrenConstant * repulsionForceX;\n            nodeB.repulsionForceY += childrenConstant * repulsionForceY;\n          } else // no overlap\n          {\n            // calculate distance\n            if (this.uniformLeafNodeSizes && nodeA.getChild() == null && nodeB.getChild() == null) // simply base repulsion on distance of node centers\n              {\n                distanceX = rectB.getCenterX() - rectA.getCenterX();\n                distanceY = rectB.getCenterY() - rectA.getCenterY();\n              } else // use clipping points\n              {\n                IGeometry.getIntersection(rectA, rectB, clipPoints);\n                distanceX = clipPoints[2] - clipPoints[0];\n                distanceY = clipPoints[3] - clipPoints[1];\n              } // No repulsion range. FR grid variant should take care of this.\n\n\n            if (Math.abs(distanceX) < FDLayoutConstants.MIN_REPULSION_DIST) {\n              distanceX = IMath.sign(distanceX) * FDLayoutConstants.MIN_REPULSION_DIST;\n            }\n\n            if (Math.abs(distanceY) < FDLayoutConstants.MIN_REPULSION_DIST) {\n              distanceY = IMath.sign(distanceY) * FDLayoutConstants.MIN_REPULSION_DIST;\n            }\n\n            distanceSquared = distanceX * distanceX + distanceY * distanceY;\n            distance = Math.sqrt(distanceSquared);\n            repulsionForce = this.repulsionConstant * nodeA.noOfChildren * nodeB.noOfChildren / distanceSquared; // Project force onto x and y axes\n\n            repulsionForceX = repulsionForce * distanceX / distance;\n            repulsionForceY = repulsionForce * distanceY / distance; // Apply forces on the two nodes    \n\n            nodeA.repulsionForceX -= repulsionForceX;\n            nodeA.repulsionForceY -= repulsionForceY;\n            nodeB.repulsionForceX += repulsionForceX;\n            nodeB.repulsionForceY += repulsionForceY;\n          }\n      };\n\n      FDLayout.prototype.calcGravitationalForce = function (node) {\n        var ownerGraph;\n        var ownerCenterX;\n        var ownerCenterY;\n        var distanceX;\n        var distanceY;\n        var absDistanceX;\n        var absDistanceY;\n        var estimatedSize;\n        ownerGraph = node.getOwner();\n        ownerCenterX = (ownerGraph.getRight() + ownerGraph.getLeft()) / 2;\n        ownerCenterY = (ownerGraph.getTop() + ownerGraph.getBottom()) / 2;\n        distanceX = node.getCenterX() - ownerCenterX;\n        distanceY = node.getCenterY() - ownerCenterY;\n        absDistanceX = Math.abs(distanceX) + node.getWidth() / 2;\n        absDistanceY = Math.abs(distanceY) + node.getHeight() / 2;\n\n        if (node.getOwner() == this.graphManager.getRoot()) // in the root graph\n          {\n            estimatedSize = ownerGraph.getEstimatedSize() * this.gravityRangeFactor;\n\n            if (absDistanceX > estimatedSize || absDistanceY > estimatedSize) {\n              node.gravitationForceX = -this.gravityConstant * distanceX;\n              node.gravitationForceY = -this.gravityConstant * distanceY;\n            }\n          } else // inside a compound\n          {\n            estimatedSize = ownerGraph.getEstimatedSize() * this.compoundGravityRangeFactor;\n\n            if (absDistanceX > estimatedSize || absDistanceY > estimatedSize) {\n              node.gravitationForceX = -this.gravityConstant * distanceX * this.compoundGravityConstant;\n              node.gravitationForceY = -this.gravityConstant * distanceY * this.compoundGravityConstant;\n            }\n          }\n      };\n\n      FDLayout.prototype.isConverged = function () {\n        var converged;\n        var oscilating = false;\n\n        if (this.totalIterations > this.maxIterations / 3) {\n          oscilating = Math.abs(this.totalDisplacement - this.oldTotalDisplacement) < 2;\n        }\n\n        converged = this.totalDisplacement < this.totalDisplacementThreshold;\n        this.oldTotalDisplacement = this.totalDisplacement;\n        return converged || oscilating;\n      };\n\n      FDLayout.prototype.animate = function () {\n        if (this.animationDuringLayout && !this.isSubLayout) {\n          if (this.notAnimatedIterations == this.animationPeriod) {\n            this.update();\n            this.notAnimatedIterations = 0;\n          } else {\n            this.notAnimatedIterations++;\n          }\n        }\n      }; //This method calculates the number of children (weight) for all nodes\n\n\n      FDLayout.prototype.calcNoOfChildrenForAllNodes = function () {\n        var node;\n        var allNodes = this.graphManager.getAllNodes();\n\n        for (var i = 0; i < allNodes.length; i++) {\n          node = allNodes[i];\n          node.noOfChildren = node.getNoOfChildren();\n        }\n      }; // -----------------------------------------------------------------------------\n      // Section: FR-Grid Variant Repulsion Force Calculation\n      // -----------------------------------------------------------------------------\n\n\n      FDLayout.prototype.calcGrid = function (graph) {\n        var sizeX = 0;\n        var sizeY = 0;\n        sizeX = parseInt(Math.ceil((graph.getRight() - graph.getLeft()) / this.repulsionRange));\n        sizeY = parseInt(Math.ceil((graph.getBottom() - graph.getTop()) / this.repulsionRange));\n        var grid = new Array(sizeX);\n\n        for (var i = 0; i < sizeX; i++) {\n          grid[i] = new Array(sizeY);\n        }\n\n        for (var i = 0; i < sizeX; i++) {\n          for (var j = 0; j < sizeY; j++) {\n            grid[i][j] = new Array();\n          }\n        }\n\n        return grid;\n      };\n\n      FDLayout.prototype.addNodeToGrid = function (v, left, top) {\n        var startX = 0;\n        var finishX = 0;\n        var startY = 0;\n        var finishY = 0;\n        startX = parseInt(Math.floor((v.getRect().x - left) / this.repulsionRange));\n        finishX = parseInt(Math.floor((v.getRect().width + v.getRect().x - left) / this.repulsionRange));\n        startY = parseInt(Math.floor((v.getRect().y - top) / this.repulsionRange));\n        finishY = parseInt(Math.floor((v.getRect().height + v.getRect().y - top) / this.repulsionRange));\n\n        for (var i = startX; i <= finishX; i++) {\n          for (var j = startY; j <= finishY; j++) {\n            this.grid[i][j].push(v);\n            v.setGridCoordinates(startX, finishX, startY, finishY);\n          }\n        }\n      };\n\n      FDLayout.prototype.updateGrid = function () {\n        var i;\n        var nodeA;\n        var lNodes = this.getAllNodes();\n        this.grid = this.calcGrid(this.graphManager.getRoot()); // put all nodes to proper grid cells\n\n        for (i = 0; i < lNodes.length; i++) {\n          nodeA = lNodes[i];\n          this.addNodeToGrid(nodeA, this.graphManager.getRoot().getLeft(), this.graphManager.getRoot().getTop());\n        }\n      };\n\n      FDLayout.prototype.calculateRepulsionForceOfANode = function (nodeA, processedNodeSet, gridUpdateAllowed, forceToNodeSurroundingUpdate) {\n        if (this.totalIterations % FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD == 1 && gridUpdateAllowed || forceToNodeSurroundingUpdate) {\n          var surrounding = new Set();\n          nodeA.surrounding = new Array();\n          var nodeB;\n          var grid = this.grid;\n\n          for (var i = nodeA.startX - 1; i < nodeA.finishX + 2; i++) {\n            for (var j = nodeA.startY - 1; j < nodeA.finishY + 2; j++) {\n              if (!(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length)) {\n                for (var k = 0; k < grid[i][j].length; k++) {\n                  nodeB = grid[i][j][k]; // If both nodes are not members of the same graph, \n                  // or both nodes are the same, skip.\n\n                  if (nodeA.getOwner() != nodeB.getOwner() || nodeA == nodeB) {\n                    continue;\n                  } // check if the repulsion force between\n                  // nodeA and nodeB has already been calculated\n\n\n                  if (!processedNodeSet.has(nodeB) && !surrounding.has(nodeB)) {\n                    var distanceX = Math.abs(nodeA.getCenterX() - nodeB.getCenterX()) - (nodeA.getWidth() / 2 + nodeB.getWidth() / 2);\n                    var distanceY = Math.abs(nodeA.getCenterY() - nodeB.getCenterY()) - (nodeA.getHeight() / 2 + nodeB.getHeight() / 2); // if the distance between nodeA and nodeB \n                    // is less then calculation range\n\n                    if (distanceX <= this.repulsionRange && distanceY <= this.repulsionRange) {\n                      //then add nodeB to surrounding of nodeA\n                      surrounding.add(nodeB);\n                    }\n                  }\n                }\n              }\n            }\n          }\n\n          nodeA.surrounding = [].concat(_toConsumableArray(surrounding));\n        }\n\n        for (i = 0; i < nodeA.surrounding.length; i++) {\n          this.calcRepulsionForce(nodeA, nodeA.surrounding[i]);\n        }\n      };\n\n      FDLayout.prototype.calcRepulsionRange = function () {\n        return 0.0;\n      };\n\n      module.exports = FDLayout;\n      /***/\n    },\n    /* 19 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var LEdge = __webpack_require__(1);\n\n      var FDLayoutConstants = __webpack_require__(7);\n\n      function FDLayoutEdge(source, target, vEdge) {\n        LEdge.call(this, source, target, vEdge);\n        this.idealLength = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n      }\n\n      FDLayoutEdge.prototype = Object.create(LEdge.prototype);\n\n      for (var prop in LEdge) {\n        FDLayoutEdge[prop] = LEdge[prop];\n      }\n\n      module.exports = FDLayoutEdge;\n      /***/\n    },\n    /* 20 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var LNode = __webpack_require__(3);\n\n      function FDLayoutNode(gm, loc, size, vNode) {\n        // alternative constructor is handled inside LNode\n        LNode.call(this, gm, loc, size, vNode); //Spring, repulsion and gravitational forces acting on this node\n\n        this.springForceX = 0;\n        this.springForceY = 0;\n        this.repulsionForceX = 0;\n        this.repulsionForceY = 0;\n        this.gravitationForceX = 0;\n        this.gravitationForceY = 0; //Amount by which this node is to be moved in this iteration\n\n        this.displacementX = 0;\n        this.displacementY = 0; //Start and finish grid coordinates that this node is fallen into\n\n        this.startX = 0;\n        this.finishX = 0;\n        this.startY = 0;\n        this.finishY = 0; //Geometric neighbors of this node\n\n        this.surrounding = [];\n      }\n\n      FDLayoutNode.prototype = Object.create(LNode.prototype);\n\n      for (var prop in LNode) {\n        FDLayoutNode[prop] = LNode[prop];\n      }\n\n      FDLayoutNode.prototype.setGridCoordinates = function (_startX, _finishX, _startY, _finishY) {\n        this.startX = _startX;\n        this.finishX = _finishX;\n        this.startY = _startY;\n        this.finishY = _finishY;\n      };\n\n      module.exports = FDLayoutNode;\n      /***/\n    },\n    /* 21 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function DimensionD(width, height) {\n        this.width = 0;\n        this.height = 0;\n\n        if (width !== null && height !== null) {\n          this.height = height;\n          this.width = width;\n        }\n      }\n\n      DimensionD.prototype.getWidth = function () {\n        return this.width;\n      };\n\n      DimensionD.prototype.setWidth = function (width) {\n        this.width = width;\n      };\n\n      DimensionD.prototype.getHeight = function () {\n        return this.height;\n      };\n\n      DimensionD.prototype.setHeight = function (height) {\n        this.height = height;\n      };\n\n      module.exports = DimensionD;\n      /***/\n    },\n    /* 22 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var UniqueIDGeneretor = __webpack_require__(14);\n\n      function HashMap() {\n        this.map = {};\n        this.keys = [];\n      }\n\n      HashMap.prototype.put = function (key, value) {\n        var theId = UniqueIDGeneretor.createID(key);\n\n        if (!this.contains(theId)) {\n          this.map[theId] = value;\n          this.keys.push(key);\n        }\n      };\n\n      HashMap.prototype.contains = function (key) {\n        var theId = UniqueIDGeneretor.createID(key);\n        return this.map[key] != null;\n      };\n\n      HashMap.prototype.get = function (key) {\n        var theId = UniqueIDGeneretor.createID(key);\n        return this.map[theId];\n      };\n\n      HashMap.prototype.keySet = function () {\n        return this.keys;\n      };\n\n      module.exports = HashMap;\n      /***/\n    },\n    /* 23 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var UniqueIDGeneretor = __webpack_require__(14);\n\n      function HashSet() {\n        this.set = {};\n      }\n\n      ;\n\n      HashSet.prototype.add = function (obj) {\n        var theId = UniqueIDGeneretor.createID(obj);\n        if (!this.contains(theId)) this.set[theId] = obj;\n      };\n\n      HashSet.prototype.remove = function (obj) {\n        delete this.set[UniqueIDGeneretor.createID(obj)];\n      };\n\n      HashSet.prototype.clear = function () {\n        this.set = {};\n      };\n\n      HashSet.prototype.contains = function (obj) {\n        return this.set[UniqueIDGeneretor.createID(obj)] == obj;\n      };\n\n      HashSet.prototype.isEmpty = function () {\n        return this.size() === 0;\n      };\n\n      HashSet.prototype.size = function () {\n        return Object.keys(this.set).length;\n      }; //concats this.set to the given list\n\n\n      HashSet.prototype.addAllTo = function (list) {\n        var keys = Object.keys(this.set);\n        var length = keys.length;\n\n        for (var i = 0; i < length; i++) {\n          list.push(this.set[keys[i]]);\n        }\n      };\n\n      HashSet.prototype.size = function () {\n        return Object.keys(this.set).length;\n      };\n\n      HashSet.prototype.addAll = function (list) {\n        var s = list.length;\n\n        for (var i = 0; i < s; i++) {\n          var v = list[i];\n          this.add(v);\n        }\n      };\n\n      module.exports = HashSet;\n      /***/\n    },\n    /* 24 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n          if (protoProps) defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n      /**\n       * A classic Quicksort algorithm with Hoare's partition\n       * - Works also on LinkedList objects\n       *\n       * Copyright: i-Vis Research Group, Bilkent University, 2007 - present\n       */\n\n\n      var LinkedList = __webpack_require__(11);\n\n      var Quicksort = function () {\n        function Quicksort(A, compareFunction) {\n          _classCallCheck(this, Quicksort);\n\n          if (compareFunction !== null || compareFunction !== undefined) this.compareFunction = this._defaultCompareFunction;\n          var length = void 0;\n          if (A instanceof LinkedList) length = A.size();else length = A.length;\n\n          this._quicksort(A, 0, length - 1);\n        }\n\n        _createClass(Quicksort, [{\n          key: '_quicksort',\n          value: function _quicksort(A, p, r) {\n            if (p < r) {\n              var q = this._partition(A, p, r);\n\n              this._quicksort(A, p, q);\n\n              this._quicksort(A, q + 1, r);\n            }\n          }\n        }, {\n          key: '_partition',\n          value: function _partition(A, p, r) {\n            var x = this._get(A, p);\n\n            var i = p;\n            var j = r;\n\n            while (true) {\n              while (this.compareFunction(x, this._get(A, j))) {\n                j--;\n              }\n\n              while (this.compareFunction(this._get(A, i), x)) {\n                i++;\n              }\n\n              if (i < j) {\n                this._swap(A, i, j);\n\n                i++;\n                j--;\n              } else return j;\n            }\n          }\n        }, {\n          key: '_get',\n          value: function _get(object, index) {\n            if (object instanceof LinkedList) return object.get_object_at(index);else return object[index];\n          }\n        }, {\n          key: '_set',\n          value: function _set(object, index, value) {\n            if (object instanceof LinkedList) object.set_object_at(index, value);else object[index] = value;\n          }\n        }, {\n          key: '_swap',\n          value: function _swap(A, i, j) {\n            var temp = this._get(A, i);\n\n            this._set(A, i, this._get(A, j));\n\n            this._set(A, j, temp);\n          }\n        }, {\n          key: '_defaultCompareFunction',\n          value: function _defaultCompareFunction(a, b) {\n            return b > a;\n          }\n        }]);\n\n        return Quicksort;\n      }();\n\n      module.exports = Quicksort;\n      /***/\n    },\n    /* 25 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n          if (protoProps) defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n      /**\n       *   Needleman-Wunsch algorithm is an procedure to compute the optimal global alignment of two string\n       *   sequences by S.B.Needleman and C.D.Wunsch (1970).\n       *\n       *   Aside from the inputs, you can assign the scores for,\n       *   - Match: The two characters at the current index are same.\n       *   - Mismatch: The two characters at the current index are different.\n       *   - Insertion/Deletion(gaps): The best alignment involves one letter aligning to a gap in the other string.\n       */\n\n\n      var NeedlemanWunsch = function () {\n        function NeedlemanWunsch(sequence1, sequence2) {\n          var match_score = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n          var mismatch_penalty = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;\n          var gap_penalty = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : -1;\n\n          _classCallCheck(this, NeedlemanWunsch);\n\n          this.sequence1 = sequence1;\n          this.sequence2 = sequence2;\n          this.match_score = match_score;\n          this.mismatch_penalty = mismatch_penalty;\n          this.gap_penalty = gap_penalty; // Just the remove redundancy\n\n          this.iMax = sequence1.length + 1;\n          this.jMax = sequence2.length + 1; // Grid matrix of scores\n\n          this.grid = new Array(this.iMax);\n\n          for (var i = 0; i < this.iMax; i++) {\n            this.grid[i] = new Array(this.jMax);\n\n            for (var j = 0; j < this.jMax; j++) {\n              this.grid[i][j] = 0;\n            }\n          } // Traceback matrix (2D array, each cell is an array of boolean values for [`Diag`, `Up`, `Left`] positions)\n\n\n          this.tracebackGrid = new Array(this.iMax);\n\n          for (var _i = 0; _i < this.iMax; _i++) {\n            this.tracebackGrid[_i] = new Array(this.jMax);\n\n            for (var _j = 0; _j < this.jMax; _j++) {\n              this.tracebackGrid[_i][_j] = [null, null, null];\n            }\n          } // The aligned sequences (return multiple possibilities)\n\n\n          this.alignments = []; // Final alignment score\n\n          this.score = -1; // Calculate scores and tracebacks\n\n          this.computeGrids();\n        }\n\n        _createClass(NeedlemanWunsch, [{\n          key: \"getScore\",\n          value: function getScore() {\n            return this.score;\n          }\n        }, {\n          key: \"getAlignments\",\n          value: function getAlignments() {\n            return this.alignments;\n          } // Main dynamic programming procedure\n\n        }, {\n          key: \"computeGrids\",\n          value: function computeGrids() {\n            // Fill in the first row\n            for (var j = 1; j < this.jMax; j++) {\n              this.grid[0][j] = this.grid[0][j - 1] + this.gap_penalty;\n              this.tracebackGrid[0][j] = [false, false, true];\n            } // Fill in the first column\n\n\n            for (var i = 1; i < this.iMax; i++) {\n              this.grid[i][0] = this.grid[i - 1][0] + this.gap_penalty;\n              this.tracebackGrid[i][0] = [false, true, false];\n            } // Fill the rest of the grid\n\n\n            for (var _i2 = 1; _i2 < this.iMax; _i2++) {\n              for (var _j2 = 1; _j2 < this.jMax; _j2++) {\n                // Find the max score(s) among [`Diag`, `Up`, `Left`]\n                var diag = void 0;\n                if (this.sequence1[_i2 - 1] === this.sequence2[_j2 - 1]) diag = this.grid[_i2 - 1][_j2 - 1] + this.match_score;else diag = this.grid[_i2 - 1][_j2 - 1] + this.mismatch_penalty;\n                var up = this.grid[_i2 - 1][_j2] + this.gap_penalty;\n                var left = this.grid[_i2][_j2 - 1] + this.gap_penalty; // If there exists multiple max values, capture them for multiple paths\n\n                var maxOf = [diag, up, left];\n                var indices = this.arrayAllMaxIndexes(maxOf); // Update Grids\n\n                this.grid[_i2][_j2] = maxOf[indices[0]];\n                this.tracebackGrid[_i2][_j2] = [indices.includes(0), indices.includes(1), indices.includes(2)];\n              }\n            } // Update alignment score\n\n\n            this.score = this.grid[this.iMax - 1][this.jMax - 1];\n          } // Gets all possible valid sequence combinations\n\n        }, {\n          key: \"alignmentTraceback\",\n          value: function alignmentTraceback() {\n            var inProcessAlignments = [];\n            inProcessAlignments.push({\n              pos: [this.sequence1.length, this.sequence2.length],\n              seq1: \"\",\n              seq2: \"\"\n            });\n\n            while (inProcessAlignments[0]) {\n              var current = inProcessAlignments[0];\n              var directions = this.tracebackGrid[current.pos[0]][current.pos[1]];\n\n              if (directions[0]) {\n                inProcessAlignments.push({\n                  pos: [current.pos[0] - 1, current.pos[1] - 1],\n                  seq1: this.sequence1[current.pos[0] - 1] + current.seq1,\n                  seq2: this.sequence2[current.pos[1] - 1] + current.seq2\n                });\n              }\n\n              if (directions[1]) {\n                inProcessAlignments.push({\n                  pos: [current.pos[0] - 1, current.pos[1]],\n                  seq1: this.sequence1[current.pos[0] - 1] + current.seq1,\n                  seq2: '-' + current.seq2\n                });\n              }\n\n              if (directions[2]) {\n                inProcessAlignments.push({\n                  pos: [current.pos[0], current.pos[1] - 1],\n                  seq1: '-' + current.seq1,\n                  seq2: this.sequence2[current.pos[1] - 1] + current.seq2\n                });\n              }\n\n              if (current.pos[0] === 0 && current.pos[1] === 0) this.alignments.push({\n                sequence1: current.seq1,\n                sequence2: current.seq2\n              });\n              inProcessAlignments.shift();\n            }\n\n            return this.alignments;\n          } // Helper Functions\n\n        }, {\n          key: \"getAllIndexes\",\n          value: function getAllIndexes(arr, val) {\n            var indexes = [],\n                i = -1;\n\n            while ((i = arr.indexOf(val, i + 1)) !== -1) {\n              indexes.push(i);\n            }\n\n            return indexes;\n          }\n        }, {\n          key: \"arrayAllMaxIndexes\",\n          value: function arrayAllMaxIndexes(array) {\n            return this.getAllIndexes(array, Math.max.apply(null, array));\n          }\n        }]);\n\n        return NeedlemanWunsch;\n      }();\n\n      module.exports = NeedlemanWunsch;\n      /***/\n    },\n    /* 26 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var layoutBase = function layoutBase() {\n        return;\n      };\n\n      layoutBase.FDLayout = __webpack_require__(18);\n      layoutBase.FDLayoutConstants = __webpack_require__(7);\n      layoutBase.FDLayoutEdge = __webpack_require__(19);\n      layoutBase.FDLayoutNode = __webpack_require__(20);\n      layoutBase.DimensionD = __webpack_require__(21);\n      layoutBase.HashMap = __webpack_require__(22);\n      layoutBase.HashSet = __webpack_require__(23);\n      layoutBase.IGeometry = __webpack_require__(8);\n      layoutBase.IMath = __webpack_require__(9);\n      layoutBase.Integer = __webpack_require__(10);\n      layoutBase.Point = __webpack_require__(12);\n      layoutBase.PointD = __webpack_require__(4);\n      layoutBase.RandomSeed = __webpack_require__(16);\n      layoutBase.RectangleD = __webpack_require__(13);\n      layoutBase.Transform = __webpack_require__(17);\n      layoutBase.UniqueIDGeneretor = __webpack_require__(14);\n      layoutBase.Quicksort = __webpack_require__(24);\n      layoutBase.LinkedList = __webpack_require__(11);\n      layoutBase.LGraphObject = __webpack_require__(2);\n      layoutBase.LGraph = __webpack_require__(5);\n      layoutBase.LEdge = __webpack_require__(1);\n      layoutBase.LGraphManager = __webpack_require__(6);\n      layoutBase.LNode = __webpack_require__(3);\n      layoutBase.Layout = __webpack_require__(15);\n      layoutBase.LayoutConstants = __webpack_require__(0);\n      layoutBase.NeedlemanWunsch = __webpack_require__(25);\n      module.exports = layoutBase;\n      /***/\n    },\n    /* 27 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function Emitter() {\n        this.listeners = [];\n      }\n\n      var p = Emitter.prototype;\n\n      p.addListener = function (event, callback) {\n        this.listeners.push({\n          event: event,\n          callback: callback\n        });\n      };\n\n      p.removeListener = function (event, callback) {\n        for (var i = this.listeners.length; i >= 0; i--) {\n          var l = this.listeners[i];\n\n          if (l.event === event && l.callback === callback) {\n            this.listeners.splice(i, 1);\n          }\n        }\n      };\n\n      p.emit = function (event, data) {\n        for (var i = 0; i < this.listeners.length; i++) {\n          var l = this.listeners[i];\n\n          if (event === l.event) {\n            l.callback(data);\n          }\n        }\n      };\n\n      module.exports = Emitter;\n      /***/\n    }\n    /******/\n    ])\n  );\n});","map":{"version":3,"names":["webpackUniversalModuleDefinition","root","factory","exports","module","define","amd","modules","installedModules","__webpack_require__","moduleId","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","getDefault","getModuleExports","object","property","prototype","hasOwnProperty","p","s","LayoutConstants","QUALITY","DEFAULT_CREATE_BENDS_AS_NEEDED","DEFAULT_INCREMENTAL","DEFAULT_ANIMATION_ON_LAYOUT","DEFAULT_ANIMATION_DURING_LAYOUT","DEFAULT_ANIMATION_PERIOD","DEFAULT_UNIFORM_LEAF_NODE_SIZES","DEFAULT_GRAPH_MARGIN","NODE_DIMENSIONS_INCLUDE_LABELS","SIMPLE_NODE_SIZE","SIMPLE_NODE_HALF_SIZE","EMPTY_COMPOUND_NODE_SIZE","MIN_EDGE_LENGTH","WORLD_BOUNDARY","INITIAL_WORLD_BOUNDARY","WORLD_CENTER_X","WORLD_CENTER_Y","LGraphObject","IGeometry","IMath","LEdge","source","target","vEdge","isOverlapingSourceAndTarget","vGraphObject","bendpoints","create","prop","getSource","getTarget","isInterGraph","getLength","length","getBendpoints","getLca","lca","getSourceInLca","sourceInLca","getTargetInLca","targetInLca","getOtherEnd","node","getOtherEndInGraph","graph","otherEnd","getGraphManager","getRoot","getOwner","getParent","updateLength","clipPointCoordinates","Array","getIntersection","getRect","lengthX","lengthY","Math","abs","sign","sqrt","updateLengthSimple","getCenterX","getCenterY","Integer","RectangleD","RandomSeed","PointD","LNode","gm","loc","size","vNode","graphManager","estimatedSize","MIN_VALUE","inclusionTreeDepth","MAX_VALUE","edges","rect","x","y","width","height","getEdges","getChild","child","owner","getWidth","setWidth","getHeight","setHeight","getCenter","getLocation","getDiagonal","getHalfTheDiagonal","setRect","upperLeft","dimension","setCenter","cx","cy","setLocation","moveBy","dx","dy","getEdgeListToNode","to","edgeList","edge","self","forEach","push","getEdgesBetween","other","getNeighborsList","neighbors","Set","add","withChildren","withNeighborsList","childNode","children","nodes","getNodes","getNoOfChildren","noOfChildren","getEstimatedSize","calcEstimatedSize","scatter","randomCenterX","randomCenterY","minX","maxX","nextDouble","minY","maxY","updateBounds","childGraph","getLeft","getTop","getRight","getBottom","labelWidth","labelHeight","labelPos","getInclusionTreeDepth","transform","trans","left","top","leftTop","vLeftTop","inverseTransformPoint","getX","getY","setX","setY","getDifference","pt","DimensionD","getCopy","translate","dim","LGraphManager","Point","LinkedList","LGraph","parent","obj2","vGraph","margin","isConnected","Layout","right","bottom","obj1","sourceNode","targetNode","newNode","indexOf","newEdge","remove","obj","edgesToBeRemoved","slice","index","splice","sourceIndex","targetIndex","updateLeftTop","nodeTop","nodeLeft","lNode","paddingLeft","undefined","recursive","nodeRight","nodeBottom","boundingRect","calculateBounds","updateConnected","queue","visited","currentNode","neighborEdges","currentNeighbor","childrenOfNode","shift","neighborEdge","has","childrenOfNeighbor","noOfVisitedInThisGraph","visitedNode","layout","graphs","addRoot","ngraph","newGraph","nnode","setRootGraph","rootGraph","parentNode","sourceGraph","targetGraph","lObj","concat","nodesToBeRemoved","getGraphs","getAllNodes","allNodes","nodeList","resetAllNodes","resetAllEdges","allEdges","resetAllNodesToApplyGravitation","allNodesToApplyGravitation","getAllEdges","getAllNodesToApplyGravitation","setAllNodesToApplyGravitation","getLayout","isOneAncestorOfOther","firstNode","secondNode","ownerGraph","calcLowestCommonAncestors","sourceAncestorGraph","targetAncestorGraph","calcLowestCommonAncestor","firstOwnerGraph","secondOwnerGraph","calcInclusionTreeDepths","depth","includesInvalidEdge","FDLayoutConstants","MAX_ITERATIONS","DEFAULT_EDGE_LENGTH","DEFAULT_SPRING_STRENGTH","DEFAULT_REPULSION_STRENGTH","DEFAULT_GRAVITY_STRENGTH","DEFAULT_COMPOUND_GRAVITY_STRENGTH","DEFAULT_GRAVITY_RANGE_FACTOR","DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR","DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION","DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION","DEFAULT_COOLING_FACTOR_INCREMENTAL","COOLING_ADAPTATION_FACTOR","ADAPTATION_LOWER_NODE_LIMIT","ADAPTATION_UPPER_NODE_LIMIT","MAX_NODE_DISPLACEMENT_INCREMENTAL","MAX_NODE_DISPLACEMENT","MIN_REPULSION_DIST","CONVERGENCE_CHECK_PERIOD","PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR","GRID_CALCULATION_CHECK_PERIOD","calcSeparationAmount","rectA","rectB","overlapAmount","separationBuffer","intersects","directions","decideDirectionsForOverlappingNodes","min","max","slope","moveByY","moveByX","getIntersection2","result","p1x","p1y","p2x","p2y","topLeftAx","topLeftAy","topRightAx","bottomLeftAx","bottomLeftAy","bottomRightAx","halfWidthA","getWidthHalf","halfHeightA","getHeightHalf","topLeftBx","topLeftBy","topRightBx","bottomLeftBx","bottomLeftBy","bottomRightBx","halfWidthB","halfHeightB","clipPointAFound","clipPointBFound","slopeA","slopeB","slopePrime","cardinalDirectionA","cardinalDirectionB","tempPointAx","tempPointAy","tempPointBx","tempPointBy","getCardinalDirection","line","s1","s2","f1","f2","x1","y1","x2","y2","x3","y3","x4","y4","a1","a2","b1","b2","c1","c2","denom","angleOfVector","Cx","Cy","Nx","Ny","C_angle","atan","PI","TWO_PI","ONE_AND_HALF_PI","HALF_PI","doIntersect","p1","p2","p3","p4","a","b","q","r","det","lambda","gamma","THREE_PI","floor","ceil","_createClass","defineProperties","props","descriptor","writable","key","Constructor","protoProps","staticProps","_classCallCheck","instance","TypeError","nodeFrom","next","prev","list","head","tail","_remove","vals","_this","v","insertBefore","val","otherNode","insertAfter","insertNodeBefore","insertNodeAfter","unshift","pop","popNode","shiftNode","get_object_at","current","set_object_at","constructor","parseInt","move","equals","toString","getMinX","getMaxX","getMinY","getMaxY","_typeof","Symbol","iterator","UniqueIDGeneretor","lastID","createID","isPrimitive","uniqueID","getString","id","arg","type","_toConsumableArray","arr","isArray","arr2","from","Transform","Emitter","isRemoteUse","layoutQuality","createBendsAsNeeded","incremental","animationOnLayout","animationDuringLayout","animationPeriod","uniformLeafNodeSizes","edgeToDummyNodes","Map","isLayoutFinished","isSubLayout","RANDOM_SEED","newGraphManager","checkLayoutSuccess","runLayout","tilingPreLayout","initParameters","isLayoutSuccessfull","ANIMATE","doPostLayout","tilingPostLayout","update","update2","createBendpointsFromDummyNodes","newLeftTop","setWorldOrgX","setWorldOrgY","setDeviceOrgX","setDeviceOrgY","positionNodesRandomly","getFlatForest","flatForest","isForest","isFlat","toBeVisited","parents","unProcessedNodes","set","temp","createDummyNodesForBendpoints","dummyNodes","dummyNode","Dimension","dummyEdge","keys","k","lEdge","path","ebp","sliderValue","defaultValue","minDiv","maxMul","minValue","maxValue","findCenterOfTree","removedNodes","remainingDegrees","foundCenter","centerNode","degree","tempList","tempList2","neighbours","neighbour","otherDegree","newDegree","setGraphManager","seed","sin","lworldOrgX","lworldOrgY","ldeviceOrgX","ldeviceOrgY","lworldExtX","lworldExtY","ldeviceExtX","ldeviceExtY","getWorldOrgX","wox","getWorldOrgY","woy","getWorldExtX","setWorldExtX","wex","getWorldExtY","setWorldExtY","wey","getDeviceOrgX","dox","getDeviceOrgY","doy","getDeviceExtX","setDeviceExtX","dex","getDeviceExtY","setDeviceExtY","dey","transformX","xDevice","worldExtX","transformY","yDevice","worldExtY","inverseTransformX","xWorld","deviceExtX","inverseTransformY","yWorld","deviceExtY","inPoint","outPoint","FDLayout","useSmartIdealEdgeLengthCalculation","idealEdgeLength","springConstant","repulsionConstant","gravityConstant","compoundGravityConstant","gravityRangeFactor","compoundGravityRangeFactor","displacementThresholdPerNode","coolingFactor","initialCoolingFactor","totalDisplacement","oldTotalDisplacement","maxIterations","arguments","totalIterations","notAnimatedIterations","useFRGridVariant","grid","calcIdealEdgeLengths","lcaDepth","sizeOfSourceInLca","sizeOfTargetInLca","idealLength","initSpringEmbedder","maxNodeDisplacement","totalDisplacementThreshold","repulsionRange","calcRepulsionRange","calcSpringForces","lEdges","calcSpringForce","calcRepulsionForces","gridUpdateAllowed","forceToNodeSurroundingUpdate","j","nodeA","nodeB","lNodes","processedNodeSet","updateGrid","calculateRepulsionForceOfANode","calcRepulsionForce","calcGravitationalForces","calcGravitationalForce","moveNodes","springForce","springForceX","springForceY","clipPoints","distanceX","distanceY","distanceSquared","distance","repulsionForce","repulsionForceX","repulsionForceY","childrenConstant","ownerCenterX","ownerCenterY","absDistanceX","absDistanceY","gravitationForceX","gravitationForceY","isConverged","converged","oscilating","animate","calcNoOfChildrenForAllNodes","calcGrid","sizeX","sizeY","addNodeToGrid","startX","finishX","startY","finishY","setGridCoordinates","surrounding","FDLayoutEdge","FDLayoutNode","displacementX","displacementY","_startX","_finishX","_startY","_finishY","HashMap","map","put","theId","contains","keySet","HashSet","clear","isEmpty","addAllTo","addAll","Quicksort","A","compareFunction","_defaultCompareFunction","_quicksort","_partition","_get","_swap","_set","NeedlemanWunsch","sequence1","sequence2","match_score","mismatch_penalty","gap_penalty","iMax","jMax","tracebackGrid","_i","_j","alignments","score","computeGrids","getScore","getAlignments","_i2","_j2","diag","up","maxOf","indices","arrayAllMaxIndexes","includes","alignmentTraceback","inProcessAlignments","pos","seq1","seq2","getAllIndexes","indexes","array","apply","layoutBase","listeners","addListener","event","callback","removeListener","emit","data"],"sources":["/Users/lord/Documents/Programmer/vue/VueProjects/cloudycraft-vue/blog-admin/node_modules/layout-base/layout-base.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"layoutBase\"] = factory();\n\telse\n\t\troot[\"layoutBase\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 26);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction LayoutConstants() {}\n\n/**\r\n * Layout Quality: 0:draft, 1:default, 2:proof\r\n */\nLayoutConstants.QUALITY = 1;\n\n/**\r\n * Default parameters\r\n */\nLayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED = false;\nLayoutConstants.DEFAULT_INCREMENTAL = false;\nLayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT = true;\nLayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT = false;\nLayoutConstants.DEFAULT_ANIMATION_PERIOD = 50;\nLayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES = false;\n\n// -----------------------------------------------------------------------------\n// Section: General other constants\n// -----------------------------------------------------------------------------\n/*\r\n * Margins of a graph to be applied on bouding rectangle of its contents. We\r\n * assume margins on all four sides to be uniform.\r\n */\nLayoutConstants.DEFAULT_GRAPH_MARGIN = 15;\n\n/*\r\n * Whether to consider labels in node dimensions or not\r\n */\nLayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = false;\n\n/*\r\n * Default dimension of a non-compound node.\r\n */\nLayoutConstants.SIMPLE_NODE_SIZE = 40;\n\n/*\r\n * Default dimension of a non-compound node.\r\n */\nLayoutConstants.SIMPLE_NODE_HALF_SIZE = LayoutConstants.SIMPLE_NODE_SIZE / 2;\n\n/*\r\n * Empty compound node size. When a compound node is empty, its both\r\n * dimensions should be of this value.\r\n */\nLayoutConstants.EMPTY_COMPOUND_NODE_SIZE = 40;\n\n/*\r\n * Minimum length that an edge should take during layout\r\n */\nLayoutConstants.MIN_EDGE_LENGTH = 1;\n\n/*\r\n * World boundaries that layout operates on\r\n */\nLayoutConstants.WORLD_BOUNDARY = 1000000;\n\n/*\r\n * World boundaries that random positioning can be performed with\r\n */\nLayoutConstants.INITIAL_WORLD_BOUNDARY = LayoutConstants.WORLD_BOUNDARY / 1000;\n\n/*\r\n * Coordinates of the world center\r\n */\nLayoutConstants.WORLD_CENTER_X = 1200;\nLayoutConstants.WORLD_CENTER_Y = 900;\n\nmodule.exports = LayoutConstants;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar LGraphObject = __webpack_require__(2);\nvar IGeometry = __webpack_require__(8);\nvar IMath = __webpack_require__(9);\n\nfunction LEdge(source, target, vEdge) {\n  LGraphObject.call(this, vEdge);\n\n  this.isOverlapingSourceAndTarget = false;\n  this.vGraphObject = vEdge;\n  this.bendpoints = [];\n  this.source = source;\n  this.target = target;\n}\n\nLEdge.prototype = Object.create(LGraphObject.prototype);\n\nfor (var prop in LGraphObject) {\n  LEdge[prop] = LGraphObject[prop];\n}\n\nLEdge.prototype.getSource = function () {\n  return this.source;\n};\n\nLEdge.prototype.getTarget = function () {\n  return this.target;\n};\n\nLEdge.prototype.isInterGraph = function () {\n  return this.isInterGraph;\n};\n\nLEdge.prototype.getLength = function () {\n  return this.length;\n};\n\nLEdge.prototype.isOverlapingSourceAndTarget = function () {\n  return this.isOverlapingSourceAndTarget;\n};\n\nLEdge.prototype.getBendpoints = function () {\n  return this.bendpoints;\n};\n\nLEdge.prototype.getLca = function () {\n  return this.lca;\n};\n\nLEdge.prototype.getSourceInLca = function () {\n  return this.sourceInLca;\n};\n\nLEdge.prototype.getTargetInLca = function () {\n  return this.targetInLca;\n};\n\nLEdge.prototype.getOtherEnd = function (node) {\n  if (this.source === node) {\n    return this.target;\n  } else if (this.target === node) {\n    return this.source;\n  } else {\n    throw \"Node is not incident with this edge\";\n  }\n};\n\nLEdge.prototype.getOtherEndInGraph = function (node, graph) {\n  var otherEnd = this.getOtherEnd(node);\n  var root = graph.getGraphManager().getRoot();\n\n  while (true) {\n    if (otherEnd.getOwner() == graph) {\n      return otherEnd;\n    }\n\n    if (otherEnd.getOwner() == root) {\n      break;\n    }\n\n    otherEnd = otherEnd.getOwner().getParent();\n  }\n\n  return null;\n};\n\nLEdge.prototype.updateLength = function () {\n  var clipPointCoordinates = new Array(4);\n\n  this.isOverlapingSourceAndTarget = IGeometry.getIntersection(this.target.getRect(), this.source.getRect(), clipPointCoordinates);\n\n  if (!this.isOverlapingSourceAndTarget) {\n    this.lengthX = clipPointCoordinates[0] - clipPointCoordinates[2];\n    this.lengthY = clipPointCoordinates[1] - clipPointCoordinates[3];\n\n    if (Math.abs(this.lengthX) < 1.0) {\n      this.lengthX = IMath.sign(this.lengthX);\n    }\n\n    if (Math.abs(this.lengthY) < 1.0) {\n      this.lengthY = IMath.sign(this.lengthY);\n    }\n\n    this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY);\n  }\n};\n\nLEdge.prototype.updateLengthSimple = function () {\n  this.lengthX = this.target.getCenterX() - this.source.getCenterX();\n  this.lengthY = this.target.getCenterY() - this.source.getCenterY();\n\n  if (Math.abs(this.lengthX) < 1.0) {\n    this.lengthX = IMath.sign(this.lengthX);\n  }\n\n  if (Math.abs(this.lengthY) < 1.0) {\n    this.lengthY = IMath.sign(this.lengthY);\n  }\n\n  this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY);\n};\n\nmodule.exports = LEdge;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction LGraphObject(vGraphObject) {\n  this.vGraphObject = vGraphObject;\n}\n\nmodule.exports = LGraphObject;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar LGraphObject = __webpack_require__(2);\nvar Integer = __webpack_require__(10);\nvar RectangleD = __webpack_require__(13);\nvar LayoutConstants = __webpack_require__(0);\nvar RandomSeed = __webpack_require__(16);\nvar PointD = __webpack_require__(4);\n\nfunction LNode(gm, loc, size, vNode) {\n  //Alternative constructor 1 : LNode(LGraphManager gm, Point loc, Dimension size, Object vNode)\n  if (size == null && vNode == null) {\n    vNode = loc;\n  }\n\n  LGraphObject.call(this, vNode);\n\n  //Alternative constructor 2 : LNode(Layout layout, Object vNode)\n  if (gm.graphManager != null) gm = gm.graphManager;\n\n  this.estimatedSize = Integer.MIN_VALUE;\n  this.inclusionTreeDepth = Integer.MAX_VALUE;\n  this.vGraphObject = vNode;\n  this.edges = [];\n  this.graphManager = gm;\n\n  if (size != null && loc != null) this.rect = new RectangleD(loc.x, loc.y, size.width, size.height);else this.rect = new RectangleD();\n}\n\nLNode.prototype = Object.create(LGraphObject.prototype);\nfor (var prop in LGraphObject) {\n  LNode[prop] = LGraphObject[prop];\n}\n\nLNode.prototype.getEdges = function () {\n  return this.edges;\n};\n\nLNode.prototype.getChild = function () {\n  return this.child;\n};\n\nLNode.prototype.getOwner = function () {\n  //  if (this.owner != null) {\n  //    if (!(this.owner == null || this.owner.getNodes().indexOf(this) > -1)) {\n  //      throw \"assert failed\";\n  //    }\n  //  }\n\n  return this.owner;\n};\n\nLNode.prototype.getWidth = function () {\n  return this.rect.width;\n};\n\nLNode.prototype.setWidth = function (width) {\n  this.rect.width = width;\n};\n\nLNode.prototype.getHeight = function () {\n  return this.rect.height;\n};\n\nLNode.prototype.setHeight = function (height) {\n  this.rect.height = height;\n};\n\nLNode.prototype.getCenterX = function () {\n  return this.rect.x + this.rect.width / 2;\n};\n\nLNode.prototype.getCenterY = function () {\n  return this.rect.y + this.rect.height / 2;\n};\n\nLNode.prototype.getCenter = function () {\n  return new PointD(this.rect.x + this.rect.width / 2, this.rect.y + this.rect.height / 2);\n};\n\nLNode.prototype.getLocation = function () {\n  return new PointD(this.rect.x, this.rect.y);\n};\n\nLNode.prototype.getRect = function () {\n  return this.rect;\n};\n\nLNode.prototype.getDiagonal = function () {\n  return Math.sqrt(this.rect.width * this.rect.width + this.rect.height * this.rect.height);\n};\n\n/**\n * This method returns half the diagonal length of this node.\n */\nLNode.prototype.getHalfTheDiagonal = function () {\n  return Math.sqrt(this.rect.height * this.rect.height + this.rect.width * this.rect.width) / 2;\n};\n\nLNode.prototype.setRect = function (upperLeft, dimension) {\n  this.rect.x = upperLeft.x;\n  this.rect.y = upperLeft.y;\n  this.rect.width = dimension.width;\n  this.rect.height = dimension.height;\n};\n\nLNode.prototype.setCenter = function (cx, cy) {\n  this.rect.x = cx - this.rect.width / 2;\n  this.rect.y = cy - this.rect.height / 2;\n};\n\nLNode.prototype.setLocation = function (x, y) {\n  this.rect.x = x;\n  this.rect.y = y;\n};\n\nLNode.prototype.moveBy = function (dx, dy) {\n  this.rect.x += dx;\n  this.rect.y += dy;\n};\n\nLNode.prototype.getEdgeListToNode = function (to) {\n  var edgeList = [];\n  var edge;\n  var self = this;\n\n  self.edges.forEach(function (edge) {\n\n    if (edge.target == to) {\n      if (edge.source != self) throw \"Incorrect edge source!\";\n\n      edgeList.push(edge);\n    }\n  });\n\n  return edgeList;\n};\n\nLNode.prototype.getEdgesBetween = function (other) {\n  var edgeList = [];\n  var edge;\n\n  var self = this;\n  self.edges.forEach(function (edge) {\n\n    if (!(edge.source == self || edge.target == self)) throw \"Incorrect edge source and/or target\";\n\n    if (edge.target == other || edge.source == other) {\n      edgeList.push(edge);\n    }\n  });\n\n  return edgeList;\n};\n\nLNode.prototype.getNeighborsList = function () {\n  var neighbors = new Set();\n\n  var self = this;\n  self.edges.forEach(function (edge) {\n\n    if (edge.source == self) {\n      neighbors.add(edge.target);\n    } else {\n      if (edge.target != self) {\n        throw \"Incorrect incidency!\";\n      }\n\n      neighbors.add(edge.source);\n    }\n  });\n\n  return neighbors;\n};\n\nLNode.prototype.withChildren = function () {\n  var withNeighborsList = new Set();\n  var childNode;\n  var children;\n\n  withNeighborsList.add(this);\n\n  if (this.child != null) {\n    var nodes = this.child.getNodes();\n    for (var i = 0; i < nodes.length; i++) {\n      childNode = nodes[i];\n      children = childNode.withChildren();\n      children.forEach(function (node) {\n        withNeighborsList.add(node);\n      });\n    }\n  }\n\n  return withNeighborsList;\n};\n\nLNode.prototype.getNoOfChildren = function () {\n  var noOfChildren = 0;\n  var childNode;\n\n  if (this.child == null) {\n    noOfChildren = 1;\n  } else {\n    var nodes = this.child.getNodes();\n    for (var i = 0; i < nodes.length; i++) {\n      childNode = nodes[i];\n\n      noOfChildren += childNode.getNoOfChildren();\n    }\n  }\n\n  if (noOfChildren == 0) {\n    noOfChildren = 1;\n  }\n  return noOfChildren;\n};\n\nLNode.prototype.getEstimatedSize = function () {\n  if (this.estimatedSize == Integer.MIN_VALUE) {\n    throw \"assert failed\";\n  }\n  return this.estimatedSize;\n};\n\nLNode.prototype.calcEstimatedSize = function () {\n  if (this.child == null) {\n    return this.estimatedSize = (this.rect.width + this.rect.height) / 2;\n  } else {\n    this.estimatedSize = this.child.calcEstimatedSize();\n    this.rect.width = this.estimatedSize;\n    this.rect.height = this.estimatedSize;\n\n    return this.estimatedSize;\n  }\n};\n\nLNode.prototype.scatter = function () {\n  var randomCenterX;\n  var randomCenterY;\n\n  var minX = -LayoutConstants.INITIAL_WORLD_BOUNDARY;\n  var maxX = LayoutConstants.INITIAL_WORLD_BOUNDARY;\n  randomCenterX = LayoutConstants.WORLD_CENTER_X + RandomSeed.nextDouble() * (maxX - minX) + minX;\n\n  var minY = -LayoutConstants.INITIAL_WORLD_BOUNDARY;\n  var maxY = LayoutConstants.INITIAL_WORLD_BOUNDARY;\n  randomCenterY = LayoutConstants.WORLD_CENTER_Y + RandomSeed.nextDouble() * (maxY - minY) + minY;\n\n  this.rect.x = randomCenterX;\n  this.rect.y = randomCenterY;\n};\n\nLNode.prototype.updateBounds = function () {\n  if (this.getChild() == null) {\n    throw \"assert failed\";\n  }\n  if (this.getChild().getNodes().length != 0) {\n    // wrap the children nodes by re-arranging the boundaries\n    var childGraph = this.getChild();\n    childGraph.updateBounds(true);\n\n    this.rect.x = childGraph.getLeft();\n    this.rect.y = childGraph.getTop();\n\n    this.setWidth(childGraph.getRight() - childGraph.getLeft());\n    this.setHeight(childGraph.getBottom() - childGraph.getTop());\n\n    // Update compound bounds considering its label properties    \n    if (LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS) {\n\n      var width = childGraph.getRight() - childGraph.getLeft();\n      var height = childGraph.getBottom() - childGraph.getTop();\n\n      if (this.labelWidth > width) {\n        this.rect.x -= (this.labelWidth - width) / 2;\n        this.setWidth(this.labelWidth);\n      }\n\n      if (this.labelHeight > height) {\n        if (this.labelPos == \"center\") {\n          this.rect.y -= (this.labelHeight - height) / 2;\n        } else if (this.labelPos == \"top\") {\n          this.rect.y -= this.labelHeight - height;\n        }\n        this.setHeight(this.labelHeight);\n      }\n    }\n  }\n};\n\nLNode.prototype.getInclusionTreeDepth = function () {\n  if (this.inclusionTreeDepth == Integer.MAX_VALUE) {\n    throw \"assert failed\";\n  }\n  return this.inclusionTreeDepth;\n};\n\nLNode.prototype.transform = function (trans) {\n  var left = this.rect.x;\n\n  if (left > LayoutConstants.WORLD_BOUNDARY) {\n    left = LayoutConstants.WORLD_BOUNDARY;\n  } else if (left < -LayoutConstants.WORLD_BOUNDARY) {\n    left = -LayoutConstants.WORLD_BOUNDARY;\n  }\n\n  var top = this.rect.y;\n\n  if (top > LayoutConstants.WORLD_BOUNDARY) {\n    top = LayoutConstants.WORLD_BOUNDARY;\n  } else if (top < -LayoutConstants.WORLD_BOUNDARY) {\n    top = -LayoutConstants.WORLD_BOUNDARY;\n  }\n\n  var leftTop = new PointD(left, top);\n  var vLeftTop = trans.inverseTransformPoint(leftTop);\n\n  this.setLocation(vLeftTop.x, vLeftTop.y);\n};\n\nLNode.prototype.getLeft = function () {\n  return this.rect.x;\n};\n\nLNode.prototype.getRight = function () {\n  return this.rect.x + this.rect.width;\n};\n\nLNode.prototype.getTop = function () {\n  return this.rect.y;\n};\n\nLNode.prototype.getBottom = function () {\n  return this.rect.y + this.rect.height;\n};\n\nLNode.prototype.getParent = function () {\n  if (this.owner == null) {\n    return null;\n  }\n\n  return this.owner.getParent();\n};\n\nmodule.exports = LNode;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction PointD(x, y) {\n  if (x == null && y == null) {\n    this.x = 0;\n    this.y = 0;\n  } else {\n    this.x = x;\n    this.y = y;\n  }\n}\n\nPointD.prototype.getX = function () {\n  return this.x;\n};\n\nPointD.prototype.getY = function () {\n  return this.y;\n};\n\nPointD.prototype.setX = function (x) {\n  this.x = x;\n};\n\nPointD.prototype.setY = function (y) {\n  this.y = y;\n};\n\nPointD.prototype.getDifference = function (pt) {\n  return new DimensionD(this.x - pt.x, this.y - pt.y);\n};\n\nPointD.prototype.getCopy = function () {\n  return new PointD(this.x, this.y);\n};\n\nPointD.prototype.translate = function (dim) {\n  this.x += dim.width;\n  this.y += dim.height;\n  return this;\n};\n\nmodule.exports = PointD;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar LGraphObject = __webpack_require__(2);\nvar Integer = __webpack_require__(10);\nvar LayoutConstants = __webpack_require__(0);\nvar LGraphManager = __webpack_require__(6);\nvar LNode = __webpack_require__(3);\nvar LEdge = __webpack_require__(1);\nvar RectangleD = __webpack_require__(13);\nvar Point = __webpack_require__(12);\nvar LinkedList = __webpack_require__(11);\n\nfunction LGraph(parent, obj2, vGraph) {\n  LGraphObject.call(this, vGraph);\n  this.estimatedSize = Integer.MIN_VALUE;\n  this.margin = LayoutConstants.DEFAULT_GRAPH_MARGIN;\n  this.edges = [];\n  this.nodes = [];\n  this.isConnected = false;\n  this.parent = parent;\n\n  if (obj2 != null && obj2 instanceof LGraphManager) {\n    this.graphManager = obj2;\n  } else if (obj2 != null && obj2 instanceof Layout) {\n    this.graphManager = obj2.graphManager;\n  }\n}\n\nLGraph.prototype = Object.create(LGraphObject.prototype);\nfor (var prop in LGraphObject) {\n  LGraph[prop] = LGraphObject[prop];\n}\n\nLGraph.prototype.getNodes = function () {\n  return this.nodes;\n};\n\nLGraph.prototype.getEdges = function () {\n  return this.edges;\n};\n\nLGraph.prototype.getGraphManager = function () {\n  return this.graphManager;\n};\n\nLGraph.prototype.getParent = function () {\n  return this.parent;\n};\n\nLGraph.prototype.getLeft = function () {\n  return this.left;\n};\n\nLGraph.prototype.getRight = function () {\n  return this.right;\n};\n\nLGraph.prototype.getTop = function () {\n  return this.top;\n};\n\nLGraph.prototype.getBottom = function () {\n  return this.bottom;\n};\n\nLGraph.prototype.isConnected = function () {\n  return this.isConnected;\n};\n\nLGraph.prototype.add = function (obj1, sourceNode, targetNode) {\n  if (sourceNode == null && targetNode == null) {\n    var newNode = obj1;\n    if (this.graphManager == null) {\n      throw \"Graph has no graph mgr!\";\n    }\n    if (this.getNodes().indexOf(newNode) > -1) {\n      throw \"Node already in graph!\";\n    }\n    newNode.owner = this;\n    this.getNodes().push(newNode);\n\n    return newNode;\n  } else {\n    var newEdge = obj1;\n    if (!(this.getNodes().indexOf(sourceNode) > -1 && this.getNodes().indexOf(targetNode) > -1)) {\n      throw \"Source or target not in graph!\";\n    }\n\n    if (!(sourceNode.owner == targetNode.owner && sourceNode.owner == this)) {\n      throw \"Both owners must be this graph!\";\n    }\n\n    if (sourceNode.owner != targetNode.owner) {\n      return null;\n    }\n\n    // set source and target\n    newEdge.source = sourceNode;\n    newEdge.target = targetNode;\n\n    // set as intra-graph edge\n    newEdge.isInterGraph = false;\n\n    // add to graph edge list\n    this.getEdges().push(newEdge);\n\n    // add to incidency lists\n    sourceNode.edges.push(newEdge);\n\n    if (targetNode != sourceNode) {\n      targetNode.edges.push(newEdge);\n    }\n\n    return newEdge;\n  }\n};\n\nLGraph.prototype.remove = function (obj) {\n  var node = obj;\n  if (obj instanceof LNode) {\n    if (node == null) {\n      throw \"Node is null!\";\n    }\n    if (!(node.owner != null && node.owner == this)) {\n      throw \"Owner graph is invalid!\";\n    }\n    if (this.graphManager == null) {\n      throw \"Owner graph manager is invalid!\";\n    }\n    // remove incident edges first (make a copy to do it safely)\n    var edgesToBeRemoved = node.edges.slice();\n    var edge;\n    var s = edgesToBeRemoved.length;\n    for (var i = 0; i < s; i++) {\n      edge = edgesToBeRemoved[i];\n\n      if (edge.isInterGraph) {\n        this.graphManager.remove(edge);\n      } else {\n        edge.source.owner.remove(edge);\n      }\n    }\n\n    // now the node itself\n    var index = this.nodes.indexOf(node);\n    if (index == -1) {\n      throw \"Node not in owner node list!\";\n    }\n\n    this.nodes.splice(index, 1);\n  } else if (obj instanceof LEdge) {\n    var edge = obj;\n    if (edge == null) {\n      throw \"Edge is null!\";\n    }\n    if (!(edge.source != null && edge.target != null)) {\n      throw \"Source and/or target is null!\";\n    }\n    if (!(edge.source.owner != null && edge.target.owner != null && edge.source.owner == this && edge.target.owner == this)) {\n      throw \"Source and/or target owner is invalid!\";\n    }\n\n    var sourceIndex = edge.source.edges.indexOf(edge);\n    var targetIndex = edge.target.edges.indexOf(edge);\n    if (!(sourceIndex > -1 && targetIndex > -1)) {\n      throw \"Source and/or target doesn't know this edge!\";\n    }\n\n    edge.source.edges.splice(sourceIndex, 1);\n\n    if (edge.target != edge.source) {\n      edge.target.edges.splice(targetIndex, 1);\n    }\n\n    var index = edge.source.owner.getEdges().indexOf(edge);\n    if (index == -1) {\n      throw \"Not in owner's edge list!\";\n    }\n\n    edge.source.owner.getEdges().splice(index, 1);\n  }\n};\n\nLGraph.prototype.updateLeftTop = function () {\n  var top = Integer.MAX_VALUE;\n  var left = Integer.MAX_VALUE;\n  var nodeTop;\n  var nodeLeft;\n  var margin;\n\n  var nodes = this.getNodes();\n  var s = nodes.length;\n\n  for (var i = 0; i < s; i++) {\n    var lNode = nodes[i];\n    nodeTop = lNode.getTop();\n    nodeLeft = lNode.getLeft();\n\n    if (top > nodeTop) {\n      top = nodeTop;\n    }\n\n    if (left > nodeLeft) {\n      left = nodeLeft;\n    }\n  }\n\n  // Do we have any nodes in this graph?\n  if (top == Integer.MAX_VALUE) {\n    return null;\n  }\n\n  if (nodes[0].getParent().paddingLeft != undefined) {\n    margin = nodes[0].getParent().paddingLeft;\n  } else {\n    margin = this.margin;\n  }\n\n  this.left = left - margin;\n  this.top = top - margin;\n\n  // Apply the margins and return the result\n  return new Point(this.left, this.top);\n};\n\nLGraph.prototype.updateBounds = function (recursive) {\n  // calculate bounds\n  var left = Integer.MAX_VALUE;\n  var right = -Integer.MAX_VALUE;\n  var top = Integer.MAX_VALUE;\n  var bottom = -Integer.MAX_VALUE;\n  var nodeLeft;\n  var nodeRight;\n  var nodeTop;\n  var nodeBottom;\n  var margin;\n\n  var nodes = this.nodes;\n  var s = nodes.length;\n  for (var i = 0; i < s; i++) {\n    var lNode = nodes[i];\n\n    if (recursive && lNode.child != null) {\n      lNode.updateBounds();\n    }\n    nodeLeft = lNode.getLeft();\n    nodeRight = lNode.getRight();\n    nodeTop = lNode.getTop();\n    nodeBottom = lNode.getBottom();\n\n    if (left > nodeLeft) {\n      left = nodeLeft;\n    }\n\n    if (right < nodeRight) {\n      right = nodeRight;\n    }\n\n    if (top > nodeTop) {\n      top = nodeTop;\n    }\n\n    if (bottom < nodeBottom) {\n      bottom = nodeBottom;\n    }\n  }\n\n  var boundingRect = new RectangleD(left, top, right - left, bottom - top);\n  if (left == Integer.MAX_VALUE) {\n    this.left = this.parent.getLeft();\n    this.right = this.parent.getRight();\n    this.top = this.parent.getTop();\n    this.bottom = this.parent.getBottom();\n  }\n\n  if (nodes[0].getParent().paddingLeft != undefined) {\n    margin = nodes[0].getParent().paddingLeft;\n  } else {\n    margin = this.margin;\n  }\n\n  this.left = boundingRect.x - margin;\n  this.right = boundingRect.x + boundingRect.width + margin;\n  this.top = boundingRect.y - margin;\n  this.bottom = boundingRect.y + boundingRect.height + margin;\n};\n\nLGraph.calculateBounds = function (nodes) {\n  var left = Integer.MAX_VALUE;\n  var right = -Integer.MAX_VALUE;\n  var top = Integer.MAX_VALUE;\n  var bottom = -Integer.MAX_VALUE;\n  var nodeLeft;\n  var nodeRight;\n  var nodeTop;\n  var nodeBottom;\n\n  var s = nodes.length;\n\n  for (var i = 0; i < s; i++) {\n    var lNode = nodes[i];\n    nodeLeft = lNode.getLeft();\n    nodeRight = lNode.getRight();\n    nodeTop = lNode.getTop();\n    nodeBottom = lNode.getBottom();\n\n    if (left > nodeLeft) {\n      left = nodeLeft;\n    }\n\n    if (right < nodeRight) {\n      right = nodeRight;\n    }\n\n    if (top > nodeTop) {\n      top = nodeTop;\n    }\n\n    if (bottom < nodeBottom) {\n      bottom = nodeBottom;\n    }\n  }\n\n  var boundingRect = new RectangleD(left, top, right - left, bottom - top);\n\n  return boundingRect;\n};\n\nLGraph.prototype.getInclusionTreeDepth = function () {\n  if (this == this.graphManager.getRoot()) {\n    return 1;\n  } else {\n    return this.parent.getInclusionTreeDepth();\n  }\n};\n\nLGraph.prototype.getEstimatedSize = function () {\n  if (this.estimatedSize == Integer.MIN_VALUE) {\n    throw \"assert failed\";\n  }\n  return this.estimatedSize;\n};\n\nLGraph.prototype.calcEstimatedSize = function () {\n  var size = 0;\n  var nodes = this.nodes;\n  var s = nodes.length;\n\n  for (var i = 0; i < s; i++) {\n    var lNode = nodes[i];\n    size += lNode.calcEstimatedSize();\n  }\n\n  if (size == 0) {\n    this.estimatedSize = LayoutConstants.EMPTY_COMPOUND_NODE_SIZE;\n  } else {\n    this.estimatedSize = size / Math.sqrt(this.nodes.length);\n  }\n\n  return this.estimatedSize;\n};\n\nLGraph.prototype.updateConnected = function () {\n  var self = this;\n  if (this.nodes.length == 0) {\n    this.isConnected = true;\n    return;\n  }\n\n  var queue = new LinkedList();\n  var visited = new Set();\n  var currentNode = this.nodes[0];\n  var neighborEdges;\n  var currentNeighbor;\n  var childrenOfNode = currentNode.withChildren();\n  childrenOfNode.forEach(function (node) {\n    queue.push(node);\n    visited.add(node);\n  });\n\n  while (queue.length !== 0) {\n    currentNode = queue.shift();\n\n    // Traverse all neighbors of this node\n    neighborEdges = currentNode.getEdges();\n    var size = neighborEdges.length;\n    for (var i = 0; i < size; i++) {\n      var neighborEdge = neighborEdges[i];\n      currentNeighbor = neighborEdge.getOtherEndInGraph(currentNode, this);\n\n      // Add unvisited neighbors to the list to visit\n      if (currentNeighbor != null && !visited.has(currentNeighbor)) {\n        var childrenOfNeighbor = currentNeighbor.withChildren();\n\n        childrenOfNeighbor.forEach(function (node) {\n          queue.push(node);\n          visited.add(node);\n        });\n      }\n    }\n  }\n\n  this.isConnected = false;\n\n  if (visited.size >= this.nodes.length) {\n    var noOfVisitedInThisGraph = 0;\n\n    visited.forEach(function (visitedNode) {\n      if (visitedNode.owner == self) {\n        noOfVisitedInThisGraph++;\n      }\n    });\n\n    if (noOfVisitedInThisGraph == this.nodes.length) {\n      this.isConnected = true;\n    }\n  }\n};\n\nmodule.exports = LGraph;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar LGraph;\nvar LEdge = __webpack_require__(1);\n\nfunction LGraphManager(layout) {\n  LGraph = __webpack_require__(5); // It may be better to initilize this out of this function but it gives an error (Right-hand side of 'instanceof' is not callable) now.\n  this.layout = layout;\n\n  this.graphs = [];\n  this.edges = [];\n}\n\nLGraphManager.prototype.addRoot = function () {\n  var ngraph = this.layout.newGraph();\n  var nnode = this.layout.newNode(null);\n  var root = this.add(ngraph, nnode);\n  this.setRootGraph(root);\n  return this.rootGraph;\n};\n\nLGraphManager.prototype.add = function (newGraph, parentNode, newEdge, sourceNode, targetNode) {\n  //there are just 2 parameters are passed then it adds an LGraph else it adds an LEdge\n  if (newEdge == null && sourceNode == null && targetNode == null) {\n    if (newGraph == null) {\n      throw \"Graph is null!\";\n    }\n    if (parentNode == null) {\n      throw \"Parent node is null!\";\n    }\n    if (this.graphs.indexOf(newGraph) > -1) {\n      throw \"Graph already in this graph mgr!\";\n    }\n\n    this.graphs.push(newGraph);\n\n    if (newGraph.parent != null) {\n      throw \"Already has a parent!\";\n    }\n    if (parentNode.child != null) {\n      throw \"Already has a child!\";\n    }\n\n    newGraph.parent = parentNode;\n    parentNode.child = newGraph;\n\n    return newGraph;\n  } else {\n    //change the order of the parameters\n    targetNode = newEdge;\n    sourceNode = parentNode;\n    newEdge = newGraph;\n    var sourceGraph = sourceNode.getOwner();\n    var targetGraph = targetNode.getOwner();\n\n    if (!(sourceGraph != null && sourceGraph.getGraphManager() == this)) {\n      throw \"Source not in this graph mgr!\";\n    }\n    if (!(targetGraph != null && targetGraph.getGraphManager() == this)) {\n      throw \"Target not in this graph mgr!\";\n    }\n\n    if (sourceGraph == targetGraph) {\n      newEdge.isInterGraph = false;\n      return sourceGraph.add(newEdge, sourceNode, targetNode);\n    } else {\n      newEdge.isInterGraph = true;\n\n      // set source and target\n      newEdge.source = sourceNode;\n      newEdge.target = targetNode;\n\n      // add edge to inter-graph edge list\n      if (this.edges.indexOf(newEdge) > -1) {\n        throw \"Edge already in inter-graph edge list!\";\n      }\n\n      this.edges.push(newEdge);\n\n      // add edge to source and target incidency lists\n      if (!(newEdge.source != null && newEdge.target != null)) {\n        throw \"Edge source and/or target is null!\";\n      }\n\n      if (!(newEdge.source.edges.indexOf(newEdge) == -1 && newEdge.target.edges.indexOf(newEdge) == -1)) {\n        throw \"Edge already in source and/or target incidency list!\";\n      }\n\n      newEdge.source.edges.push(newEdge);\n      newEdge.target.edges.push(newEdge);\n\n      return newEdge;\n    }\n  }\n};\n\nLGraphManager.prototype.remove = function (lObj) {\n  if (lObj instanceof LGraph) {\n    var graph = lObj;\n    if (graph.getGraphManager() != this) {\n      throw \"Graph not in this graph mgr\";\n    }\n    if (!(graph == this.rootGraph || graph.parent != null && graph.parent.graphManager == this)) {\n      throw \"Invalid parent node!\";\n    }\n\n    // first the edges (make a copy to do it safely)\n    var edgesToBeRemoved = [];\n\n    edgesToBeRemoved = edgesToBeRemoved.concat(graph.getEdges());\n\n    var edge;\n    var s = edgesToBeRemoved.length;\n    for (var i = 0; i < s; i++) {\n      edge = edgesToBeRemoved[i];\n      graph.remove(edge);\n    }\n\n    // then the nodes (make a copy to do it safely)\n    var nodesToBeRemoved = [];\n\n    nodesToBeRemoved = nodesToBeRemoved.concat(graph.getNodes());\n\n    var node;\n    s = nodesToBeRemoved.length;\n    for (var i = 0; i < s; i++) {\n      node = nodesToBeRemoved[i];\n      graph.remove(node);\n    }\n\n    // check if graph is the root\n    if (graph == this.rootGraph) {\n      this.setRootGraph(null);\n    }\n\n    // now remove the graph itself\n    var index = this.graphs.indexOf(graph);\n    this.graphs.splice(index, 1);\n\n    // also reset the parent of the graph\n    graph.parent = null;\n  } else if (lObj instanceof LEdge) {\n    edge = lObj;\n    if (edge == null) {\n      throw \"Edge is null!\";\n    }\n    if (!edge.isInterGraph) {\n      throw \"Not an inter-graph edge!\";\n    }\n    if (!(edge.source != null && edge.target != null)) {\n      throw \"Source and/or target is null!\";\n    }\n\n    // remove edge from source and target nodes' incidency lists\n\n    if (!(edge.source.edges.indexOf(edge) != -1 && edge.target.edges.indexOf(edge) != -1)) {\n      throw \"Source and/or target doesn't know this edge!\";\n    }\n\n    var index = edge.source.edges.indexOf(edge);\n    edge.source.edges.splice(index, 1);\n    index = edge.target.edges.indexOf(edge);\n    edge.target.edges.splice(index, 1);\n\n    // remove edge from owner graph manager's inter-graph edge list\n\n    if (!(edge.source.owner != null && edge.source.owner.getGraphManager() != null)) {\n      throw \"Edge owner graph or owner graph manager is null!\";\n    }\n    if (edge.source.owner.getGraphManager().edges.indexOf(edge) == -1) {\n      throw \"Not in owner graph manager's edge list!\";\n    }\n\n    var index = edge.source.owner.getGraphManager().edges.indexOf(edge);\n    edge.source.owner.getGraphManager().edges.splice(index, 1);\n  }\n};\n\nLGraphManager.prototype.updateBounds = function () {\n  this.rootGraph.updateBounds(true);\n};\n\nLGraphManager.prototype.getGraphs = function () {\n  return this.graphs;\n};\n\nLGraphManager.prototype.getAllNodes = function () {\n  if (this.allNodes == null) {\n    var nodeList = [];\n    var graphs = this.getGraphs();\n    var s = graphs.length;\n    for (var i = 0; i < s; i++) {\n      nodeList = nodeList.concat(graphs[i].getNodes());\n    }\n    this.allNodes = nodeList;\n  }\n  return this.allNodes;\n};\n\nLGraphManager.prototype.resetAllNodes = function () {\n  this.allNodes = null;\n};\n\nLGraphManager.prototype.resetAllEdges = function () {\n  this.allEdges = null;\n};\n\nLGraphManager.prototype.resetAllNodesToApplyGravitation = function () {\n  this.allNodesToApplyGravitation = null;\n};\n\nLGraphManager.prototype.getAllEdges = function () {\n  if (this.allEdges == null) {\n    var edgeList = [];\n    var graphs = this.getGraphs();\n    var s = graphs.length;\n    for (var i = 0; i < graphs.length; i++) {\n      edgeList = edgeList.concat(graphs[i].getEdges());\n    }\n\n    edgeList = edgeList.concat(this.edges);\n\n    this.allEdges = edgeList;\n  }\n  return this.allEdges;\n};\n\nLGraphManager.prototype.getAllNodesToApplyGravitation = function () {\n  return this.allNodesToApplyGravitation;\n};\n\nLGraphManager.prototype.setAllNodesToApplyGravitation = function (nodeList) {\n  if (this.allNodesToApplyGravitation != null) {\n    throw \"assert failed\";\n  }\n\n  this.allNodesToApplyGravitation = nodeList;\n};\n\nLGraphManager.prototype.getRoot = function () {\n  return this.rootGraph;\n};\n\nLGraphManager.prototype.setRootGraph = function (graph) {\n  if (graph.getGraphManager() != this) {\n    throw \"Root not in this graph mgr!\";\n  }\n\n  this.rootGraph = graph;\n  // root graph must have a root node associated with it for convenience\n  if (graph.parent == null) {\n    graph.parent = this.layout.newNode(\"Root node\");\n  }\n};\n\nLGraphManager.prototype.getLayout = function () {\n  return this.layout;\n};\n\nLGraphManager.prototype.isOneAncestorOfOther = function (firstNode, secondNode) {\n  if (!(firstNode != null && secondNode != null)) {\n    throw \"assert failed\";\n  }\n\n  if (firstNode == secondNode) {\n    return true;\n  }\n  // Is second node an ancestor of the first one?\n  var ownerGraph = firstNode.getOwner();\n  var parentNode;\n\n  do {\n    parentNode = ownerGraph.getParent();\n\n    if (parentNode == null) {\n      break;\n    }\n\n    if (parentNode == secondNode) {\n      return true;\n    }\n\n    ownerGraph = parentNode.getOwner();\n    if (ownerGraph == null) {\n      break;\n    }\n  } while (true);\n  // Is first node an ancestor of the second one?\n  ownerGraph = secondNode.getOwner();\n\n  do {\n    parentNode = ownerGraph.getParent();\n\n    if (parentNode == null) {\n      break;\n    }\n\n    if (parentNode == firstNode) {\n      return true;\n    }\n\n    ownerGraph = parentNode.getOwner();\n    if (ownerGraph == null) {\n      break;\n    }\n  } while (true);\n\n  return false;\n};\n\nLGraphManager.prototype.calcLowestCommonAncestors = function () {\n  var edge;\n  var sourceNode;\n  var targetNode;\n  var sourceAncestorGraph;\n  var targetAncestorGraph;\n\n  var edges = this.getAllEdges();\n  var s = edges.length;\n  for (var i = 0; i < s; i++) {\n    edge = edges[i];\n\n    sourceNode = edge.source;\n    targetNode = edge.target;\n    edge.lca = null;\n    edge.sourceInLca = sourceNode;\n    edge.targetInLca = targetNode;\n\n    if (sourceNode == targetNode) {\n      edge.lca = sourceNode.getOwner();\n      continue;\n    }\n\n    sourceAncestorGraph = sourceNode.getOwner();\n\n    while (edge.lca == null) {\n      edge.targetInLca = targetNode;\n      targetAncestorGraph = targetNode.getOwner();\n\n      while (edge.lca == null) {\n        if (targetAncestorGraph == sourceAncestorGraph) {\n          edge.lca = targetAncestorGraph;\n          break;\n        }\n\n        if (targetAncestorGraph == this.rootGraph) {\n          break;\n        }\n\n        if (edge.lca != null) {\n          throw \"assert failed\";\n        }\n        edge.targetInLca = targetAncestorGraph.getParent();\n        targetAncestorGraph = edge.targetInLca.getOwner();\n      }\n\n      if (sourceAncestorGraph == this.rootGraph) {\n        break;\n      }\n\n      if (edge.lca == null) {\n        edge.sourceInLca = sourceAncestorGraph.getParent();\n        sourceAncestorGraph = edge.sourceInLca.getOwner();\n      }\n    }\n\n    if (edge.lca == null) {\n      throw \"assert failed\";\n    }\n  }\n};\n\nLGraphManager.prototype.calcLowestCommonAncestor = function (firstNode, secondNode) {\n  if (firstNode == secondNode) {\n    return firstNode.getOwner();\n  }\n  var firstOwnerGraph = firstNode.getOwner();\n\n  do {\n    if (firstOwnerGraph == null) {\n      break;\n    }\n    var secondOwnerGraph = secondNode.getOwner();\n\n    do {\n      if (secondOwnerGraph == null) {\n        break;\n      }\n\n      if (secondOwnerGraph == firstOwnerGraph) {\n        return secondOwnerGraph;\n      }\n      secondOwnerGraph = secondOwnerGraph.getParent().getOwner();\n    } while (true);\n\n    firstOwnerGraph = firstOwnerGraph.getParent().getOwner();\n  } while (true);\n\n  return firstOwnerGraph;\n};\n\nLGraphManager.prototype.calcInclusionTreeDepths = function (graph, depth) {\n  if (graph == null && depth == null) {\n    graph = this.rootGraph;\n    depth = 1;\n  }\n  var node;\n\n  var nodes = graph.getNodes();\n  var s = nodes.length;\n  for (var i = 0; i < s; i++) {\n    node = nodes[i];\n    node.inclusionTreeDepth = depth;\n\n    if (node.child != null) {\n      this.calcInclusionTreeDepths(node.child, depth + 1);\n    }\n  }\n};\n\nLGraphManager.prototype.includesInvalidEdge = function () {\n  var edge;\n\n  var s = this.edges.length;\n  for (var i = 0; i < s; i++) {\n    edge = this.edges[i];\n\n    if (this.isOneAncestorOfOther(edge.source, edge.target)) {\n      return true;\n    }\n  }\n  return false;\n};\n\nmodule.exports = LGraphManager;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar LayoutConstants = __webpack_require__(0);\n\nfunction FDLayoutConstants() {}\n\n//FDLayoutConstants inherits static props in LayoutConstants\nfor (var prop in LayoutConstants) {\n  FDLayoutConstants[prop] = LayoutConstants[prop];\n}\n\nFDLayoutConstants.MAX_ITERATIONS = 2500;\n\nFDLayoutConstants.DEFAULT_EDGE_LENGTH = 50;\nFDLayoutConstants.DEFAULT_SPRING_STRENGTH = 0.45;\nFDLayoutConstants.DEFAULT_REPULSION_STRENGTH = 4500.0;\nFDLayoutConstants.DEFAULT_GRAVITY_STRENGTH = 0.4;\nFDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = 1.0;\nFDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR = 3.8;\nFDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = 1.5;\nFDLayoutConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION = true;\nFDLayoutConstants.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION = true;\nFDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = 0.3;\nFDLayoutConstants.COOLING_ADAPTATION_FACTOR = 0.33;\nFDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT = 1000;\nFDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT = 5000;\nFDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL = 100.0;\nFDLayoutConstants.MAX_NODE_DISPLACEMENT = FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL * 3;\nFDLayoutConstants.MIN_REPULSION_DIST = FDLayoutConstants.DEFAULT_EDGE_LENGTH / 10.0;\nFDLayoutConstants.CONVERGENCE_CHECK_PERIOD = 100;\nFDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = 0.1;\nFDLayoutConstants.MIN_EDGE_LENGTH = 1;\nFDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD = 10;\n\nmodule.exports = FDLayoutConstants;\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * This class maintains a list of static geometry related utility methods.\n *\n *\n * Copyright: i-Vis Research Group, Bilkent University, 2007 - present\n */\n\nvar Point = __webpack_require__(12);\n\nfunction IGeometry() {}\n\n/**\n * This method calculates *half* the amount in x and y directions of the two\n * input rectangles needed to separate them keeping their respective\n * positioning, and returns the result in the input array. An input\n * separation buffer added to the amount in both directions. We assume that\n * the two rectangles do intersect.\n */\nIGeometry.calcSeparationAmount = function (rectA, rectB, overlapAmount, separationBuffer) {\n  if (!rectA.intersects(rectB)) {\n    throw \"assert failed\";\n  }\n\n  var directions = new Array(2);\n\n  this.decideDirectionsForOverlappingNodes(rectA, rectB, directions);\n\n  overlapAmount[0] = Math.min(rectA.getRight(), rectB.getRight()) - Math.max(rectA.x, rectB.x);\n  overlapAmount[1] = Math.min(rectA.getBottom(), rectB.getBottom()) - Math.max(rectA.y, rectB.y);\n\n  // update the overlapping amounts for the following cases:\n  if (rectA.getX() <= rectB.getX() && rectA.getRight() >= rectB.getRight()) {\n    /* Case x.1:\n    *\n    * rectA\n    * \t|                       |\n    * \t|        _________      |\n    * \t|        |       |      |\n    * \t|________|_______|______|\n    * \t\t\t |       |\n    *           |       |\n    *        rectB\n    */\n    overlapAmount[0] += Math.min(rectB.getX() - rectA.getX(), rectA.getRight() - rectB.getRight());\n  } else if (rectB.getX() <= rectA.getX() && rectB.getRight() >= rectA.getRight()) {\n    /* Case x.2:\n    *\n    * rectB\n    * \t|                       |\n    * \t|        _________      |\n    * \t|        |       |      |\n    * \t|________|_______|______|\n    * \t\t\t |       |\n    *           |       |\n    *        rectA\n    */\n    overlapAmount[0] += Math.min(rectA.getX() - rectB.getX(), rectB.getRight() - rectA.getRight());\n  }\n  if (rectA.getY() <= rectB.getY() && rectA.getBottom() >= rectB.getBottom()) {\n    /* Case y.1:\n     *          ________ rectA\n     *         |\n     *         |\n     *   ______|____  rectB\n     *         |    |\n     *         |    |\n     *   ______|____|\n     *         |\n     *         |\n     *         |________\n     *\n     */\n    overlapAmount[1] += Math.min(rectB.getY() - rectA.getY(), rectA.getBottom() - rectB.getBottom());\n  } else if (rectB.getY() <= rectA.getY() && rectB.getBottom() >= rectA.getBottom()) {\n    /* Case y.2:\n    *          ________ rectB\n    *         |\n    *         |\n    *   ______|____  rectA\n    *         |    |\n    *         |    |\n    *   ______|____|\n    *         |\n    *         |\n    *         |________\n    *\n    */\n    overlapAmount[1] += Math.min(rectA.getY() - rectB.getY(), rectB.getBottom() - rectA.getBottom());\n  }\n\n  // find slope of the line passes two centers\n  var slope = Math.abs((rectB.getCenterY() - rectA.getCenterY()) / (rectB.getCenterX() - rectA.getCenterX()));\n  // if centers are overlapped\n  if (rectB.getCenterY() === rectA.getCenterY() && rectB.getCenterX() === rectA.getCenterX()) {\n    // assume the slope is 1 (45 degree)\n    slope = 1.0;\n  }\n\n  var moveByY = slope * overlapAmount[0];\n  var moveByX = overlapAmount[1] / slope;\n  if (overlapAmount[0] < moveByX) {\n    moveByX = overlapAmount[0];\n  } else {\n    moveByY = overlapAmount[1];\n  }\n  // return half the amount so that if each rectangle is moved by these\n  // amounts in opposite directions, overlap will be resolved\n  overlapAmount[0] = -1 * directions[0] * (moveByX / 2 + separationBuffer);\n  overlapAmount[1] = -1 * directions[1] * (moveByY / 2 + separationBuffer);\n};\n\n/**\n * This method decides the separation direction of overlapping nodes\n *\n * if directions[0] = -1, then rectA goes left\n * if directions[0] = 1,  then rectA goes right\n * if directions[1] = -1, then rectA goes up\n * if directions[1] = 1,  then rectA goes down\n */\nIGeometry.decideDirectionsForOverlappingNodes = function (rectA, rectB, directions) {\n  if (rectA.getCenterX() < rectB.getCenterX()) {\n    directions[0] = -1;\n  } else {\n    directions[0] = 1;\n  }\n\n  if (rectA.getCenterY() < rectB.getCenterY()) {\n    directions[1] = -1;\n  } else {\n    directions[1] = 1;\n  }\n};\n\n/**\n * This method calculates the intersection (clipping) points of the two\n * input rectangles with line segment defined by the centers of these two\n * rectangles. The clipping points are saved in the input double array and\n * whether or not the two rectangles overlap is returned.\n */\nIGeometry.getIntersection2 = function (rectA, rectB, result) {\n  //result[0-1] will contain clipPoint of rectA, result[2-3] will contain clipPoint of rectB\n  var p1x = rectA.getCenterX();\n  var p1y = rectA.getCenterY();\n  var p2x = rectB.getCenterX();\n  var p2y = rectB.getCenterY();\n\n  //if two rectangles intersect, then clipping points are centers\n  if (rectA.intersects(rectB)) {\n    result[0] = p1x;\n    result[1] = p1y;\n    result[2] = p2x;\n    result[3] = p2y;\n    return true;\n  }\n  //variables for rectA\n  var topLeftAx = rectA.getX();\n  var topLeftAy = rectA.getY();\n  var topRightAx = rectA.getRight();\n  var bottomLeftAx = rectA.getX();\n  var bottomLeftAy = rectA.getBottom();\n  var bottomRightAx = rectA.getRight();\n  var halfWidthA = rectA.getWidthHalf();\n  var halfHeightA = rectA.getHeightHalf();\n  //variables for rectB\n  var topLeftBx = rectB.getX();\n  var topLeftBy = rectB.getY();\n  var topRightBx = rectB.getRight();\n  var bottomLeftBx = rectB.getX();\n  var bottomLeftBy = rectB.getBottom();\n  var bottomRightBx = rectB.getRight();\n  var halfWidthB = rectB.getWidthHalf();\n  var halfHeightB = rectB.getHeightHalf();\n\n  //flag whether clipping points are found\n  var clipPointAFound = false;\n  var clipPointBFound = false;\n\n  // line is vertical\n  if (p1x === p2x) {\n    if (p1y > p2y) {\n      result[0] = p1x;\n      result[1] = topLeftAy;\n      result[2] = p2x;\n      result[3] = bottomLeftBy;\n      return false;\n    } else if (p1y < p2y) {\n      result[0] = p1x;\n      result[1] = bottomLeftAy;\n      result[2] = p2x;\n      result[3] = topLeftBy;\n      return false;\n    } else {\n      //not line, return null;\n    }\n  }\n  // line is horizontal\n  else if (p1y === p2y) {\n      if (p1x > p2x) {\n        result[0] = topLeftAx;\n        result[1] = p1y;\n        result[2] = topRightBx;\n        result[3] = p2y;\n        return false;\n      } else if (p1x < p2x) {\n        result[0] = topRightAx;\n        result[1] = p1y;\n        result[2] = topLeftBx;\n        result[3] = p2y;\n        return false;\n      } else {\n        //not valid line, return null;\n      }\n    } else {\n      //slopes of rectA's and rectB's diagonals\n      var slopeA = rectA.height / rectA.width;\n      var slopeB = rectB.height / rectB.width;\n\n      //slope of line between center of rectA and center of rectB\n      var slopePrime = (p2y - p1y) / (p2x - p1x);\n      var cardinalDirectionA = void 0;\n      var cardinalDirectionB = void 0;\n      var tempPointAx = void 0;\n      var tempPointAy = void 0;\n      var tempPointBx = void 0;\n      var tempPointBy = void 0;\n\n      //determine whether clipping point is the corner of nodeA\n      if (-slopeA === slopePrime) {\n        if (p1x > p2x) {\n          result[0] = bottomLeftAx;\n          result[1] = bottomLeftAy;\n          clipPointAFound = true;\n        } else {\n          result[0] = topRightAx;\n          result[1] = topLeftAy;\n          clipPointAFound = true;\n        }\n      } else if (slopeA === slopePrime) {\n        if (p1x > p2x) {\n          result[0] = topLeftAx;\n          result[1] = topLeftAy;\n          clipPointAFound = true;\n        } else {\n          result[0] = bottomRightAx;\n          result[1] = bottomLeftAy;\n          clipPointAFound = true;\n        }\n      }\n\n      //determine whether clipping point is the corner of nodeB\n      if (-slopeB === slopePrime) {\n        if (p2x > p1x) {\n          result[2] = bottomLeftBx;\n          result[3] = bottomLeftBy;\n          clipPointBFound = true;\n        } else {\n          result[2] = topRightBx;\n          result[3] = topLeftBy;\n          clipPointBFound = true;\n        }\n      } else if (slopeB === slopePrime) {\n        if (p2x > p1x) {\n          result[2] = topLeftBx;\n          result[3] = topLeftBy;\n          clipPointBFound = true;\n        } else {\n          result[2] = bottomRightBx;\n          result[3] = bottomLeftBy;\n          clipPointBFound = true;\n        }\n      }\n\n      //if both clipping points are corners\n      if (clipPointAFound && clipPointBFound) {\n        return false;\n      }\n\n      //determine Cardinal Direction of rectangles\n      if (p1x > p2x) {\n        if (p1y > p2y) {\n          cardinalDirectionA = this.getCardinalDirection(slopeA, slopePrime, 4);\n          cardinalDirectionB = this.getCardinalDirection(slopeB, slopePrime, 2);\n        } else {\n          cardinalDirectionA = this.getCardinalDirection(-slopeA, slopePrime, 3);\n          cardinalDirectionB = this.getCardinalDirection(-slopeB, slopePrime, 1);\n        }\n      } else {\n        if (p1y > p2y) {\n          cardinalDirectionA = this.getCardinalDirection(-slopeA, slopePrime, 1);\n          cardinalDirectionB = this.getCardinalDirection(-slopeB, slopePrime, 3);\n        } else {\n          cardinalDirectionA = this.getCardinalDirection(slopeA, slopePrime, 2);\n          cardinalDirectionB = this.getCardinalDirection(slopeB, slopePrime, 4);\n        }\n      }\n      //calculate clipping Point if it is not found before\n      if (!clipPointAFound) {\n        switch (cardinalDirectionA) {\n          case 1:\n            tempPointAy = topLeftAy;\n            tempPointAx = p1x + -halfHeightA / slopePrime;\n            result[0] = tempPointAx;\n            result[1] = tempPointAy;\n            break;\n          case 2:\n            tempPointAx = bottomRightAx;\n            tempPointAy = p1y + halfWidthA * slopePrime;\n            result[0] = tempPointAx;\n            result[1] = tempPointAy;\n            break;\n          case 3:\n            tempPointAy = bottomLeftAy;\n            tempPointAx = p1x + halfHeightA / slopePrime;\n            result[0] = tempPointAx;\n            result[1] = tempPointAy;\n            break;\n          case 4:\n            tempPointAx = bottomLeftAx;\n            tempPointAy = p1y + -halfWidthA * slopePrime;\n            result[0] = tempPointAx;\n            result[1] = tempPointAy;\n            break;\n        }\n      }\n      if (!clipPointBFound) {\n        switch (cardinalDirectionB) {\n          case 1:\n            tempPointBy = topLeftBy;\n            tempPointBx = p2x + -halfHeightB / slopePrime;\n            result[2] = tempPointBx;\n            result[3] = tempPointBy;\n            break;\n          case 2:\n            tempPointBx = bottomRightBx;\n            tempPointBy = p2y + halfWidthB * slopePrime;\n            result[2] = tempPointBx;\n            result[3] = tempPointBy;\n            break;\n          case 3:\n            tempPointBy = bottomLeftBy;\n            tempPointBx = p2x + halfHeightB / slopePrime;\n            result[2] = tempPointBx;\n            result[3] = tempPointBy;\n            break;\n          case 4:\n            tempPointBx = bottomLeftBx;\n            tempPointBy = p2y + -halfWidthB * slopePrime;\n            result[2] = tempPointBx;\n            result[3] = tempPointBy;\n            break;\n        }\n      }\n    }\n  return false;\n};\n\n/**\n * This method returns in which cardinal direction does input point stays\n * 1: North\n * 2: East\n * 3: South\n * 4: West\n */\nIGeometry.getCardinalDirection = function (slope, slopePrime, line) {\n  if (slope > slopePrime) {\n    return line;\n  } else {\n    return 1 + line % 4;\n  }\n};\n\n/**\n * This method calculates the intersection of the two lines defined by\n * point pairs (s1,s2) and (f1,f2).\n */\nIGeometry.getIntersection = function (s1, s2, f1, f2) {\n  if (f2 == null) {\n    return this.getIntersection2(s1, s2, f1);\n  }\n\n  var x1 = s1.x;\n  var y1 = s1.y;\n  var x2 = s2.x;\n  var y2 = s2.y;\n  var x3 = f1.x;\n  var y3 = f1.y;\n  var x4 = f2.x;\n  var y4 = f2.y;\n  var x = void 0,\n      y = void 0; // intersection point\n  var a1 = void 0,\n      a2 = void 0,\n      b1 = void 0,\n      b2 = void 0,\n      c1 = void 0,\n      c2 = void 0; // coefficients of line eqns.\n  var denom = void 0;\n\n  a1 = y2 - y1;\n  b1 = x1 - x2;\n  c1 = x2 * y1 - x1 * y2; // { a1*x + b1*y + c1 = 0 is line 1 }\n\n  a2 = y4 - y3;\n  b2 = x3 - x4;\n  c2 = x4 * y3 - x3 * y4; // { a2*x + b2*y + c2 = 0 is line 2 }\n\n  denom = a1 * b2 - a2 * b1;\n\n  if (denom === 0) {\n    return null;\n  }\n\n  x = (b1 * c2 - b2 * c1) / denom;\n  y = (a2 * c1 - a1 * c2) / denom;\n\n  return new Point(x, y);\n};\n\n/**\n * This method finds and returns the angle of the vector from the + x-axis\n * in clockwise direction (compatible w/ Java coordinate system!).\n */\nIGeometry.angleOfVector = function (Cx, Cy, Nx, Ny) {\n  var C_angle = void 0;\n\n  if (Cx !== Nx) {\n    C_angle = Math.atan((Ny - Cy) / (Nx - Cx));\n\n    if (Nx < Cx) {\n      C_angle += Math.PI;\n    } else if (Ny < Cy) {\n      C_angle += this.TWO_PI;\n    }\n  } else if (Ny < Cy) {\n    C_angle = this.ONE_AND_HALF_PI; // 270 degrees\n  } else {\n    C_angle = this.HALF_PI; // 90 degrees\n  }\n\n  return C_angle;\n};\n\n/**\n * This method checks whether the given two line segments (one with point\n * p1 and p2, the other with point p3 and p4) intersect at a point other\n * than these points.\n */\nIGeometry.doIntersect = function (p1, p2, p3, p4) {\n  var a = p1.x;\n  var b = p1.y;\n  var c = p2.x;\n  var d = p2.y;\n  var p = p3.x;\n  var q = p3.y;\n  var r = p4.x;\n  var s = p4.y;\n  var det = (c - a) * (s - q) - (r - p) * (d - b);\n\n  if (det === 0) {\n    return false;\n  } else {\n    var lambda = ((s - q) * (r - a) + (p - r) * (s - b)) / det;\n    var gamma = ((b - d) * (r - a) + (c - a) * (s - b)) / det;\n    return 0 < lambda && lambda < 1 && 0 < gamma && gamma < 1;\n  }\n};\n\n// -----------------------------------------------------------------------------\n// Section: Class Constants\n// -----------------------------------------------------------------------------\n/**\n * Some useful pre-calculated constants\n */\nIGeometry.HALF_PI = 0.5 * Math.PI;\nIGeometry.ONE_AND_HALF_PI = 1.5 * Math.PI;\nIGeometry.TWO_PI = 2.0 * Math.PI;\nIGeometry.THREE_PI = 3.0 * Math.PI;\n\nmodule.exports = IGeometry;\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction IMath() {}\n\n/**\n * This method returns the sign of the input value.\n */\nIMath.sign = function (value) {\n  if (value > 0) {\n    return 1;\n  } else if (value < 0) {\n    return -1;\n  } else {\n    return 0;\n  }\n};\n\nIMath.floor = function (value) {\n  return value < 0 ? Math.ceil(value) : Math.floor(value);\n};\n\nIMath.ceil = function (value) {\n  return value < 0 ? Math.floor(value) : Math.ceil(value);\n};\n\nmodule.exports = IMath;\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction Integer() {}\n\nInteger.MAX_VALUE = 2147483647;\nInteger.MIN_VALUE = -2147483648;\n\nmodule.exports = Integer;\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar nodeFrom = function nodeFrom(value) {\n  return { value: value, next: null, prev: null };\n};\n\nvar add = function add(prev, node, next, list) {\n  if (prev !== null) {\n    prev.next = node;\n  } else {\n    list.head = node;\n  }\n\n  if (next !== null) {\n    next.prev = node;\n  } else {\n    list.tail = node;\n  }\n\n  node.prev = prev;\n  node.next = next;\n\n  list.length++;\n\n  return node;\n};\n\nvar _remove = function _remove(node, list) {\n  var prev = node.prev,\n      next = node.next;\n\n\n  if (prev !== null) {\n    prev.next = next;\n  } else {\n    list.head = next;\n  }\n\n  if (next !== null) {\n    next.prev = prev;\n  } else {\n    list.tail = prev;\n  }\n\n  node.prev = node.next = null;\n\n  list.length--;\n\n  return node;\n};\n\nvar LinkedList = function () {\n  function LinkedList(vals) {\n    var _this = this;\n\n    _classCallCheck(this, LinkedList);\n\n    this.length = 0;\n    this.head = null;\n    this.tail = null;\n\n    if (vals != null) {\n      vals.forEach(function (v) {\n        return _this.push(v);\n      });\n    }\n  }\n\n  _createClass(LinkedList, [{\n    key: \"size\",\n    value: function size() {\n      return this.length;\n    }\n  }, {\n    key: \"insertBefore\",\n    value: function insertBefore(val, otherNode) {\n      return add(otherNode.prev, nodeFrom(val), otherNode, this);\n    }\n  }, {\n    key: \"insertAfter\",\n    value: function insertAfter(val, otherNode) {\n      return add(otherNode, nodeFrom(val), otherNode.next, this);\n    }\n  }, {\n    key: \"insertNodeBefore\",\n    value: function insertNodeBefore(newNode, otherNode) {\n      return add(otherNode.prev, newNode, otherNode, this);\n    }\n  }, {\n    key: \"insertNodeAfter\",\n    value: function insertNodeAfter(newNode, otherNode) {\n      return add(otherNode, newNode, otherNode.next, this);\n    }\n  }, {\n    key: \"push\",\n    value: function push(val) {\n      return add(this.tail, nodeFrom(val), null, this);\n    }\n  }, {\n    key: \"unshift\",\n    value: function unshift(val) {\n      return add(null, nodeFrom(val), this.head, this);\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(node) {\n      return _remove(node, this);\n    }\n  }, {\n    key: \"pop\",\n    value: function pop() {\n      return _remove(this.tail, this).value;\n    }\n  }, {\n    key: \"popNode\",\n    value: function popNode() {\n      return _remove(this.tail, this);\n    }\n  }, {\n    key: \"shift\",\n    value: function shift() {\n      return _remove(this.head, this).value;\n    }\n  }, {\n    key: \"shiftNode\",\n    value: function shiftNode() {\n      return _remove(this.head, this);\n    }\n  }, {\n    key: \"get_object_at\",\n    value: function get_object_at(index) {\n      if (index <= this.length()) {\n        var i = 1;\n        var current = this.head;\n        while (i < index) {\n          current = current.next;\n          i++;\n        }\n        return current.value;\n      }\n    }\n  }, {\n    key: \"set_object_at\",\n    value: function set_object_at(index, value) {\n      if (index <= this.length()) {\n        var i = 1;\n        var current = this.head;\n        while (i < index) {\n          current = current.next;\n          i++;\n        }\n        current.value = value;\n      }\n    }\n  }]);\n\n  return LinkedList;\n}();\n\nmodule.exports = LinkedList;\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/*\r\n *This class is the javascript implementation of the Point.java class in jdk\r\n */\nfunction Point(x, y, p) {\n  this.x = null;\n  this.y = null;\n  if (x == null && y == null && p == null) {\n    this.x = 0;\n    this.y = 0;\n  } else if (typeof x == 'number' && typeof y == 'number' && p == null) {\n    this.x = x;\n    this.y = y;\n  } else if (x.constructor.name == 'Point' && y == null && p == null) {\n    p = x;\n    this.x = p.x;\n    this.y = p.y;\n  }\n}\n\nPoint.prototype.getX = function () {\n  return this.x;\n};\n\nPoint.prototype.getY = function () {\n  return this.y;\n};\n\nPoint.prototype.getLocation = function () {\n  return new Point(this.x, this.y);\n};\n\nPoint.prototype.setLocation = function (x, y, p) {\n  if (x.constructor.name == 'Point' && y == null && p == null) {\n    p = x;\n    this.setLocation(p.x, p.y);\n  } else if (typeof x == 'number' && typeof y == 'number' && p == null) {\n    //if both parameters are integer just move (x,y) location\n    if (parseInt(x) == x && parseInt(y) == y) {\n      this.move(x, y);\n    } else {\n      this.x = Math.floor(x + 0.5);\n      this.y = Math.floor(y + 0.5);\n    }\n  }\n};\n\nPoint.prototype.move = function (x, y) {\n  this.x = x;\n  this.y = y;\n};\n\nPoint.prototype.translate = function (dx, dy) {\n  this.x += dx;\n  this.y += dy;\n};\n\nPoint.prototype.equals = function (obj) {\n  if (obj.constructor.name == \"Point\") {\n    var pt = obj;\n    return this.x == pt.x && this.y == pt.y;\n  }\n  return this == obj;\n};\n\nPoint.prototype.toString = function () {\n  return new Point().constructor.name + \"[x=\" + this.x + \",y=\" + this.y + \"]\";\n};\n\nmodule.exports = Point;\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction RectangleD(x, y, width, height) {\n  this.x = 0;\n  this.y = 0;\n  this.width = 0;\n  this.height = 0;\n\n  if (x != null && y != null && width != null && height != null) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n  }\n}\n\nRectangleD.prototype.getX = function () {\n  return this.x;\n};\n\nRectangleD.prototype.setX = function (x) {\n  this.x = x;\n};\n\nRectangleD.prototype.getY = function () {\n  return this.y;\n};\n\nRectangleD.prototype.setY = function (y) {\n  this.y = y;\n};\n\nRectangleD.prototype.getWidth = function () {\n  return this.width;\n};\n\nRectangleD.prototype.setWidth = function (width) {\n  this.width = width;\n};\n\nRectangleD.prototype.getHeight = function () {\n  return this.height;\n};\n\nRectangleD.prototype.setHeight = function (height) {\n  this.height = height;\n};\n\nRectangleD.prototype.getRight = function () {\n  return this.x + this.width;\n};\n\nRectangleD.prototype.getBottom = function () {\n  return this.y + this.height;\n};\n\nRectangleD.prototype.intersects = function (a) {\n  if (this.getRight() < a.x) {\n    return false;\n  }\n\n  if (this.getBottom() < a.y) {\n    return false;\n  }\n\n  if (a.getRight() < this.x) {\n    return false;\n  }\n\n  if (a.getBottom() < this.y) {\n    return false;\n  }\n\n  return true;\n};\n\nRectangleD.prototype.getCenterX = function () {\n  return this.x + this.width / 2;\n};\n\nRectangleD.prototype.getMinX = function () {\n  return this.getX();\n};\n\nRectangleD.prototype.getMaxX = function () {\n  return this.getX() + this.width;\n};\n\nRectangleD.prototype.getCenterY = function () {\n  return this.y + this.height / 2;\n};\n\nRectangleD.prototype.getMinY = function () {\n  return this.getY();\n};\n\nRectangleD.prototype.getMaxY = function () {\n  return this.getY() + this.height;\n};\n\nRectangleD.prototype.getWidthHalf = function () {\n  return this.width / 2;\n};\n\nRectangleD.prototype.getHeightHalf = function () {\n  return this.height / 2;\n};\n\nmodule.exports = RectangleD;\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction UniqueIDGeneretor() {}\n\nUniqueIDGeneretor.lastID = 0;\n\nUniqueIDGeneretor.createID = function (obj) {\n  if (UniqueIDGeneretor.isPrimitive(obj)) {\n    return obj;\n  }\n  if (obj.uniqueID != null) {\n    return obj.uniqueID;\n  }\n  obj.uniqueID = UniqueIDGeneretor.getString();\n  UniqueIDGeneretor.lastID++;\n  return obj.uniqueID;\n};\n\nUniqueIDGeneretor.getString = function (id) {\n  if (id == null) id = UniqueIDGeneretor.lastID;\n  return \"Object#\" + id + \"\";\n};\n\nUniqueIDGeneretor.isPrimitive = function (arg) {\n  var type = typeof arg === \"undefined\" ? \"undefined\" : _typeof(arg);\n  return arg == null || type != \"object\" && type != \"function\";\n};\n\nmodule.exports = UniqueIDGeneretor;\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar LayoutConstants = __webpack_require__(0);\nvar LGraphManager = __webpack_require__(6);\nvar LNode = __webpack_require__(3);\nvar LEdge = __webpack_require__(1);\nvar LGraph = __webpack_require__(5);\nvar PointD = __webpack_require__(4);\nvar Transform = __webpack_require__(17);\nvar Emitter = __webpack_require__(27);\n\nfunction Layout(isRemoteUse) {\n  Emitter.call(this);\n\n  //Layout Quality: 0:draft, 1:default, 2:proof\n  this.layoutQuality = LayoutConstants.QUALITY;\n  //Whether layout should create bendpoints as needed or not\n  this.createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n  //Whether layout should be incremental or not\n  this.incremental = LayoutConstants.DEFAULT_INCREMENTAL;\n  //Whether we animate from before to after layout node positions\n  this.animationOnLayout = LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT;\n  //Whether we animate the layout process or not\n  this.animationDuringLayout = LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT;\n  //Number iterations that should be done between two successive animations\n  this.animationPeriod = LayoutConstants.DEFAULT_ANIMATION_PERIOD;\n  /**\r\n   * Whether or not leaf nodes (non-compound nodes) are of uniform sizes. When\r\n   * they are, both spring and repulsion forces between two leaf nodes can be\r\n   * calculated without the expensive clipping point calculations, resulting\r\n   * in major speed-up.\r\n   */\n  this.uniformLeafNodeSizes = LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES;\n  /**\r\n   * This is used for creation of bendpoints by using dummy nodes and edges.\r\n   * Maps an LEdge to its dummy bendpoint path.\r\n   */\n  this.edgeToDummyNodes = new Map();\n  this.graphManager = new LGraphManager(this);\n  this.isLayoutFinished = false;\n  this.isSubLayout = false;\n  this.isRemoteUse = false;\n\n  if (isRemoteUse != null) {\n    this.isRemoteUse = isRemoteUse;\n  }\n}\n\nLayout.RANDOM_SEED = 1;\n\nLayout.prototype = Object.create(Emitter.prototype);\n\nLayout.prototype.getGraphManager = function () {\n  return this.graphManager;\n};\n\nLayout.prototype.getAllNodes = function () {\n  return this.graphManager.getAllNodes();\n};\n\nLayout.prototype.getAllEdges = function () {\n  return this.graphManager.getAllEdges();\n};\n\nLayout.prototype.getAllNodesToApplyGravitation = function () {\n  return this.graphManager.getAllNodesToApplyGravitation();\n};\n\nLayout.prototype.newGraphManager = function () {\n  var gm = new LGraphManager(this);\n  this.graphManager = gm;\n  return gm;\n};\n\nLayout.prototype.newGraph = function (vGraph) {\n  return new LGraph(null, this.graphManager, vGraph);\n};\n\nLayout.prototype.newNode = function (vNode) {\n  return new LNode(this.graphManager, vNode);\n};\n\nLayout.prototype.newEdge = function (vEdge) {\n  return new LEdge(null, null, vEdge);\n};\n\nLayout.prototype.checkLayoutSuccess = function () {\n  return this.graphManager.getRoot() == null || this.graphManager.getRoot().getNodes().length == 0 || this.graphManager.includesInvalidEdge();\n};\n\nLayout.prototype.runLayout = function () {\n  this.isLayoutFinished = false;\n\n  if (this.tilingPreLayout) {\n    this.tilingPreLayout();\n  }\n\n  this.initParameters();\n  var isLayoutSuccessfull;\n\n  if (this.checkLayoutSuccess()) {\n    isLayoutSuccessfull = false;\n  } else {\n    isLayoutSuccessfull = this.layout();\n  }\n\n  if (LayoutConstants.ANIMATE === 'during') {\n    // If this is a 'during' layout animation. Layout is not finished yet. \n    // We need to perform these in index.js when layout is really finished.\n    return false;\n  }\n\n  if (isLayoutSuccessfull) {\n    if (!this.isSubLayout) {\n      this.doPostLayout();\n    }\n  }\n\n  if (this.tilingPostLayout) {\n    this.tilingPostLayout();\n  }\n\n  this.isLayoutFinished = true;\n\n  return isLayoutSuccessfull;\n};\n\n/**\r\n * This method performs the operations required after layout.\r\n */\nLayout.prototype.doPostLayout = function () {\n  //assert !isSubLayout : \"Should not be called on sub-layout!\";\n  // Propagate geometric changes to v-level objects\n  if (!this.incremental) {\n    this.transform();\n  }\n  this.update();\n};\n\n/**\r\n * This method updates the geometry of the target graph according to\r\n * calculated layout.\r\n */\nLayout.prototype.update2 = function () {\n  // update bend points\n  if (this.createBendsAsNeeded) {\n    this.createBendpointsFromDummyNodes();\n\n    // reset all edges, since the topology has changed\n    this.graphManager.resetAllEdges();\n  }\n\n  // perform edge, node and root updates if layout is not called\n  // remotely\n  if (!this.isRemoteUse) {\n    // update all edges\n    var edge;\n    var allEdges = this.graphManager.getAllEdges();\n    for (var i = 0; i < allEdges.length; i++) {\n      edge = allEdges[i];\n      //      this.update(edge);\n    }\n\n    // recursively update nodes\n    var node;\n    var nodes = this.graphManager.getRoot().getNodes();\n    for (var i = 0; i < nodes.length; i++) {\n      node = nodes[i];\n      //      this.update(node);\n    }\n\n    // update root graph\n    this.update(this.graphManager.getRoot());\n  }\n};\n\nLayout.prototype.update = function (obj) {\n  if (obj == null) {\n    this.update2();\n  } else if (obj instanceof LNode) {\n    var node = obj;\n    if (node.getChild() != null) {\n      // since node is compound, recursively update child nodes\n      var nodes = node.getChild().getNodes();\n      for (var i = 0; i < nodes.length; i++) {\n        update(nodes[i]);\n      }\n    }\n\n    // if the l-level node is associated with a v-level graph object,\n    // then it is assumed that the v-level node implements the\n    // interface Updatable.\n    if (node.vGraphObject != null) {\n      // cast to Updatable without any type check\n      var vNode = node.vGraphObject;\n\n      // call the update method of the interface\n      vNode.update(node);\n    }\n  } else if (obj instanceof LEdge) {\n    var edge = obj;\n    // if the l-level edge is associated with a v-level graph object,\n    // then it is assumed that the v-level edge implements the\n    // interface Updatable.\n\n    if (edge.vGraphObject != null) {\n      // cast to Updatable without any type check\n      var vEdge = edge.vGraphObject;\n\n      // call the update method of the interface\n      vEdge.update(edge);\n    }\n  } else if (obj instanceof LGraph) {\n    var graph = obj;\n    // if the l-level graph is associated with a v-level graph object,\n    // then it is assumed that the v-level object implements the\n    // interface Updatable.\n\n    if (graph.vGraphObject != null) {\n      // cast to Updatable without any type check\n      var vGraph = graph.vGraphObject;\n\n      // call the update method of the interface\n      vGraph.update(graph);\n    }\n  }\n};\n\n/**\r\n * This method is used to set all layout parameters to default values\r\n * determined at compile time.\r\n */\nLayout.prototype.initParameters = function () {\n  if (!this.isSubLayout) {\n    this.layoutQuality = LayoutConstants.QUALITY;\n    this.animationDuringLayout = LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT;\n    this.animationPeriod = LayoutConstants.DEFAULT_ANIMATION_PERIOD;\n    this.animationOnLayout = LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT;\n    this.incremental = LayoutConstants.DEFAULT_INCREMENTAL;\n    this.createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n    this.uniformLeafNodeSizes = LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES;\n  }\n\n  if (this.animationDuringLayout) {\n    this.animationOnLayout = false;\n  }\n};\n\nLayout.prototype.transform = function (newLeftTop) {\n  if (newLeftTop == undefined) {\n    this.transform(new PointD(0, 0));\n  } else {\n    // create a transformation object (from Eclipse to layout). When an\n    // inverse transform is applied, we get upper-left coordinate of the\n    // drawing or the root graph at given input coordinate (some margins\n    // already included in calculation of left-top).\n\n    var trans = new Transform();\n    var leftTop = this.graphManager.getRoot().updateLeftTop();\n\n    if (leftTop != null) {\n      trans.setWorldOrgX(newLeftTop.x);\n      trans.setWorldOrgY(newLeftTop.y);\n\n      trans.setDeviceOrgX(leftTop.x);\n      trans.setDeviceOrgY(leftTop.y);\n\n      var nodes = this.getAllNodes();\n      var node;\n\n      for (var i = 0; i < nodes.length; i++) {\n        node = nodes[i];\n        node.transform(trans);\n      }\n    }\n  }\n};\n\nLayout.prototype.positionNodesRandomly = function (graph) {\n\n  if (graph == undefined) {\n    //assert !this.incremental;\n    this.positionNodesRandomly(this.getGraphManager().getRoot());\n    this.getGraphManager().getRoot().updateBounds(true);\n  } else {\n    var lNode;\n    var childGraph;\n\n    var nodes = graph.getNodes();\n    for (var i = 0; i < nodes.length; i++) {\n      lNode = nodes[i];\n      childGraph = lNode.getChild();\n\n      if (childGraph == null) {\n        lNode.scatter();\n      } else if (childGraph.getNodes().length == 0) {\n        lNode.scatter();\n      } else {\n        this.positionNodesRandomly(childGraph);\n        lNode.updateBounds();\n      }\n    }\n  }\n};\n\n/**\r\n * This method returns a list of trees where each tree is represented as a\r\n * list of l-nodes. The method returns a list of size 0 when:\r\n * - The graph is not flat or\r\n * - One of the component(s) of the graph is not a tree.\r\n */\nLayout.prototype.getFlatForest = function () {\n  var flatForest = [];\n  var isForest = true;\n\n  // Quick reference for all nodes in the graph manager associated with\n  // this layout. The list should not be changed.\n  var allNodes = this.graphManager.getRoot().getNodes();\n\n  // First be sure that the graph is flat\n  var isFlat = true;\n\n  for (var i = 0; i < allNodes.length; i++) {\n    if (allNodes[i].getChild() != null) {\n      isFlat = false;\n    }\n  }\n\n  // Return empty forest if the graph is not flat.\n  if (!isFlat) {\n    return flatForest;\n  }\n\n  // Run BFS for each component of the graph.\n\n  var visited = new Set();\n  var toBeVisited = [];\n  var parents = new Map();\n  var unProcessedNodes = [];\n\n  unProcessedNodes = unProcessedNodes.concat(allNodes);\n\n  // Each iteration of this loop finds a component of the graph and\n  // decides whether it is a tree or not. If it is a tree, adds it to the\n  // forest and continued with the next component.\n\n  while (unProcessedNodes.length > 0 && isForest) {\n    toBeVisited.push(unProcessedNodes[0]);\n\n    // Start the BFS. Each iteration of this loop visits a node in a\n    // BFS manner.\n    while (toBeVisited.length > 0 && isForest) {\n      //pool operation\n      var currentNode = toBeVisited[0];\n      toBeVisited.splice(0, 1);\n      visited.add(currentNode);\n\n      // Traverse all neighbors of this node\n      var neighborEdges = currentNode.getEdges();\n\n      for (var i = 0; i < neighborEdges.length; i++) {\n        var currentNeighbor = neighborEdges[i].getOtherEnd(currentNode);\n\n        // If BFS is not growing from this neighbor.\n        if (parents.get(currentNode) != currentNeighbor) {\n          // We haven't previously visited this neighbor.\n          if (!visited.has(currentNeighbor)) {\n            toBeVisited.push(currentNeighbor);\n            parents.set(currentNeighbor, currentNode);\n          }\n          // Since we have previously visited this neighbor and\n          // this neighbor is not parent of currentNode, given\n          // graph contains a component that is not tree, hence\n          // it is not a forest.\n          else {\n              isForest = false;\n              break;\n            }\n        }\n      }\n    }\n\n    // The graph contains a component that is not a tree. Empty\n    // previously found trees. The method will end.\n    if (!isForest) {\n      flatForest = [];\n    }\n    // Save currently visited nodes as a tree in our forest. Reset\n    // visited and parents lists. Continue with the next component of\n    // the graph, if any.\n    else {\n        var temp = [].concat(_toConsumableArray(visited));\n        flatForest.push(temp);\n        //flatForest = flatForest.concat(temp);\n        //unProcessedNodes.removeAll(visited);\n        for (var i = 0; i < temp.length; i++) {\n          var value = temp[i];\n          var index = unProcessedNodes.indexOf(value);\n          if (index > -1) {\n            unProcessedNodes.splice(index, 1);\n          }\n        }\n        visited = new Set();\n        parents = new Map();\n      }\n  }\n\n  return flatForest;\n};\n\n/**\r\n * This method creates dummy nodes (an l-level node with minimal dimensions)\r\n * for the given edge (one per bendpoint). The existing l-level structure\r\n * is updated accordingly.\r\n */\nLayout.prototype.createDummyNodesForBendpoints = function (edge) {\n  var dummyNodes = [];\n  var prev = edge.source;\n\n  var graph = this.graphManager.calcLowestCommonAncestor(edge.source, edge.target);\n\n  for (var i = 0; i < edge.bendpoints.length; i++) {\n    // create new dummy node\n    var dummyNode = this.newNode(null);\n    dummyNode.setRect(new Point(0, 0), new Dimension(1, 1));\n\n    graph.add(dummyNode);\n\n    // create new dummy edge between prev and dummy node\n    var dummyEdge = this.newEdge(null);\n    this.graphManager.add(dummyEdge, prev, dummyNode);\n\n    dummyNodes.add(dummyNode);\n    prev = dummyNode;\n  }\n\n  var dummyEdge = this.newEdge(null);\n  this.graphManager.add(dummyEdge, prev, edge.target);\n\n  this.edgeToDummyNodes.set(edge, dummyNodes);\n\n  // remove real edge from graph manager if it is inter-graph\n  if (edge.isInterGraph()) {\n    this.graphManager.remove(edge);\n  }\n  // else, remove the edge from the current graph\n  else {\n      graph.remove(edge);\n    }\n\n  return dummyNodes;\n};\n\n/**\r\n * This method creates bendpoints for edges from the dummy nodes\r\n * at l-level.\r\n */\nLayout.prototype.createBendpointsFromDummyNodes = function () {\n  var edges = [];\n  edges = edges.concat(this.graphManager.getAllEdges());\n  edges = [].concat(_toConsumableArray(this.edgeToDummyNodes.keys())).concat(edges);\n\n  for (var k = 0; k < edges.length; k++) {\n    var lEdge = edges[k];\n\n    if (lEdge.bendpoints.length > 0) {\n      var path = this.edgeToDummyNodes.get(lEdge);\n\n      for (var i = 0; i < path.length; i++) {\n        var dummyNode = path[i];\n        var p = new PointD(dummyNode.getCenterX(), dummyNode.getCenterY());\n\n        // update bendpoint's location according to dummy node\n        var ebp = lEdge.bendpoints.get(i);\n        ebp.x = p.x;\n        ebp.y = p.y;\n\n        // remove the dummy node, dummy edges incident with this\n        // dummy node is also removed (within the remove method)\n        dummyNode.getOwner().remove(dummyNode);\n      }\n\n      // add the real edge to graph\n      this.graphManager.add(lEdge, lEdge.source, lEdge.target);\n    }\n  }\n};\n\nLayout.transform = function (sliderValue, defaultValue, minDiv, maxMul) {\n  if (minDiv != undefined && maxMul != undefined) {\n    var value = defaultValue;\n\n    if (sliderValue <= 50) {\n      var minValue = defaultValue / minDiv;\n      value -= (defaultValue - minValue) / 50 * (50 - sliderValue);\n    } else {\n      var maxValue = defaultValue * maxMul;\n      value += (maxValue - defaultValue) / 50 * (sliderValue - 50);\n    }\n\n    return value;\n  } else {\n    var a, b;\n\n    if (sliderValue <= 50) {\n      a = 9.0 * defaultValue / 500.0;\n      b = defaultValue / 10.0;\n    } else {\n      a = 9.0 * defaultValue / 50.0;\n      b = -8 * defaultValue;\n    }\n\n    return a * sliderValue + b;\n  }\n};\n\n/**\r\n * This method finds and returns the center of the given nodes, assuming\r\n * that the given nodes form a tree in themselves.\r\n */\nLayout.findCenterOfTree = function (nodes) {\n  var list = [];\n  list = list.concat(nodes);\n\n  var removedNodes = [];\n  var remainingDegrees = new Map();\n  var foundCenter = false;\n  var centerNode = null;\n\n  if (list.length == 1 || list.length == 2) {\n    foundCenter = true;\n    centerNode = list[0];\n  }\n\n  for (var i = 0; i < list.length; i++) {\n    var node = list[i];\n    var degree = node.getNeighborsList().size;\n    remainingDegrees.set(node, node.getNeighborsList().size);\n\n    if (degree == 1) {\n      removedNodes.push(node);\n    }\n  }\n\n  var tempList = [];\n  tempList = tempList.concat(removedNodes);\n\n  while (!foundCenter) {\n    var tempList2 = [];\n    tempList2 = tempList2.concat(tempList);\n    tempList = [];\n\n    for (var i = 0; i < list.length; i++) {\n      var node = list[i];\n\n      var index = list.indexOf(node);\n      if (index >= 0) {\n        list.splice(index, 1);\n      }\n\n      var neighbours = node.getNeighborsList();\n\n      neighbours.forEach(function (neighbour) {\n        if (removedNodes.indexOf(neighbour) < 0) {\n          var otherDegree = remainingDegrees.get(neighbour);\n          var newDegree = otherDegree - 1;\n\n          if (newDegree == 1) {\n            tempList.push(neighbour);\n          }\n\n          remainingDegrees.set(neighbour, newDegree);\n        }\n      });\n    }\n\n    removedNodes = removedNodes.concat(tempList);\n\n    if (list.length == 1 || list.length == 2) {\n      foundCenter = true;\n      centerNode = list[0];\n    }\n  }\n\n  return centerNode;\n};\n\n/**\r\n * During the coarsening process, this layout may be referenced by two graph managers\r\n * this setter function grants access to change the currently being used graph manager\r\n */\nLayout.prototype.setGraphManager = function (gm) {\n  this.graphManager = gm;\n};\n\nmodule.exports = Layout;\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction RandomSeed() {}\n// adapted from: https://stackoverflow.com/a/19303725\nRandomSeed.seed = 1;\nRandomSeed.x = 0;\n\nRandomSeed.nextDouble = function () {\n  RandomSeed.x = Math.sin(RandomSeed.seed++) * 10000;\n  return RandomSeed.x - Math.floor(RandomSeed.x);\n};\n\nmodule.exports = RandomSeed;\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar PointD = __webpack_require__(4);\n\nfunction Transform(x, y) {\n  this.lworldOrgX = 0.0;\n  this.lworldOrgY = 0.0;\n  this.ldeviceOrgX = 0.0;\n  this.ldeviceOrgY = 0.0;\n  this.lworldExtX = 1.0;\n  this.lworldExtY = 1.0;\n  this.ldeviceExtX = 1.0;\n  this.ldeviceExtY = 1.0;\n}\n\nTransform.prototype.getWorldOrgX = function () {\n  return this.lworldOrgX;\n};\n\nTransform.prototype.setWorldOrgX = function (wox) {\n  this.lworldOrgX = wox;\n};\n\nTransform.prototype.getWorldOrgY = function () {\n  return this.lworldOrgY;\n};\n\nTransform.prototype.setWorldOrgY = function (woy) {\n  this.lworldOrgY = woy;\n};\n\nTransform.prototype.getWorldExtX = function () {\n  return this.lworldExtX;\n};\n\nTransform.prototype.setWorldExtX = function (wex) {\n  this.lworldExtX = wex;\n};\n\nTransform.prototype.getWorldExtY = function () {\n  return this.lworldExtY;\n};\n\nTransform.prototype.setWorldExtY = function (wey) {\n  this.lworldExtY = wey;\n};\n\n/* Device related */\n\nTransform.prototype.getDeviceOrgX = function () {\n  return this.ldeviceOrgX;\n};\n\nTransform.prototype.setDeviceOrgX = function (dox) {\n  this.ldeviceOrgX = dox;\n};\n\nTransform.prototype.getDeviceOrgY = function () {\n  return this.ldeviceOrgY;\n};\n\nTransform.prototype.setDeviceOrgY = function (doy) {\n  this.ldeviceOrgY = doy;\n};\n\nTransform.prototype.getDeviceExtX = function () {\n  return this.ldeviceExtX;\n};\n\nTransform.prototype.setDeviceExtX = function (dex) {\n  this.ldeviceExtX = dex;\n};\n\nTransform.prototype.getDeviceExtY = function () {\n  return this.ldeviceExtY;\n};\n\nTransform.prototype.setDeviceExtY = function (dey) {\n  this.ldeviceExtY = dey;\n};\n\nTransform.prototype.transformX = function (x) {\n  var xDevice = 0.0;\n  var worldExtX = this.lworldExtX;\n  if (worldExtX != 0.0) {\n    xDevice = this.ldeviceOrgX + (x - this.lworldOrgX) * this.ldeviceExtX / worldExtX;\n  }\n\n  return xDevice;\n};\n\nTransform.prototype.transformY = function (y) {\n  var yDevice = 0.0;\n  var worldExtY = this.lworldExtY;\n  if (worldExtY != 0.0) {\n    yDevice = this.ldeviceOrgY + (y - this.lworldOrgY) * this.ldeviceExtY / worldExtY;\n  }\n\n  return yDevice;\n};\n\nTransform.prototype.inverseTransformX = function (x) {\n  var xWorld = 0.0;\n  var deviceExtX = this.ldeviceExtX;\n  if (deviceExtX != 0.0) {\n    xWorld = this.lworldOrgX + (x - this.ldeviceOrgX) * this.lworldExtX / deviceExtX;\n  }\n\n  return xWorld;\n};\n\nTransform.prototype.inverseTransformY = function (y) {\n  var yWorld = 0.0;\n  var deviceExtY = this.ldeviceExtY;\n  if (deviceExtY != 0.0) {\n    yWorld = this.lworldOrgY + (y - this.ldeviceOrgY) * this.lworldExtY / deviceExtY;\n  }\n  return yWorld;\n};\n\nTransform.prototype.inverseTransformPoint = function (inPoint) {\n  var outPoint = new PointD(this.inverseTransformX(inPoint.x), this.inverseTransformY(inPoint.y));\n  return outPoint;\n};\n\nmodule.exports = Transform;\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar Layout = __webpack_require__(15);\nvar FDLayoutConstants = __webpack_require__(7);\nvar LayoutConstants = __webpack_require__(0);\nvar IGeometry = __webpack_require__(8);\nvar IMath = __webpack_require__(9);\n\nfunction FDLayout() {\n  Layout.call(this);\n\n  this.useSmartIdealEdgeLengthCalculation = FDLayoutConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION;\n  this.idealEdgeLength = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n  this.springConstant = FDLayoutConstants.DEFAULT_SPRING_STRENGTH;\n  this.repulsionConstant = FDLayoutConstants.DEFAULT_REPULSION_STRENGTH;\n  this.gravityConstant = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH;\n  this.compoundGravityConstant = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH;\n  this.gravityRangeFactor = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR;\n  this.compoundGravityRangeFactor = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR;\n  this.displacementThresholdPerNode = 3.0 * FDLayoutConstants.DEFAULT_EDGE_LENGTH / 100;\n  this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n  this.initialCoolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n  this.totalDisplacement = 0.0;\n  this.oldTotalDisplacement = 0.0;\n  this.maxIterations = FDLayoutConstants.MAX_ITERATIONS;\n}\n\nFDLayout.prototype = Object.create(Layout.prototype);\n\nfor (var prop in Layout) {\n  FDLayout[prop] = Layout[prop];\n}\n\nFDLayout.prototype.initParameters = function () {\n  Layout.prototype.initParameters.call(this, arguments);\n\n  this.totalIterations = 0;\n  this.notAnimatedIterations = 0;\n\n  this.useFRGridVariant = FDLayoutConstants.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION;\n\n  this.grid = [];\n};\n\nFDLayout.prototype.calcIdealEdgeLengths = function () {\n  var edge;\n  var lcaDepth;\n  var source;\n  var target;\n  var sizeOfSourceInLca;\n  var sizeOfTargetInLca;\n\n  var allEdges = this.getGraphManager().getAllEdges();\n  for (var i = 0; i < allEdges.length; i++) {\n    edge = allEdges[i];\n\n    edge.idealLength = this.idealEdgeLength;\n\n    if (edge.isInterGraph) {\n      source = edge.getSource();\n      target = edge.getTarget();\n\n      sizeOfSourceInLca = edge.getSourceInLca().getEstimatedSize();\n      sizeOfTargetInLca = edge.getTargetInLca().getEstimatedSize();\n\n      if (this.useSmartIdealEdgeLengthCalculation) {\n        edge.idealLength += sizeOfSourceInLca + sizeOfTargetInLca - 2 * LayoutConstants.SIMPLE_NODE_SIZE;\n      }\n\n      lcaDepth = edge.getLca().getInclusionTreeDepth();\n\n      edge.idealLength += FDLayoutConstants.DEFAULT_EDGE_LENGTH * FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR * (source.getInclusionTreeDepth() + target.getInclusionTreeDepth() - 2 * lcaDepth);\n    }\n  }\n};\n\nFDLayout.prototype.initSpringEmbedder = function () {\n\n  var s = this.getAllNodes().length;\n  if (this.incremental) {\n    if (s > FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) {\n      this.coolingFactor = Math.max(this.coolingFactor * FDLayoutConstants.COOLING_ADAPTATION_FACTOR, this.coolingFactor - (s - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) / (FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) * this.coolingFactor * (1 - FDLayoutConstants.COOLING_ADAPTATION_FACTOR));\n    }\n    this.maxNodeDisplacement = FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL;\n  } else {\n    if (s > FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) {\n      this.coolingFactor = Math.max(FDLayoutConstants.COOLING_ADAPTATION_FACTOR, 1.0 - (s - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) / (FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) * (1 - FDLayoutConstants.COOLING_ADAPTATION_FACTOR));\n    } else {\n      this.coolingFactor = 1.0;\n    }\n    this.initialCoolingFactor = this.coolingFactor;\n    this.maxNodeDisplacement = FDLayoutConstants.MAX_NODE_DISPLACEMENT;\n  }\n\n  this.maxIterations = Math.max(this.getAllNodes().length * 5, this.maxIterations);\n\n  this.totalDisplacementThreshold = this.displacementThresholdPerNode * this.getAllNodes().length;\n\n  this.repulsionRange = this.calcRepulsionRange();\n};\n\nFDLayout.prototype.calcSpringForces = function () {\n  var lEdges = this.getAllEdges();\n  var edge;\n\n  for (var i = 0; i < lEdges.length; i++) {\n    edge = lEdges[i];\n\n    this.calcSpringForce(edge, edge.idealLength);\n  }\n};\n\nFDLayout.prototype.calcRepulsionForces = function () {\n  var gridUpdateAllowed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n  var forceToNodeSurroundingUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  var i, j;\n  var nodeA, nodeB;\n  var lNodes = this.getAllNodes();\n  var processedNodeSet;\n\n  if (this.useFRGridVariant) {\n    if (this.totalIterations % FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD == 1 && gridUpdateAllowed) {\n      this.updateGrid();\n    }\n\n    processedNodeSet = new Set();\n\n    // calculate repulsion forces between each nodes and its surrounding\n    for (i = 0; i < lNodes.length; i++) {\n      nodeA = lNodes[i];\n      this.calculateRepulsionForceOfANode(nodeA, processedNodeSet, gridUpdateAllowed, forceToNodeSurroundingUpdate);\n      processedNodeSet.add(nodeA);\n    }\n  } else {\n    for (i = 0; i < lNodes.length; i++) {\n      nodeA = lNodes[i];\n\n      for (j = i + 1; j < lNodes.length; j++) {\n        nodeB = lNodes[j];\n\n        // If both nodes are not members of the same graph, skip.\n        if (nodeA.getOwner() != nodeB.getOwner()) {\n          continue;\n        }\n\n        this.calcRepulsionForce(nodeA, nodeB);\n      }\n    }\n  }\n};\n\nFDLayout.prototype.calcGravitationalForces = function () {\n  var node;\n  var lNodes = this.getAllNodesToApplyGravitation();\n\n  for (var i = 0; i < lNodes.length; i++) {\n    node = lNodes[i];\n    this.calcGravitationalForce(node);\n  }\n};\n\nFDLayout.prototype.moveNodes = function () {\n  var lNodes = this.getAllNodes();\n  var node;\n\n  for (var i = 0; i < lNodes.length; i++) {\n    node = lNodes[i];\n    node.move();\n  }\n};\n\nFDLayout.prototype.calcSpringForce = function (edge, idealLength) {\n  var sourceNode = edge.getSource();\n  var targetNode = edge.getTarget();\n\n  var length;\n  var springForce;\n  var springForceX;\n  var springForceY;\n\n  // Update edge length\n  if (this.uniformLeafNodeSizes && sourceNode.getChild() == null && targetNode.getChild() == null) {\n    edge.updateLengthSimple();\n  } else {\n    edge.updateLength();\n\n    if (edge.isOverlapingSourceAndTarget) {\n      return;\n    }\n  }\n\n  length = edge.getLength();\n\n  if (length == 0) return;\n\n  // Calculate spring forces\n  springForce = this.springConstant * (length - idealLength);\n\n  // Project force onto x and y axes\n  springForceX = springForce * (edge.lengthX / length);\n  springForceY = springForce * (edge.lengthY / length);\n\n  // Apply forces on the end nodes\n  sourceNode.springForceX += springForceX;\n  sourceNode.springForceY += springForceY;\n  targetNode.springForceX -= springForceX;\n  targetNode.springForceY -= springForceY;\n};\n\nFDLayout.prototype.calcRepulsionForce = function (nodeA, nodeB) {\n  var rectA = nodeA.getRect();\n  var rectB = nodeB.getRect();\n  var overlapAmount = new Array(2);\n  var clipPoints = new Array(4);\n  var distanceX;\n  var distanceY;\n  var distanceSquared;\n  var distance;\n  var repulsionForce;\n  var repulsionForceX;\n  var repulsionForceY;\n\n  if (rectA.intersects(rectB)) // two nodes overlap\n    {\n      // calculate separation amount in x and y directions\n      IGeometry.calcSeparationAmount(rectA, rectB, overlapAmount, FDLayoutConstants.DEFAULT_EDGE_LENGTH / 2.0);\n\n      repulsionForceX = 2 * overlapAmount[0];\n      repulsionForceY = 2 * overlapAmount[1];\n\n      var childrenConstant = nodeA.noOfChildren * nodeB.noOfChildren / (nodeA.noOfChildren + nodeB.noOfChildren);\n\n      // Apply forces on the two nodes\n      nodeA.repulsionForceX -= childrenConstant * repulsionForceX;\n      nodeA.repulsionForceY -= childrenConstant * repulsionForceY;\n      nodeB.repulsionForceX += childrenConstant * repulsionForceX;\n      nodeB.repulsionForceY += childrenConstant * repulsionForceY;\n    } else // no overlap\n    {\n      // calculate distance\n\n      if (this.uniformLeafNodeSizes && nodeA.getChild() == null && nodeB.getChild() == null) // simply base repulsion on distance of node centers\n        {\n          distanceX = rectB.getCenterX() - rectA.getCenterX();\n          distanceY = rectB.getCenterY() - rectA.getCenterY();\n        } else // use clipping points\n        {\n          IGeometry.getIntersection(rectA, rectB, clipPoints);\n\n          distanceX = clipPoints[2] - clipPoints[0];\n          distanceY = clipPoints[3] - clipPoints[1];\n        }\n\n      // No repulsion range. FR grid variant should take care of this.\n      if (Math.abs(distanceX) < FDLayoutConstants.MIN_REPULSION_DIST) {\n        distanceX = IMath.sign(distanceX) * FDLayoutConstants.MIN_REPULSION_DIST;\n      }\n\n      if (Math.abs(distanceY) < FDLayoutConstants.MIN_REPULSION_DIST) {\n        distanceY = IMath.sign(distanceY) * FDLayoutConstants.MIN_REPULSION_DIST;\n      }\n\n      distanceSquared = distanceX * distanceX + distanceY * distanceY;\n      distance = Math.sqrt(distanceSquared);\n\n      repulsionForce = this.repulsionConstant * nodeA.noOfChildren * nodeB.noOfChildren / distanceSquared;\n\n      // Project force onto x and y axes\n      repulsionForceX = repulsionForce * distanceX / distance;\n      repulsionForceY = repulsionForce * distanceY / distance;\n\n      // Apply forces on the two nodes    \n      nodeA.repulsionForceX -= repulsionForceX;\n      nodeA.repulsionForceY -= repulsionForceY;\n      nodeB.repulsionForceX += repulsionForceX;\n      nodeB.repulsionForceY += repulsionForceY;\n    }\n};\n\nFDLayout.prototype.calcGravitationalForce = function (node) {\n  var ownerGraph;\n  var ownerCenterX;\n  var ownerCenterY;\n  var distanceX;\n  var distanceY;\n  var absDistanceX;\n  var absDistanceY;\n  var estimatedSize;\n  ownerGraph = node.getOwner();\n\n  ownerCenterX = (ownerGraph.getRight() + ownerGraph.getLeft()) / 2;\n  ownerCenterY = (ownerGraph.getTop() + ownerGraph.getBottom()) / 2;\n  distanceX = node.getCenterX() - ownerCenterX;\n  distanceY = node.getCenterY() - ownerCenterY;\n  absDistanceX = Math.abs(distanceX) + node.getWidth() / 2;\n  absDistanceY = Math.abs(distanceY) + node.getHeight() / 2;\n\n  if (node.getOwner() == this.graphManager.getRoot()) // in the root graph\n    {\n      estimatedSize = ownerGraph.getEstimatedSize() * this.gravityRangeFactor;\n\n      if (absDistanceX > estimatedSize || absDistanceY > estimatedSize) {\n        node.gravitationForceX = -this.gravityConstant * distanceX;\n        node.gravitationForceY = -this.gravityConstant * distanceY;\n      }\n    } else // inside a compound\n    {\n      estimatedSize = ownerGraph.getEstimatedSize() * this.compoundGravityRangeFactor;\n\n      if (absDistanceX > estimatedSize || absDistanceY > estimatedSize) {\n        node.gravitationForceX = -this.gravityConstant * distanceX * this.compoundGravityConstant;\n        node.gravitationForceY = -this.gravityConstant * distanceY * this.compoundGravityConstant;\n      }\n    }\n};\n\nFDLayout.prototype.isConverged = function () {\n  var converged;\n  var oscilating = false;\n\n  if (this.totalIterations > this.maxIterations / 3) {\n    oscilating = Math.abs(this.totalDisplacement - this.oldTotalDisplacement) < 2;\n  }\n\n  converged = this.totalDisplacement < this.totalDisplacementThreshold;\n\n  this.oldTotalDisplacement = this.totalDisplacement;\n\n  return converged || oscilating;\n};\n\nFDLayout.prototype.animate = function () {\n  if (this.animationDuringLayout && !this.isSubLayout) {\n    if (this.notAnimatedIterations == this.animationPeriod) {\n      this.update();\n      this.notAnimatedIterations = 0;\n    } else {\n      this.notAnimatedIterations++;\n    }\n  }\n};\n\n//This method calculates the number of children (weight) for all nodes\nFDLayout.prototype.calcNoOfChildrenForAllNodes = function () {\n  var node;\n  var allNodes = this.graphManager.getAllNodes();\n\n  for (var i = 0; i < allNodes.length; i++) {\n    node = allNodes[i];\n    node.noOfChildren = node.getNoOfChildren();\n  }\n};\n\n// -----------------------------------------------------------------------------\n// Section: FR-Grid Variant Repulsion Force Calculation\n// -----------------------------------------------------------------------------\n\nFDLayout.prototype.calcGrid = function (graph) {\n\n  var sizeX = 0;\n  var sizeY = 0;\n\n  sizeX = parseInt(Math.ceil((graph.getRight() - graph.getLeft()) / this.repulsionRange));\n  sizeY = parseInt(Math.ceil((graph.getBottom() - graph.getTop()) / this.repulsionRange));\n\n  var grid = new Array(sizeX);\n\n  for (var i = 0; i < sizeX; i++) {\n    grid[i] = new Array(sizeY);\n  }\n\n  for (var i = 0; i < sizeX; i++) {\n    for (var j = 0; j < sizeY; j++) {\n      grid[i][j] = new Array();\n    }\n  }\n\n  return grid;\n};\n\nFDLayout.prototype.addNodeToGrid = function (v, left, top) {\n\n  var startX = 0;\n  var finishX = 0;\n  var startY = 0;\n  var finishY = 0;\n\n  startX = parseInt(Math.floor((v.getRect().x - left) / this.repulsionRange));\n  finishX = parseInt(Math.floor((v.getRect().width + v.getRect().x - left) / this.repulsionRange));\n  startY = parseInt(Math.floor((v.getRect().y - top) / this.repulsionRange));\n  finishY = parseInt(Math.floor((v.getRect().height + v.getRect().y - top) / this.repulsionRange));\n\n  for (var i = startX; i <= finishX; i++) {\n    for (var j = startY; j <= finishY; j++) {\n      this.grid[i][j].push(v);\n      v.setGridCoordinates(startX, finishX, startY, finishY);\n    }\n  }\n};\n\nFDLayout.prototype.updateGrid = function () {\n  var i;\n  var nodeA;\n  var lNodes = this.getAllNodes();\n\n  this.grid = this.calcGrid(this.graphManager.getRoot());\n\n  // put all nodes to proper grid cells\n  for (i = 0; i < lNodes.length; i++) {\n    nodeA = lNodes[i];\n    this.addNodeToGrid(nodeA, this.graphManager.getRoot().getLeft(), this.graphManager.getRoot().getTop());\n  }\n};\n\nFDLayout.prototype.calculateRepulsionForceOfANode = function (nodeA, processedNodeSet, gridUpdateAllowed, forceToNodeSurroundingUpdate) {\n\n  if (this.totalIterations % FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD == 1 && gridUpdateAllowed || forceToNodeSurroundingUpdate) {\n    var surrounding = new Set();\n    nodeA.surrounding = new Array();\n    var nodeB;\n    var grid = this.grid;\n\n    for (var i = nodeA.startX - 1; i < nodeA.finishX + 2; i++) {\n      for (var j = nodeA.startY - 1; j < nodeA.finishY + 2; j++) {\n        if (!(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length)) {\n          for (var k = 0; k < grid[i][j].length; k++) {\n            nodeB = grid[i][j][k];\n\n            // If both nodes are not members of the same graph, \n            // or both nodes are the same, skip.\n            if (nodeA.getOwner() != nodeB.getOwner() || nodeA == nodeB) {\n              continue;\n            }\n\n            // check if the repulsion force between\n            // nodeA and nodeB has already been calculated\n            if (!processedNodeSet.has(nodeB) && !surrounding.has(nodeB)) {\n              var distanceX = Math.abs(nodeA.getCenterX() - nodeB.getCenterX()) - (nodeA.getWidth() / 2 + nodeB.getWidth() / 2);\n              var distanceY = Math.abs(nodeA.getCenterY() - nodeB.getCenterY()) - (nodeA.getHeight() / 2 + nodeB.getHeight() / 2);\n\n              // if the distance between nodeA and nodeB \n              // is less then calculation range\n              if (distanceX <= this.repulsionRange && distanceY <= this.repulsionRange) {\n                //then add nodeB to surrounding of nodeA\n                surrounding.add(nodeB);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    nodeA.surrounding = [].concat(_toConsumableArray(surrounding));\n  }\n  for (i = 0; i < nodeA.surrounding.length; i++) {\n    this.calcRepulsionForce(nodeA, nodeA.surrounding[i]);\n  }\n};\n\nFDLayout.prototype.calcRepulsionRange = function () {\n  return 0.0;\n};\n\nmodule.exports = FDLayout;\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar LEdge = __webpack_require__(1);\nvar FDLayoutConstants = __webpack_require__(7);\n\nfunction FDLayoutEdge(source, target, vEdge) {\n  LEdge.call(this, source, target, vEdge);\n  this.idealLength = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n}\n\nFDLayoutEdge.prototype = Object.create(LEdge.prototype);\n\nfor (var prop in LEdge) {\n  FDLayoutEdge[prop] = LEdge[prop];\n}\n\nmodule.exports = FDLayoutEdge;\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar LNode = __webpack_require__(3);\n\nfunction FDLayoutNode(gm, loc, size, vNode) {\n  // alternative constructor is handled inside LNode\n  LNode.call(this, gm, loc, size, vNode);\n  //Spring, repulsion and gravitational forces acting on this node\n  this.springForceX = 0;\n  this.springForceY = 0;\n  this.repulsionForceX = 0;\n  this.repulsionForceY = 0;\n  this.gravitationForceX = 0;\n  this.gravitationForceY = 0;\n  //Amount by which this node is to be moved in this iteration\n  this.displacementX = 0;\n  this.displacementY = 0;\n\n  //Start and finish grid coordinates that this node is fallen into\n  this.startX = 0;\n  this.finishX = 0;\n  this.startY = 0;\n  this.finishY = 0;\n\n  //Geometric neighbors of this node\n  this.surrounding = [];\n}\n\nFDLayoutNode.prototype = Object.create(LNode.prototype);\n\nfor (var prop in LNode) {\n  FDLayoutNode[prop] = LNode[prop];\n}\n\nFDLayoutNode.prototype.setGridCoordinates = function (_startX, _finishX, _startY, _finishY) {\n  this.startX = _startX;\n  this.finishX = _finishX;\n  this.startY = _startY;\n  this.finishY = _finishY;\n};\n\nmodule.exports = FDLayoutNode;\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction DimensionD(width, height) {\n  this.width = 0;\n  this.height = 0;\n  if (width !== null && height !== null) {\n    this.height = height;\n    this.width = width;\n  }\n}\n\nDimensionD.prototype.getWidth = function () {\n  return this.width;\n};\n\nDimensionD.prototype.setWidth = function (width) {\n  this.width = width;\n};\n\nDimensionD.prototype.getHeight = function () {\n  return this.height;\n};\n\nDimensionD.prototype.setHeight = function (height) {\n  this.height = height;\n};\n\nmodule.exports = DimensionD;\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar UniqueIDGeneretor = __webpack_require__(14);\n\nfunction HashMap() {\n  this.map = {};\n  this.keys = [];\n}\n\nHashMap.prototype.put = function (key, value) {\n  var theId = UniqueIDGeneretor.createID(key);\n  if (!this.contains(theId)) {\n    this.map[theId] = value;\n    this.keys.push(key);\n  }\n};\n\nHashMap.prototype.contains = function (key) {\n  var theId = UniqueIDGeneretor.createID(key);\n  return this.map[key] != null;\n};\n\nHashMap.prototype.get = function (key) {\n  var theId = UniqueIDGeneretor.createID(key);\n  return this.map[theId];\n};\n\nHashMap.prototype.keySet = function () {\n  return this.keys;\n};\n\nmodule.exports = HashMap;\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar UniqueIDGeneretor = __webpack_require__(14);\n\nfunction HashSet() {\n  this.set = {};\n}\n;\n\nHashSet.prototype.add = function (obj) {\n  var theId = UniqueIDGeneretor.createID(obj);\n  if (!this.contains(theId)) this.set[theId] = obj;\n};\n\nHashSet.prototype.remove = function (obj) {\n  delete this.set[UniqueIDGeneretor.createID(obj)];\n};\n\nHashSet.prototype.clear = function () {\n  this.set = {};\n};\n\nHashSet.prototype.contains = function (obj) {\n  return this.set[UniqueIDGeneretor.createID(obj)] == obj;\n};\n\nHashSet.prototype.isEmpty = function () {\n  return this.size() === 0;\n};\n\nHashSet.prototype.size = function () {\n  return Object.keys(this.set).length;\n};\n\n//concats this.set to the given list\nHashSet.prototype.addAllTo = function (list) {\n  var keys = Object.keys(this.set);\n  var length = keys.length;\n  for (var i = 0; i < length; i++) {\n    list.push(this.set[keys[i]]);\n  }\n};\n\nHashSet.prototype.size = function () {\n  return Object.keys(this.set).length;\n};\n\nHashSet.prototype.addAll = function (list) {\n  var s = list.length;\n  for (var i = 0; i < s; i++) {\n    var v = list[i];\n    this.add(v);\n  }\n};\n\nmodule.exports = HashSet;\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * A classic Quicksort algorithm with Hoare's partition\n * - Works also on LinkedList objects\n *\n * Copyright: i-Vis Research Group, Bilkent University, 2007 - present\n */\n\nvar LinkedList = __webpack_require__(11);\n\nvar Quicksort = function () {\n    function Quicksort(A, compareFunction) {\n        _classCallCheck(this, Quicksort);\n\n        if (compareFunction !== null || compareFunction !== undefined) this.compareFunction = this._defaultCompareFunction;\n\n        var length = void 0;\n        if (A instanceof LinkedList) length = A.size();else length = A.length;\n\n        this._quicksort(A, 0, length - 1);\n    }\n\n    _createClass(Quicksort, [{\n        key: '_quicksort',\n        value: function _quicksort(A, p, r) {\n            if (p < r) {\n                var q = this._partition(A, p, r);\n                this._quicksort(A, p, q);\n                this._quicksort(A, q + 1, r);\n            }\n        }\n    }, {\n        key: '_partition',\n        value: function _partition(A, p, r) {\n            var x = this._get(A, p);\n            var i = p;\n            var j = r;\n            while (true) {\n                while (this.compareFunction(x, this._get(A, j))) {\n                    j--;\n                }while (this.compareFunction(this._get(A, i), x)) {\n                    i++;\n                }if (i < j) {\n                    this._swap(A, i, j);\n                    i++;\n                    j--;\n                } else return j;\n            }\n        }\n    }, {\n        key: '_get',\n        value: function _get(object, index) {\n            if (object instanceof LinkedList) return object.get_object_at(index);else return object[index];\n        }\n    }, {\n        key: '_set',\n        value: function _set(object, index, value) {\n            if (object instanceof LinkedList) object.set_object_at(index, value);else object[index] = value;\n        }\n    }, {\n        key: '_swap',\n        value: function _swap(A, i, j) {\n            var temp = this._get(A, i);\n            this._set(A, i, this._get(A, j));\n            this._set(A, j, temp);\n        }\n    }, {\n        key: '_defaultCompareFunction',\n        value: function _defaultCompareFunction(a, b) {\n            return b > a;\n        }\n    }]);\n\n    return Quicksort;\n}();\n\nmodule.exports = Quicksort;\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n *   Needleman-Wunsch algorithm is an procedure to compute the optimal global alignment of two string\n *   sequences by S.B.Needleman and C.D.Wunsch (1970).\n *\n *   Aside from the inputs, you can assign the scores for,\n *   - Match: The two characters at the current index are same.\n *   - Mismatch: The two characters at the current index are different.\n *   - Insertion/Deletion(gaps): The best alignment involves one letter aligning to a gap in the other string.\n */\n\nvar NeedlemanWunsch = function () {\n    function NeedlemanWunsch(sequence1, sequence2) {\n        var match_score = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n        var mismatch_penalty = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;\n        var gap_penalty = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : -1;\n\n        _classCallCheck(this, NeedlemanWunsch);\n\n        this.sequence1 = sequence1;\n        this.sequence2 = sequence2;\n        this.match_score = match_score;\n        this.mismatch_penalty = mismatch_penalty;\n        this.gap_penalty = gap_penalty;\n\n        // Just the remove redundancy\n        this.iMax = sequence1.length + 1;\n        this.jMax = sequence2.length + 1;\n\n        // Grid matrix of scores\n        this.grid = new Array(this.iMax);\n        for (var i = 0; i < this.iMax; i++) {\n            this.grid[i] = new Array(this.jMax);\n\n            for (var j = 0; j < this.jMax; j++) {\n                this.grid[i][j] = 0;\n            }\n        }\n\n        // Traceback matrix (2D array, each cell is an array of boolean values for [`Diag`, `Up`, `Left`] positions)\n        this.tracebackGrid = new Array(this.iMax);\n        for (var _i = 0; _i < this.iMax; _i++) {\n            this.tracebackGrid[_i] = new Array(this.jMax);\n\n            for (var _j = 0; _j < this.jMax; _j++) {\n                this.tracebackGrid[_i][_j] = [null, null, null];\n            }\n        }\n\n        // The aligned sequences (return multiple possibilities)\n        this.alignments = [];\n\n        // Final alignment score\n        this.score = -1;\n\n        // Calculate scores and tracebacks\n        this.computeGrids();\n    }\n\n    _createClass(NeedlemanWunsch, [{\n        key: \"getScore\",\n        value: function getScore() {\n            return this.score;\n        }\n    }, {\n        key: \"getAlignments\",\n        value: function getAlignments() {\n            return this.alignments;\n        }\n\n        // Main dynamic programming procedure\n\n    }, {\n        key: \"computeGrids\",\n        value: function computeGrids() {\n            // Fill in the first row\n            for (var j = 1; j < this.jMax; j++) {\n                this.grid[0][j] = this.grid[0][j - 1] + this.gap_penalty;\n                this.tracebackGrid[0][j] = [false, false, true];\n            }\n\n            // Fill in the first column\n            for (var i = 1; i < this.iMax; i++) {\n                this.grid[i][0] = this.grid[i - 1][0] + this.gap_penalty;\n                this.tracebackGrid[i][0] = [false, true, false];\n            }\n\n            // Fill the rest of the grid\n            for (var _i2 = 1; _i2 < this.iMax; _i2++) {\n                for (var _j2 = 1; _j2 < this.jMax; _j2++) {\n                    // Find the max score(s) among [`Diag`, `Up`, `Left`]\n                    var diag = void 0;\n                    if (this.sequence1[_i2 - 1] === this.sequence2[_j2 - 1]) diag = this.grid[_i2 - 1][_j2 - 1] + this.match_score;else diag = this.grid[_i2 - 1][_j2 - 1] + this.mismatch_penalty;\n\n                    var up = this.grid[_i2 - 1][_j2] + this.gap_penalty;\n                    var left = this.grid[_i2][_j2 - 1] + this.gap_penalty;\n\n                    // If there exists multiple max values, capture them for multiple paths\n                    var maxOf = [diag, up, left];\n                    var indices = this.arrayAllMaxIndexes(maxOf);\n\n                    // Update Grids\n                    this.grid[_i2][_j2] = maxOf[indices[0]];\n                    this.tracebackGrid[_i2][_j2] = [indices.includes(0), indices.includes(1), indices.includes(2)];\n                }\n            }\n\n            // Update alignment score\n            this.score = this.grid[this.iMax - 1][this.jMax - 1];\n        }\n\n        // Gets all possible valid sequence combinations\n\n    }, {\n        key: \"alignmentTraceback\",\n        value: function alignmentTraceback() {\n            var inProcessAlignments = [];\n\n            inProcessAlignments.push({ pos: [this.sequence1.length, this.sequence2.length],\n                seq1: \"\",\n                seq2: \"\"\n            });\n\n            while (inProcessAlignments[0]) {\n                var current = inProcessAlignments[0];\n                var directions = this.tracebackGrid[current.pos[0]][current.pos[1]];\n\n                if (directions[0]) {\n                    inProcessAlignments.push({ pos: [current.pos[0] - 1, current.pos[1] - 1],\n                        seq1: this.sequence1[current.pos[0] - 1] + current.seq1,\n                        seq2: this.sequence2[current.pos[1] - 1] + current.seq2\n                    });\n                }\n                if (directions[1]) {\n                    inProcessAlignments.push({ pos: [current.pos[0] - 1, current.pos[1]],\n                        seq1: this.sequence1[current.pos[0] - 1] + current.seq1,\n                        seq2: '-' + current.seq2\n                    });\n                }\n                if (directions[2]) {\n                    inProcessAlignments.push({ pos: [current.pos[0], current.pos[1] - 1],\n                        seq1: '-' + current.seq1,\n                        seq2: this.sequence2[current.pos[1] - 1] + current.seq2\n                    });\n                }\n\n                if (current.pos[0] === 0 && current.pos[1] === 0) this.alignments.push({ sequence1: current.seq1,\n                    sequence2: current.seq2\n                });\n\n                inProcessAlignments.shift();\n            }\n\n            return this.alignments;\n        }\n\n        // Helper Functions\n\n    }, {\n        key: \"getAllIndexes\",\n        value: function getAllIndexes(arr, val) {\n            var indexes = [],\n                i = -1;\n            while ((i = arr.indexOf(val, i + 1)) !== -1) {\n                indexes.push(i);\n            }\n            return indexes;\n        }\n    }, {\n        key: \"arrayAllMaxIndexes\",\n        value: function arrayAllMaxIndexes(array) {\n            return this.getAllIndexes(array, Math.max.apply(null, array));\n        }\n    }]);\n\n    return NeedlemanWunsch;\n}();\n\nmodule.exports = NeedlemanWunsch;\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar layoutBase = function layoutBase() {\n  return;\n};\n\nlayoutBase.FDLayout = __webpack_require__(18);\nlayoutBase.FDLayoutConstants = __webpack_require__(7);\nlayoutBase.FDLayoutEdge = __webpack_require__(19);\nlayoutBase.FDLayoutNode = __webpack_require__(20);\nlayoutBase.DimensionD = __webpack_require__(21);\nlayoutBase.HashMap = __webpack_require__(22);\nlayoutBase.HashSet = __webpack_require__(23);\nlayoutBase.IGeometry = __webpack_require__(8);\nlayoutBase.IMath = __webpack_require__(9);\nlayoutBase.Integer = __webpack_require__(10);\nlayoutBase.Point = __webpack_require__(12);\nlayoutBase.PointD = __webpack_require__(4);\nlayoutBase.RandomSeed = __webpack_require__(16);\nlayoutBase.RectangleD = __webpack_require__(13);\nlayoutBase.Transform = __webpack_require__(17);\nlayoutBase.UniqueIDGeneretor = __webpack_require__(14);\nlayoutBase.Quicksort = __webpack_require__(24);\nlayoutBase.LinkedList = __webpack_require__(11);\nlayoutBase.LGraphObject = __webpack_require__(2);\nlayoutBase.LGraph = __webpack_require__(5);\nlayoutBase.LEdge = __webpack_require__(1);\nlayoutBase.LGraphManager = __webpack_require__(6);\nlayoutBase.LNode = __webpack_require__(3);\nlayoutBase.Layout = __webpack_require__(15);\nlayoutBase.LayoutConstants = __webpack_require__(0);\nlayoutBase.NeedlemanWunsch = __webpack_require__(25);\n\nmodule.exports = layoutBase;\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction Emitter() {\n  this.listeners = [];\n}\n\nvar p = Emitter.prototype;\n\np.addListener = function (event, callback) {\n  this.listeners.push({\n    event: event,\n    callback: callback\n  });\n};\n\np.removeListener = function (event, callback) {\n  for (var i = this.listeners.length; i >= 0; i--) {\n    var l = this.listeners[i];\n\n    if (l.event === event && l.callback === callback) {\n      this.listeners.splice(i, 1);\n    }\n  }\n};\n\np.emit = function (event, data) {\n  for (var i = 0; i < this.listeners.length; i++) {\n    var l = this.listeners[i];\n\n    if (event === l.event) {\n      l.callback(data);\n    }\n  }\n};\n\nmodule.exports = Emitter;\n\n/***/ })\n/******/ ]);\n});"],"mappings":"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"},"metadata":{},"sourceType":"script"}