{"ast":null,"code":"/* IMPORT */\nimport _ from '../utils/index.js';\nimport ChannelsReusable from '../channels/reusable.js';\n/* MAIN */\n\nconst HSL = {\n  /* VARIABLES */\n  re: /^hsla?\\(\\s*?(-?(?:\\d+(?:\\.\\d+)?|(?:\\.\\d+))(?:e-?\\d+)?(?:deg|grad|rad|turn)?)\\s*?(?:,|\\s)\\s*?(-?(?:\\d+(?:\\.\\d+)?|(?:\\.\\d+))(?:e-?\\d+)?%)\\s*?(?:,|\\s)\\s*?(-?(?:\\d+(?:\\.\\d+)?|(?:\\.\\d+))(?:e-?\\d+)?%)(?:\\s*?(?:,|\\/)\\s*?\\+?(-?(?:\\d+(?:\\.\\d+)?|(?:\\.\\d+))(?:e-?\\d+)?(%)?))?\\s*?\\)$/i,\n  hueRe: /^(.+?)(deg|grad|rad|turn)$/i,\n\n  /* HELPERS */\n  _hue2deg: hue => {\n    const match = hue.match(HSL.hueRe);\n\n    if (match) {\n      const [, number, unit] = match;\n\n      switch (unit) {\n        case 'grad':\n          return _.channel.clamp.h(parseFloat(number) * .9);\n\n        case 'rad':\n          return _.channel.clamp.h(parseFloat(number) * 180 / Math.PI);\n\n        case 'turn':\n          return _.channel.clamp.h(parseFloat(number) * 360);\n      }\n    }\n\n    return _.channel.clamp.h(parseFloat(hue));\n  },\n\n  /* API */\n  parse: color => {\n    const charCode = color.charCodeAt(0);\n    if (charCode !== 104 && charCode !== 72) return; // 'h'/'H'\n\n    const match = color.match(HSL.re);\n    if (!match) return;\n    const [, h, s, l, a, isAlphaPercentage] = match;\n    return ChannelsReusable.set({\n      h: HSL._hue2deg(h),\n      s: _.channel.clamp.s(parseFloat(s)),\n      l: _.channel.clamp.l(parseFloat(l)),\n      a: a ? _.channel.clamp.a(isAlphaPercentage ? parseFloat(a) / 100 : parseFloat(a)) : 1\n    }, color);\n  },\n  stringify: channels => {\n    const {\n      h,\n      s,\n      l,\n      a\n    } = channels;\n\n    if (a < 1) {\n      // HSLA\n      return `hsla(${_.lang.round(h)}, ${_.lang.round(s)}%, ${_.lang.round(l)}%, ${a})`;\n    } else {\n      // HSL\n      return `hsl(${_.lang.round(h)}, ${_.lang.round(s)}%, ${_.lang.round(l)}%)`;\n    }\n  }\n};\n/* EXPORT */\n\nexport default HSL;","map":null,"metadata":{},"sourceType":"module"}