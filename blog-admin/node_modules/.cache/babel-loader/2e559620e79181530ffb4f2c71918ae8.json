{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar layoutUtil = require(\"../../util/layout\");\n\nvar LegendView = require(\"./LegendView\");\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Separate legend and scrollable legend to reduce package size.\n */\n\n\nvar Group = graphic.Group;\nvar WH = ['width', 'height'];\nvar XY = ['x', 'y'];\nvar ScrollableLegendView = LegendView.extend({\n  type: 'legend.scroll',\n  newlineDisabled: true,\n  init: function () {\n    ScrollableLegendView.superCall(this, 'init');\n    /**\n     * @private\n     * @type {number} For `scroll`.\n     */\n\n    this._currentIndex = 0;\n    /**\n     * @private\n     * @type {module:zrender/container/Group}\n     */\n\n    this.group.add(this._containerGroup = new Group());\n\n    this._containerGroup.add(this.getContentGroup());\n    /**\n     * @private\n     * @type {module:zrender/container/Group}\n     */\n\n\n    this.group.add(this._controllerGroup = new Group());\n    /**\n     *\n     * @private\n     */\n\n    this._showController;\n  },\n\n  /**\n   * @override\n   */\n  resetInner: function () {\n    ScrollableLegendView.superCall(this, 'resetInner');\n\n    this._controllerGroup.removeAll();\n\n    this._containerGroup.removeClipPath();\n\n    this._containerGroup.__rectSize = null;\n  },\n\n  /**\n   * @override\n   */\n  renderInner: function (itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition) {\n    var me = this; // Render content items.\n\n    ScrollableLegendView.superCall(this, 'renderInner', itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition);\n    var controllerGroup = this._controllerGroup; // FIXME: support be 'auto' adapt to size number text length,\n    // e.g., '3/12345' should not overlap with the control arrow button.\n\n    var pageIconSize = legendModel.get('pageIconSize', true);\n\n    if (!zrUtil.isArray(pageIconSize)) {\n      pageIconSize = [pageIconSize, pageIconSize];\n    }\n\n    createPageButton('pagePrev', 0);\n    var pageTextStyleModel = legendModel.getModel('pageTextStyle');\n    controllerGroup.add(new graphic.Text({\n      name: 'pageText',\n      style: {\n        textFill: pageTextStyleModel.getTextColor(),\n        font: pageTextStyleModel.getFont(),\n        textVerticalAlign: 'middle',\n        textAlign: 'center'\n      },\n      silent: true\n    }));\n    createPageButton('pageNext', 1);\n\n    function createPageButton(name, iconIdx) {\n      var pageDataIndexName = name + 'DataIndex';\n      var icon = graphic.createIcon(legendModel.get('pageIcons', true)[legendModel.getOrient().name][iconIdx], {\n        // Buttons will be created in each render, so we do not need\n        // to worry about avoiding using legendModel kept in scope.\n        onclick: zrUtil.bind(me._pageGo, me, pageDataIndexName, legendModel, api)\n      }, {\n        x: -pageIconSize[0] / 2,\n        y: -pageIconSize[1] / 2,\n        width: pageIconSize[0],\n        height: pageIconSize[1]\n      });\n      icon.name = name;\n      controllerGroup.add(icon);\n    }\n  },\n\n  /**\n   * @override\n   */\n  layoutInner: function (legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition) {\n    var selectorGroup = this.getSelectorGroup();\n    var orientIdx = legendModel.getOrient().index;\n    var wh = WH[orientIdx];\n    var xy = XY[orientIdx];\n    var hw = WH[1 - orientIdx];\n    var yx = XY[1 - orientIdx];\n    selector && layoutUtil.box( // Buttons in selectorGroup always layout horizontally\n    'horizontal', selectorGroup, legendModel.get('selectorItemGap', true));\n    var selectorButtonGap = legendModel.get('selectorButtonGap', true);\n    var selectorRect = selectorGroup.getBoundingRect();\n    var selectorPos = [-selectorRect.x, -selectorRect.y];\n    var processMaxSize = zrUtil.clone(maxSize);\n    selector && (processMaxSize[wh] = maxSize[wh] - selectorRect[wh] - selectorButtonGap);\n\n    var mainRect = this._layoutContentAndController(legendModel, isFirstRender, processMaxSize, orientIdx, wh, hw, yx);\n\n    if (selector) {\n      if (selectorPosition === 'end') {\n        selectorPos[orientIdx] += mainRect[wh] + selectorButtonGap;\n      } else {\n        var offset = selectorRect[wh] + selectorButtonGap;\n        selectorPos[orientIdx] -= offset;\n        mainRect[xy] -= offset;\n      }\n\n      mainRect[wh] += selectorRect[wh] + selectorButtonGap;\n      selectorPos[1 - orientIdx] += mainRect[yx] + mainRect[hw] / 2 - selectorRect[hw] / 2;\n      mainRect[hw] = Math.max(mainRect[hw], selectorRect[hw]);\n      mainRect[yx] = Math.min(mainRect[yx], selectorRect[yx] + selectorPos[1 - orientIdx]);\n      selectorGroup.attr('position', selectorPos);\n    }\n\n    return mainRect;\n  },\n  _layoutContentAndController: function (legendModel, isFirstRender, maxSize, orientIdx, wh, hw, yx) {\n    var contentGroup = this.getContentGroup();\n    var containerGroup = this._containerGroup;\n    var controllerGroup = this._controllerGroup; // Place items in contentGroup.\n\n    layoutUtil.box(legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), !orientIdx ? null : maxSize.width, orientIdx ? null : maxSize.height);\n    layoutUtil.box( // Buttons in controller are layout always horizontally.\n    'horizontal', controllerGroup, legendModel.get('pageButtonItemGap', true));\n    var contentRect = contentGroup.getBoundingRect();\n    var controllerRect = controllerGroup.getBoundingRect();\n    var showController = this._showController = contentRect[wh] > maxSize[wh];\n    var contentPos = [-contentRect.x, -contentRect.y]; // Remain contentPos when scroll animation perfroming.\n    // If first rendering, `contentGroup.position` is [0, 0], which\n    // does not make sense and may cause unexepcted animation if adopted.\n\n    if (!isFirstRender) {\n      contentPos[orientIdx] = contentGroup.position[orientIdx];\n    } // Layout container group based on 0.\n\n\n    var containerPos = [0, 0];\n    var controllerPos = [-controllerRect.x, -controllerRect.y];\n    var pageButtonGap = zrUtil.retrieve2(legendModel.get('pageButtonGap', true), legendModel.get('itemGap', true)); // Place containerGroup and controllerGroup and contentGroup.\n\n    if (showController) {\n      var pageButtonPosition = legendModel.get('pageButtonPosition', true); // controller is on the right / bottom.\n\n      if (pageButtonPosition === 'end') {\n        controllerPos[orientIdx] += maxSize[wh] - controllerRect[wh];\n      } // controller is on the left / top.\n      else {\n        containerPos[orientIdx] += controllerRect[wh] + pageButtonGap;\n      }\n    } // Always align controller to content as 'middle'.\n\n\n    controllerPos[1 - orientIdx] += contentRect[hw] / 2 - controllerRect[hw] / 2;\n    contentGroup.attr('position', contentPos);\n    containerGroup.attr('position', containerPos);\n    controllerGroup.attr('position', controllerPos); // Calculate `mainRect` and set `clipPath`.\n    // mainRect should not be calculated by `this.group.getBoundingRect()`\n    // for sake of the overflow.\n\n    var mainRect = {\n      x: 0,\n      y: 0\n    }; // Consider content may be overflow (should be clipped).\n\n    mainRect[wh] = showController ? maxSize[wh] : contentRect[wh];\n    mainRect[hw] = Math.max(contentRect[hw], controllerRect[hw]); // `containerRect[yx] + containerPos[1 - orientIdx]` is 0.\n\n    mainRect[yx] = Math.min(0, controllerRect[yx] + controllerPos[1 - orientIdx]);\n    containerGroup.__rectSize = maxSize[wh];\n\n    if (showController) {\n      var clipShape = {\n        x: 0,\n        y: 0\n      };\n      clipShape[wh] = Math.max(maxSize[wh] - controllerRect[wh] - pageButtonGap, 0);\n      clipShape[hw] = mainRect[hw];\n      containerGroup.setClipPath(new graphic.Rect({\n        shape: clipShape\n      })); // Consider content may be larger than container, container rect\n      // can not be obtained from `containerGroup.getBoundingRect()`.\n\n      containerGroup.__rectSize = clipShape[wh];\n    } else {\n      // Do not remove or ignore controller. Keep them set as placeholders.\n      controllerGroup.eachChild(function (child) {\n        child.attr({\n          invisible: true,\n          silent: true\n        });\n      });\n    } // Content translate animation.\n\n\n    var pageInfo = this._getPageInfo(legendModel);\n\n    pageInfo.pageIndex != null && graphic.updateProps(contentGroup, {\n      position: pageInfo.contentPosition\n    }, // When switch from \"show controller\" to \"not show controller\", view should be\n    // updated immediately without animation, otherwise causes weird effect.\n    showController ? legendModel : false);\n\n    this._updatePageInfoView(legendModel, pageInfo);\n\n    return mainRect;\n  },\n  _pageGo: function (to, legendModel, api) {\n    var scrollDataIndex = this._getPageInfo(legendModel)[to];\n\n    scrollDataIndex != null && api.dispatchAction({\n      type: 'legendScroll',\n      scrollDataIndex: scrollDataIndex,\n      legendId: legendModel.id\n    });\n  },\n  _updatePageInfoView: function (legendModel, pageInfo) {\n    var controllerGroup = this._controllerGroup;\n    zrUtil.each(['pagePrev', 'pageNext'], function (name) {\n      var canJump = pageInfo[name + 'DataIndex'] != null;\n      var icon = controllerGroup.childOfName(name);\n\n      if (icon) {\n        icon.setStyle('fill', canJump ? legendModel.get('pageIconColor', true) : legendModel.get('pageIconInactiveColor', true));\n        icon.cursor = canJump ? 'pointer' : 'default';\n      }\n    });\n    var pageText = controllerGroup.childOfName('pageText');\n    var pageFormatter = legendModel.get('pageFormatter');\n    var pageIndex = pageInfo.pageIndex;\n    var current = pageIndex != null ? pageIndex + 1 : 0;\n    var total = pageInfo.pageCount;\n    pageText && pageFormatter && pageText.setStyle('text', zrUtil.isString(pageFormatter) ? pageFormatter.replace('{current}', current).replace('{total}', total) : pageFormatter({\n      current: current,\n      total: total\n    }));\n  },\n\n  /**\n   * @param {module:echarts/model/Model} legendModel\n   * @return {Object} {\n   *  contentPosition: Array.<number>, null when data item not found.\n   *  pageIndex: number, null when data item not found.\n   *  pageCount: number, always be a number, can be 0.\n   *  pagePrevDataIndex: number, null when no previous page.\n   *  pageNextDataIndex: number, null when no next page.\n   * }\n   */\n  _getPageInfo: function (legendModel) {\n    var scrollDataIndex = legendModel.get('scrollDataIndex', true);\n    var contentGroup = this.getContentGroup();\n    var containerRectSize = this._containerGroup.__rectSize;\n    var orientIdx = legendModel.getOrient().index;\n    var wh = WH[orientIdx];\n    var xy = XY[orientIdx];\n\n    var targetItemIndex = this._findTargetItemIndex(scrollDataIndex);\n\n    var children = contentGroup.children();\n    var targetItem = children[targetItemIndex];\n    var itemCount = children.length;\n    var pCount = !itemCount ? 0 : 1;\n    var result = {\n      contentPosition: contentGroup.position.slice(),\n      pageCount: pCount,\n      pageIndex: pCount - 1,\n      pagePrevDataIndex: null,\n      pageNextDataIndex: null\n    };\n\n    if (!targetItem) {\n      return result;\n    }\n\n    var targetItemInfo = getItemInfo(targetItem);\n    result.contentPosition[orientIdx] = -targetItemInfo.s; // Strategy:\n    // (1) Always align based on the left/top most item.\n    // (2) It is user-friendly that the last item shown in the\n    // current window is shown at the begining of next window.\n    // Otherwise if half of the last item is cut by the window,\n    // it will have no chance to display entirely.\n    // (3) Consider that item size probably be different, we\n    // have calculate pageIndex by size rather than item index,\n    // and we can not get page index directly by division.\n    // (4) The window is to narrow to contain more than\n    // one item, we should make sure that the page can be fliped.\n\n    for (var i = targetItemIndex + 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i <= itemCount; ++i) {\n      currItemInfo = getItemInfo(children[i]);\n\n      if ( // Half of the last item is out of the window.\n      !currItemInfo && winEndItemInfo.e > winStartItemInfo.s + containerRectSize || // If the current item does not intersect with the window, the new page\n      // can be started at the current item or the last item.\n      currItemInfo && !intersect(currItemInfo, winStartItemInfo.s)) {\n        if (winEndItemInfo.i > winStartItemInfo.i) {\n          winStartItemInfo = winEndItemInfo;\n        } else {\n          // e.g., when page size is smaller than item size.\n          winStartItemInfo = currItemInfo;\n        }\n\n        if (winStartItemInfo) {\n          if (result.pageNextDataIndex == null) {\n            result.pageNextDataIndex = winStartItemInfo.i;\n          }\n\n          ++result.pageCount;\n        }\n      }\n\n      winEndItemInfo = currItemInfo;\n    }\n\n    for (var i = targetItemIndex - 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i >= -1; --i) {\n      currItemInfo = getItemInfo(children[i]);\n\n      if ( // If the the end item does not intersect with the window started\n      // from the current item, a page can be settled.\n      (!currItemInfo || !intersect(winEndItemInfo, currItemInfo.s)) && // e.g., when page size is smaller than item size.\n      winStartItemInfo.i < winEndItemInfo.i) {\n        winEndItemInfo = winStartItemInfo;\n\n        if (result.pagePrevDataIndex == null) {\n          result.pagePrevDataIndex = winStartItemInfo.i;\n        }\n\n        ++result.pageCount;\n        ++result.pageIndex;\n      }\n\n      winStartItemInfo = currItemInfo;\n    }\n\n    return result;\n\n    function getItemInfo(el) {\n      if (el) {\n        var itemRect = el.getBoundingRect();\n        var start = itemRect[xy] + el.position[orientIdx];\n        return {\n          s: start,\n          e: start + itemRect[wh],\n          i: el.__legendDataIndex\n        };\n      }\n    }\n\n    function intersect(itemInfo, winStart) {\n      return itemInfo.e >= winStart && itemInfo.s <= winStart + containerRectSize;\n    }\n  },\n  _findTargetItemIndex: function (targetDataIndex) {\n    if (!this._showController) {\n      return 0;\n    }\n\n    var index;\n    var contentGroup = this.getContentGroup();\n    var defaultIndex;\n    contentGroup.eachChild(function (child, idx) {\n      var legendDataIdx = child.__legendDataIndex; // FIXME\n      // If the given targetDataIndex (from model) is illegal,\n      // we use defaultIndex. But the index on the legend model and\n      // action payload is still illegal. That case will not be\n      // changed until some scenario requires.\n\n      if (defaultIndex == null && legendDataIdx != null) {\n        defaultIndex = idx;\n      }\n\n      if (legendDataIdx === targetDataIndex) {\n        index = idx;\n      }\n    });\n    return index != null ? index : defaultIndex;\n  }\n});\nvar _default = ScrollableLegendView;\nmodule.exports = _default;","map":{"version":3,"names":["zrUtil","require","graphic","layoutUtil","LegendView","Group","WH","XY","ScrollableLegendView","extend","type","newlineDisabled","init","superCall","_currentIndex","group","add","_containerGroup","getContentGroup","_controllerGroup","_showController","resetInner","removeAll","removeClipPath","__rectSize","renderInner","itemAlign","legendModel","ecModel","api","selector","orient","selectorPosition","me","controllerGroup","pageIconSize","get","isArray","createPageButton","pageTextStyleModel","getModel","Text","name","style","textFill","getTextColor","font","getFont","textVerticalAlign","textAlign","silent","iconIdx","pageDataIndexName","icon","createIcon","getOrient","onclick","bind","_pageGo","x","y","width","height","layoutInner","maxSize","isFirstRender","selectorGroup","getSelectorGroup","orientIdx","index","wh","xy","hw","yx","box","selectorButtonGap","selectorRect","getBoundingRect","selectorPos","processMaxSize","clone","mainRect","_layoutContentAndController","offset","Math","max","min","attr","contentGroup","containerGroup","contentRect","controllerRect","showController","contentPos","position","containerPos","controllerPos","pageButtonGap","retrieve2","pageButtonPosition","clipShape","setClipPath","Rect","shape","eachChild","child","invisible","pageInfo","_getPageInfo","pageIndex","updateProps","contentPosition","_updatePageInfoView","to","scrollDataIndex","dispatchAction","legendId","id","each","canJump","childOfName","setStyle","cursor","pageText","pageFormatter","current","total","pageCount","isString","replace","containerRectSize","targetItemIndex","_findTargetItemIndex","children","targetItem","itemCount","length","pCount","result","slice","pagePrevDataIndex","pageNextDataIndex","targetItemInfo","getItemInfo","s","i","winStartItemInfo","winEndItemInfo","currItemInfo","e","intersect","el","itemRect","start","__legendDataIndex","itemInfo","winStart","targetDataIndex","defaultIndex","idx","legendDataIdx","_default","module","exports"],"sources":["/Users/lord/Documents/Programmer/vue/VueProjects/blog-vue/blog-admin/node_modules/echarts/lib/component/legend/ScrollableLegendView.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar layoutUtil = require(\"../../util/layout\");\n\nvar LegendView = require(\"./LegendView\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Separate legend and scrollable legend to reduce package size.\n */\nvar Group = graphic.Group;\nvar WH = ['width', 'height'];\nvar XY = ['x', 'y'];\nvar ScrollableLegendView = LegendView.extend({\n  type: 'legend.scroll',\n  newlineDisabled: true,\n  init: function () {\n    ScrollableLegendView.superCall(this, 'init');\n    /**\n     * @private\n     * @type {number} For `scroll`.\n     */\n\n    this._currentIndex = 0;\n    /**\n     * @private\n     * @type {module:zrender/container/Group}\n     */\n\n    this.group.add(this._containerGroup = new Group());\n\n    this._containerGroup.add(this.getContentGroup());\n    /**\n     * @private\n     * @type {module:zrender/container/Group}\n     */\n\n\n    this.group.add(this._controllerGroup = new Group());\n    /**\n     *\n     * @private\n     */\n\n    this._showController;\n  },\n\n  /**\n   * @override\n   */\n  resetInner: function () {\n    ScrollableLegendView.superCall(this, 'resetInner');\n\n    this._controllerGroup.removeAll();\n\n    this._containerGroup.removeClipPath();\n\n    this._containerGroup.__rectSize = null;\n  },\n\n  /**\n   * @override\n   */\n  renderInner: function (itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition) {\n    var me = this; // Render content items.\n\n    ScrollableLegendView.superCall(this, 'renderInner', itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition);\n    var controllerGroup = this._controllerGroup; // FIXME: support be 'auto' adapt to size number text length,\n    // e.g., '3/12345' should not overlap with the control arrow button.\n\n    var pageIconSize = legendModel.get('pageIconSize', true);\n\n    if (!zrUtil.isArray(pageIconSize)) {\n      pageIconSize = [pageIconSize, pageIconSize];\n    }\n\n    createPageButton('pagePrev', 0);\n    var pageTextStyleModel = legendModel.getModel('pageTextStyle');\n    controllerGroup.add(new graphic.Text({\n      name: 'pageText',\n      style: {\n        textFill: pageTextStyleModel.getTextColor(),\n        font: pageTextStyleModel.getFont(),\n        textVerticalAlign: 'middle',\n        textAlign: 'center'\n      },\n      silent: true\n    }));\n    createPageButton('pageNext', 1);\n\n    function createPageButton(name, iconIdx) {\n      var pageDataIndexName = name + 'DataIndex';\n      var icon = graphic.createIcon(legendModel.get('pageIcons', true)[legendModel.getOrient().name][iconIdx], {\n        // Buttons will be created in each render, so we do not need\n        // to worry about avoiding using legendModel kept in scope.\n        onclick: zrUtil.bind(me._pageGo, me, pageDataIndexName, legendModel, api)\n      }, {\n        x: -pageIconSize[0] / 2,\n        y: -pageIconSize[1] / 2,\n        width: pageIconSize[0],\n        height: pageIconSize[1]\n      });\n      icon.name = name;\n      controllerGroup.add(icon);\n    }\n  },\n\n  /**\n   * @override\n   */\n  layoutInner: function (legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition) {\n    var selectorGroup = this.getSelectorGroup();\n    var orientIdx = legendModel.getOrient().index;\n    var wh = WH[orientIdx];\n    var xy = XY[orientIdx];\n    var hw = WH[1 - orientIdx];\n    var yx = XY[1 - orientIdx];\n    selector && layoutUtil.box( // Buttons in selectorGroup always layout horizontally\n    'horizontal', selectorGroup, legendModel.get('selectorItemGap', true));\n    var selectorButtonGap = legendModel.get('selectorButtonGap', true);\n    var selectorRect = selectorGroup.getBoundingRect();\n    var selectorPos = [-selectorRect.x, -selectorRect.y];\n    var processMaxSize = zrUtil.clone(maxSize);\n    selector && (processMaxSize[wh] = maxSize[wh] - selectorRect[wh] - selectorButtonGap);\n\n    var mainRect = this._layoutContentAndController(legendModel, isFirstRender, processMaxSize, orientIdx, wh, hw, yx);\n\n    if (selector) {\n      if (selectorPosition === 'end') {\n        selectorPos[orientIdx] += mainRect[wh] + selectorButtonGap;\n      } else {\n        var offset = selectorRect[wh] + selectorButtonGap;\n        selectorPos[orientIdx] -= offset;\n        mainRect[xy] -= offset;\n      }\n\n      mainRect[wh] += selectorRect[wh] + selectorButtonGap;\n      selectorPos[1 - orientIdx] += mainRect[yx] + mainRect[hw] / 2 - selectorRect[hw] / 2;\n      mainRect[hw] = Math.max(mainRect[hw], selectorRect[hw]);\n      mainRect[yx] = Math.min(mainRect[yx], selectorRect[yx] + selectorPos[1 - orientIdx]);\n      selectorGroup.attr('position', selectorPos);\n    }\n\n    return mainRect;\n  },\n  _layoutContentAndController: function (legendModel, isFirstRender, maxSize, orientIdx, wh, hw, yx) {\n    var contentGroup = this.getContentGroup();\n    var containerGroup = this._containerGroup;\n    var controllerGroup = this._controllerGroup; // Place items in contentGroup.\n\n    layoutUtil.box(legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), !orientIdx ? null : maxSize.width, orientIdx ? null : maxSize.height);\n    layoutUtil.box( // Buttons in controller are layout always horizontally.\n    'horizontal', controllerGroup, legendModel.get('pageButtonItemGap', true));\n    var contentRect = contentGroup.getBoundingRect();\n    var controllerRect = controllerGroup.getBoundingRect();\n    var showController = this._showController = contentRect[wh] > maxSize[wh];\n    var contentPos = [-contentRect.x, -contentRect.y]; // Remain contentPos when scroll animation perfroming.\n    // If first rendering, `contentGroup.position` is [0, 0], which\n    // does not make sense and may cause unexepcted animation if adopted.\n\n    if (!isFirstRender) {\n      contentPos[orientIdx] = contentGroup.position[orientIdx];\n    } // Layout container group based on 0.\n\n\n    var containerPos = [0, 0];\n    var controllerPos = [-controllerRect.x, -controllerRect.y];\n    var pageButtonGap = zrUtil.retrieve2(legendModel.get('pageButtonGap', true), legendModel.get('itemGap', true)); // Place containerGroup and controllerGroup and contentGroup.\n\n    if (showController) {\n      var pageButtonPosition = legendModel.get('pageButtonPosition', true); // controller is on the right / bottom.\n\n      if (pageButtonPosition === 'end') {\n        controllerPos[orientIdx] += maxSize[wh] - controllerRect[wh];\n      } // controller is on the left / top.\n      else {\n          containerPos[orientIdx] += controllerRect[wh] + pageButtonGap;\n        }\n    } // Always align controller to content as 'middle'.\n\n\n    controllerPos[1 - orientIdx] += contentRect[hw] / 2 - controllerRect[hw] / 2;\n    contentGroup.attr('position', contentPos);\n    containerGroup.attr('position', containerPos);\n    controllerGroup.attr('position', controllerPos); // Calculate `mainRect` and set `clipPath`.\n    // mainRect should not be calculated by `this.group.getBoundingRect()`\n    // for sake of the overflow.\n\n    var mainRect = {\n      x: 0,\n      y: 0\n    }; // Consider content may be overflow (should be clipped).\n\n    mainRect[wh] = showController ? maxSize[wh] : contentRect[wh];\n    mainRect[hw] = Math.max(contentRect[hw], controllerRect[hw]); // `containerRect[yx] + containerPos[1 - orientIdx]` is 0.\n\n    mainRect[yx] = Math.min(0, controllerRect[yx] + controllerPos[1 - orientIdx]);\n    containerGroup.__rectSize = maxSize[wh];\n\n    if (showController) {\n      var clipShape = {\n        x: 0,\n        y: 0\n      };\n      clipShape[wh] = Math.max(maxSize[wh] - controllerRect[wh] - pageButtonGap, 0);\n      clipShape[hw] = mainRect[hw];\n      containerGroup.setClipPath(new graphic.Rect({\n        shape: clipShape\n      })); // Consider content may be larger than container, container rect\n      // can not be obtained from `containerGroup.getBoundingRect()`.\n\n      containerGroup.__rectSize = clipShape[wh];\n    } else {\n      // Do not remove or ignore controller. Keep them set as placeholders.\n      controllerGroup.eachChild(function (child) {\n        child.attr({\n          invisible: true,\n          silent: true\n        });\n      });\n    } // Content translate animation.\n\n\n    var pageInfo = this._getPageInfo(legendModel);\n\n    pageInfo.pageIndex != null && graphic.updateProps(contentGroup, {\n      position: pageInfo.contentPosition\n    }, // When switch from \"show controller\" to \"not show controller\", view should be\n    // updated immediately without animation, otherwise causes weird effect.\n    showController ? legendModel : false);\n\n    this._updatePageInfoView(legendModel, pageInfo);\n\n    return mainRect;\n  },\n  _pageGo: function (to, legendModel, api) {\n    var scrollDataIndex = this._getPageInfo(legendModel)[to];\n\n    scrollDataIndex != null && api.dispatchAction({\n      type: 'legendScroll',\n      scrollDataIndex: scrollDataIndex,\n      legendId: legendModel.id\n    });\n  },\n  _updatePageInfoView: function (legendModel, pageInfo) {\n    var controllerGroup = this._controllerGroup;\n    zrUtil.each(['pagePrev', 'pageNext'], function (name) {\n      var canJump = pageInfo[name + 'DataIndex'] != null;\n      var icon = controllerGroup.childOfName(name);\n\n      if (icon) {\n        icon.setStyle('fill', canJump ? legendModel.get('pageIconColor', true) : legendModel.get('pageIconInactiveColor', true));\n        icon.cursor = canJump ? 'pointer' : 'default';\n      }\n    });\n    var pageText = controllerGroup.childOfName('pageText');\n    var pageFormatter = legendModel.get('pageFormatter');\n    var pageIndex = pageInfo.pageIndex;\n    var current = pageIndex != null ? pageIndex + 1 : 0;\n    var total = pageInfo.pageCount;\n    pageText && pageFormatter && pageText.setStyle('text', zrUtil.isString(pageFormatter) ? pageFormatter.replace('{current}', current).replace('{total}', total) : pageFormatter({\n      current: current,\n      total: total\n    }));\n  },\n\n  /**\n   * @param {module:echarts/model/Model} legendModel\n   * @return {Object} {\n   *  contentPosition: Array.<number>, null when data item not found.\n   *  pageIndex: number, null when data item not found.\n   *  pageCount: number, always be a number, can be 0.\n   *  pagePrevDataIndex: number, null when no previous page.\n   *  pageNextDataIndex: number, null when no next page.\n   * }\n   */\n  _getPageInfo: function (legendModel) {\n    var scrollDataIndex = legendModel.get('scrollDataIndex', true);\n    var contentGroup = this.getContentGroup();\n    var containerRectSize = this._containerGroup.__rectSize;\n    var orientIdx = legendModel.getOrient().index;\n    var wh = WH[orientIdx];\n    var xy = XY[orientIdx];\n\n    var targetItemIndex = this._findTargetItemIndex(scrollDataIndex);\n\n    var children = contentGroup.children();\n    var targetItem = children[targetItemIndex];\n    var itemCount = children.length;\n    var pCount = !itemCount ? 0 : 1;\n    var result = {\n      contentPosition: contentGroup.position.slice(),\n      pageCount: pCount,\n      pageIndex: pCount - 1,\n      pagePrevDataIndex: null,\n      pageNextDataIndex: null\n    };\n\n    if (!targetItem) {\n      return result;\n    }\n\n    var targetItemInfo = getItemInfo(targetItem);\n    result.contentPosition[orientIdx] = -targetItemInfo.s; // Strategy:\n    // (1) Always align based on the left/top most item.\n    // (2) It is user-friendly that the last item shown in the\n    // current window is shown at the begining of next window.\n    // Otherwise if half of the last item is cut by the window,\n    // it will have no chance to display entirely.\n    // (3) Consider that item size probably be different, we\n    // have calculate pageIndex by size rather than item index,\n    // and we can not get page index directly by division.\n    // (4) The window is to narrow to contain more than\n    // one item, we should make sure that the page can be fliped.\n\n    for (var i = targetItemIndex + 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i <= itemCount; ++i) {\n      currItemInfo = getItemInfo(children[i]);\n\n      if ( // Half of the last item is out of the window.\n      !currItemInfo && winEndItemInfo.e > winStartItemInfo.s + containerRectSize || // If the current item does not intersect with the window, the new page\n      // can be started at the current item or the last item.\n      currItemInfo && !intersect(currItemInfo, winStartItemInfo.s)) {\n        if (winEndItemInfo.i > winStartItemInfo.i) {\n          winStartItemInfo = winEndItemInfo;\n        } else {\n          // e.g., when page size is smaller than item size.\n          winStartItemInfo = currItemInfo;\n        }\n\n        if (winStartItemInfo) {\n          if (result.pageNextDataIndex == null) {\n            result.pageNextDataIndex = winStartItemInfo.i;\n          }\n\n          ++result.pageCount;\n        }\n      }\n\n      winEndItemInfo = currItemInfo;\n    }\n\n    for (var i = targetItemIndex - 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i >= -1; --i) {\n      currItemInfo = getItemInfo(children[i]);\n\n      if ( // If the the end item does not intersect with the window started\n      // from the current item, a page can be settled.\n      (!currItemInfo || !intersect(winEndItemInfo, currItemInfo.s)) && // e.g., when page size is smaller than item size.\n      winStartItemInfo.i < winEndItemInfo.i) {\n        winEndItemInfo = winStartItemInfo;\n\n        if (result.pagePrevDataIndex == null) {\n          result.pagePrevDataIndex = winStartItemInfo.i;\n        }\n\n        ++result.pageCount;\n        ++result.pageIndex;\n      }\n\n      winStartItemInfo = currItemInfo;\n    }\n\n    return result;\n\n    function getItemInfo(el) {\n      if (el) {\n        var itemRect = el.getBoundingRect();\n        var start = itemRect[xy] + el.position[orientIdx];\n        return {\n          s: start,\n          e: start + itemRect[wh],\n          i: el.__legendDataIndex\n        };\n      }\n    }\n\n    function intersect(itemInfo, winStart) {\n      return itemInfo.e >= winStart && itemInfo.s <= winStart + containerRectSize;\n    }\n  },\n  _findTargetItemIndex: function (targetDataIndex) {\n    if (!this._showController) {\n      return 0;\n    }\n\n    var index;\n    var contentGroup = this.getContentGroup();\n    var defaultIndex;\n    contentGroup.eachChild(function (child, idx) {\n      var legendDataIdx = child.__legendDataIndex; // FIXME\n      // If the given targetDataIndex (from model) is illegal,\n      // we use defaultIndex. But the index on the legend model and\n      // action payload is still illegal. That case will not be\n      // changed until some scenario requires.\n\n      if (defaultIndex == null && legendDataIdx != null) {\n        defaultIndex = idx;\n      }\n\n      if (legendDataIdx === targetDataIndex) {\n        index = idx;\n      }\n    });\n    return index != null ? index : defaultIndex;\n  }\n});\nvar _default = ScrollableLegendView;\nmodule.exports = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}