{"ast":null,"code":"(function webpackUniversalModuleDefinition(root, factory) {\n  if (typeof exports === 'object' && typeof module === 'object') module.exports = factory(require(\"layout-base\"));else if (typeof define === 'function' && define.amd) define([\"layout-base\"], factory);else if (typeof exports === 'object') exports[\"coseBase\"] = factory(require(\"layout-base\"));else root[\"coseBase\"] = factory(root[\"layoutBase\"]);\n})(this, function (__WEBPACK_EXTERNAL_MODULE_0__) {\n  return (\n    /******/\n    function (modules) {\n      // webpackBootstrap\n\n      /******/\n      // The module cache\n\n      /******/\n      var installedModules = {};\n      /******/\n\n      /******/\n      // The require function\n\n      /******/\n\n      function __webpack_require__(moduleId) {\n        /******/\n\n        /******/\n        // Check if module is in cache\n\n        /******/\n        if (installedModules[moduleId]) {\n          /******/\n          return installedModules[moduleId].exports;\n          /******/\n        }\n        /******/\n        // Create a new module (and put it into the cache)\n\n        /******/\n\n\n        var module = installedModules[moduleId] = {\n          /******/\n          i: moduleId,\n\n          /******/\n          l: false,\n\n          /******/\n          exports: {}\n          /******/\n\n        };\n        /******/\n\n        /******/\n        // Execute the module function\n\n        /******/\n\n        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n        /******/\n\n        /******/\n        // Flag the module as loaded\n\n        /******/\n\n        module.l = true;\n        /******/\n\n        /******/\n        // Return the exports of the module\n\n        /******/\n\n        return module.exports;\n        /******/\n      }\n      /******/\n\n      /******/\n\n      /******/\n      // expose the modules object (__webpack_modules__)\n\n      /******/\n\n\n      __webpack_require__.m = modules;\n      /******/\n\n      /******/\n      // expose the module cache\n\n      /******/\n\n      __webpack_require__.c = installedModules;\n      /******/\n\n      /******/\n      // identity function for calling harmony imports with the correct context\n\n      /******/\n\n      __webpack_require__.i = function (value) {\n        return value;\n      };\n      /******/\n\n      /******/\n      // define getter function for harmony exports\n\n      /******/\n\n\n      __webpack_require__.d = function (exports, name, getter) {\n        /******/\n        if (!__webpack_require__.o(exports, name)) {\n          /******/\n          Object.defineProperty(exports, name, {\n            /******/\n            configurable: false,\n\n            /******/\n            enumerable: true,\n\n            /******/\n            get: getter\n            /******/\n\n          });\n          /******/\n        }\n        /******/\n\n      };\n      /******/\n\n      /******/\n      // getDefaultExport function for compatibility with non-harmony modules\n\n      /******/\n\n\n      __webpack_require__.n = function (module) {\n        /******/\n        var getter = module && module.__esModule ?\n        /******/\n        function getDefault() {\n          return module['default'];\n        } :\n        /******/\n        function getModuleExports() {\n          return module;\n        };\n        /******/\n\n        __webpack_require__.d(getter, 'a', getter);\n        /******/\n\n\n        return getter;\n        /******/\n      };\n      /******/\n\n      /******/\n      // Object.prototype.hasOwnProperty.call\n\n      /******/\n\n\n      __webpack_require__.o = function (object, property) {\n        return Object.prototype.hasOwnProperty.call(object, property);\n      };\n      /******/\n\n      /******/\n      // __webpack_public_path__\n\n      /******/\n\n\n      __webpack_require__.p = \"\";\n      /******/\n\n      /******/\n      // Load entry module and return exports\n\n      /******/\n\n      return __webpack_require__(__webpack_require__.s = 7);\n      /******/\n    }\n    /************************************************************************/\n\n    /******/\n    ([\n    /* 0 */\n\n    /***/\n    function (module, exports) {\n      module.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n      /***/\n    },\n    /* 1 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var FDLayoutConstants = __webpack_require__(0).FDLayoutConstants;\n\n      function CoSEConstants() {} //CoSEConstants inherits static props in FDLayoutConstants\n\n\n      for (var prop in FDLayoutConstants) {\n        CoSEConstants[prop] = FDLayoutConstants[prop];\n      }\n\n      CoSEConstants.DEFAULT_USE_MULTI_LEVEL_SCALING = false;\n      CoSEConstants.DEFAULT_RADIAL_SEPARATION = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n      CoSEConstants.DEFAULT_COMPONENT_SEPERATION = 60;\n      CoSEConstants.TILE = true;\n      CoSEConstants.TILING_PADDING_VERTICAL = 10;\n      CoSEConstants.TILING_PADDING_HORIZONTAL = 10;\n      CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = false; // make this true when cose is used incrementally as a part of other non-incremental layout\n\n      module.exports = CoSEConstants;\n      /***/\n    },\n    /* 2 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var FDLayoutEdge = __webpack_require__(0).FDLayoutEdge;\n\n      function CoSEEdge(source, target, vEdge) {\n        FDLayoutEdge.call(this, source, target, vEdge);\n      }\n\n      CoSEEdge.prototype = Object.create(FDLayoutEdge.prototype);\n\n      for (var prop in FDLayoutEdge) {\n        CoSEEdge[prop] = FDLayoutEdge[prop];\n      }\n\n      module.exports = CoSEEdge;\n      /***/\n    },\n    /* 3 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var LGraph = __webpack_require__(0).LGraph;\n\n      function CoSEGraph(parent, graphMgr, vGraph) {\n        LGraph.call(this, parent, graphMgr, vGraph);\n      }\n\n      CoSEGraph.prototype = Object.create(LGraph.prototype);\n\n      for (var prop in LGraph) {\n        CoSEGraph[prop] = LGraph[prop];\n      }\n\n      module.exports = CoSEGraph;\n      /***/\n    },\n    /* 4 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var LGraphManager = __webpack_require__(0).LGraphManager;\n\n      function CoSEGraphManager(layout) {\n        LGraphManager.call(this, layout);\n      }\n\n      CoSEGraphManager.prototype = Object.create(LGraphManager.prototype);\n\n      for (var prop in LGraphManager) {\n        CoSEGraphManager[prop] = LGraphManager[prop];\n      }\n\n      module.exports = CoSEGraphManager;\n      /***/\n    },\n    /* 5 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var FDLayoutNode = __webpack_require__(0).FDLayoutNode;\n\n      var IMath = __webpack_require__(0).IMath;\n\n      function CoSENode(gm, loc, size, vNode) {\n        FDLayoutNode.call(this, gm, loc, size, vNode);\n      }\n\n      CoSENode.prototype = Object.create(FDLayoutNode.prototype);\n\n      for (var prop in FDLayoutNode) {\n        CoSENode[prop] = FDLayoutNode[prop];\n      }\n\n      CoSENode.prototype.move = function () {\n        var layout = this.graphManager.getLayout();\n        this.displacementX = layout.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.noOfChildren;\n        this.displacementY = layout.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.noOfChildren;\n\n        if (Math.abs(this.displacementX) > layout.coolingFactor * layout.maxNodeDisplacement) {\n          this.displacementX = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementX);\n        }\n\n        if (Math.abs(this.displacementY) > layout.coolingFactor * layout.maxNodeDisplacement) {\n          this.displacementY = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementY);\n        } // a simple node, just move it\n\n\n        if (this.child == null) {\n          this.moveBy(this.displacementX, this.displacementY);\n        } // an empty compound node, again just move it\n        else if (this.child.getNodes().length == 0) {\n          this.moveBy(this.displacementX, this.displacementY);\n        } // non-empty compound node, propogate movement to children as well\n        else {\n          this.propogateDisplacementToChildren(this.displacementX, this.displacementY);\n        }\n\n        layout.totalDisplacement += Math.abs(this.displacementX) + Math.abs(this.displacementY);\n        this.springForceX = 0;\n        this.springForceY = 0;\n        this.repulsionForceX = 0;\n        this.repulsionForceY = 0;\n        this.gravitationForceX = 0;\n        this.gravitationForceY = 0;\n        this.displacementX = 0;\n        this.displacementY = 0;\n      };\n\n      CoSENode.prototype.propogateDisplacementToChildren = function (dX, dY) {\n        var nodes = this.getChild().getNodes();\n        var node;\n\n        for (var i = 0; i < nodes.length; i++) {\n          node = nodes[i];\n\n          if (node.getChild() == null) {\n            node.moveBy(dX, dY);\n            node.displacementX += dX;\n            node.displacementY += dY;\n          } else {\n            node.propogateDisplacementToChildren(dX, dY);\n          }\n        }\n      };\n\n      CoSENode.prototype.setPred1 = function (pred1) {\n        this.pred1 = pred1;\n      };\n\n      CoSENode.prototype.getPred1 = function () {\n        return pred1;\n      };\n\n      CoSENode.prototype.getPred2 = function () {\n        return pred2;\n      };\n\n      CoSENode.prototype.setNext = function (next) {\n        this.next = next;\n      };\n\n      CoSENode.prototype.getNext = function () {\n        return next;\n      };\n\n      CoSENode.prototype.setProcessed = function (processed) {\n        this.processed = processed;\n      };\n\n      CoSENode.prototype.isProcessed = function () {\n        return processed;\n      };\n\n      module.exports = CoSENode;\n      /***/\n    },\n    /* 6 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var FDLayout = __webpack_require__(0).FDLayout;\n\n      var CoSEGraphManager = __webpack_require__(4);\n\n      var CoSEGraph = __webpack_require__(3);\n\n      var CoSENode = __webpack_require__(5);\n\n      var CoSEEdge = __webpack_require__(2);\n\n      var CoSEConstants = __webpack_require__(1);\n\n      var FDLayoutConstants = __webpack_require__(0).FDLayoutConstants;\n\n      var LayoutConstants = __webpack_require__(0).LayoutConstants;\n\n      var Point = __webpack_require__(0).Point;\n\n      var PointD = __webpack_require__(0).PointD;\n\n      var Layout = __webpack_require__(0).Layout;\n\n      var Integer = __webpack_require__(0).Integer;\n\n      var IGeometry = __webpack_require__(0).IGeometry;\n\n      var LGraph = __webpack_require__(0).LGraph;\n\n      var Transform = __webpack_require__(0).Transform;\n\n      function CoSELayout() {\n        FDLayout.call(this);\n        this.toBeTiled = {}; // Memorize if a node is to be tiled or is tiled\n      }\n\n      CoSELayout.prototype = Object.create(FDLayout.prototype);\n\n      for (var prop in FDLayout) {\n        CoSELayout[prop] = FDLayout[prop];\n      }\n\n      CoSELayout.prototype.newGraphManager = function () {\n        var gm = new CoSEGraphManager(this);\n        this.graphManager = gm;\n        return gm;\n      };\n\n      CoSELayout.prototype.newGraph = function (vGraph) {\n        return new CoSEGraph(null, this.graphManager, vGraph);\n      };\n\n      CoSELayout.prototype.newNode = function (vNode) {\n        return new CoSENode(this.graphManager, vNode);\n      };\n\n      CoSELayout.prototype.newEdge = function (vEdge) {\n        return new CoSEEdge(null, null, vEdge);\n      };\n\n      CoSELayout.prototype.initParameters = function () {\n        FDLayout.prototype.initParameters.call(this, arguments);\n\n        if (!this.isSubLayout) {\n          if (CoSEConstants.DEFAULT_EDGE_LENGTH < 10) {\n            this.idealEdgeLength = 10;\n          } else {\n            this.idealEdgeLength = CoSEConstants.DEFAULT_EDGE_LENGTH;\n          }\n\n          this.useSmartIdealEdgeLengthCalculation = CoSEConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION;\n          this.springConstant = FDLayoutConstants.DEFAULT_SPRING_STRENGTH;\n          this.repulsionConstant = FDLayoutConstants.DEFAULT_REPULSION_STRENGTH;\n          this.gravityConstant = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH;\n          this.compoundGravityConstant = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH;\n          this.gravityRangeFactor = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR;\n          this.compoundGravityRangeFactor = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR; // variables for tree reduction support\n\n          this.prunedNodesAll = [];\n          this.growTreeIterations = 0;\n          this.afterGrowthIterations = 0;\n          this.isTreeGrowing = false;\n          this.isGrowthFinished = false; // variables for cooling\n\n          this.coolingCycle = 0;\n          this.maxCoolingCycle = this.maxIterations / FDLayoutConstants.CONVERGENCE_CHECK_PERIOD;\n          this.finalTemperature = FDLayoutConstants.CONVERGENCE_CHECK_PERIOD / this.maxIterations;\n          this.coolingAdjuster = 1;\n        }\n      };\n\n      CoSELayout.prototype.layout = function () {\n        var createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n\n        if (createBendsAsNeeded) {\n          this.createBendpoints();\n          this.graphManager.resetAllEdges();\n        }\n\n        this.level = 0;\n        return this.classicLayout();\n      };\n\n      CoSELayout.prototype.classicLayout = function () {\n        this.nodesWithGravity = this.calculateNodesToApplyGravitationTo();\n        this.graphManager.setAllNodesToApplyGravitation(this.nodesWithGravity);\n        this.calcNoOfChildrenForAllNodes();\n        this.graphManager.calcLowestCommonAncestors();\n        this.graphManager.calcInclusionTreeDepths();\n        this.graphManager.getRoot().calcEstimatedSize();\n        this.calcIdealEdgeLengths();\n\n        if (!this.incremental) {\n          var forest = this.getFlatForest(); // The graph associated with this layout is flat and a forest\n\n          if (forest.length > 0) {\n            this.positionNodesRadially(forest);\n          } // The graph associated with this layout is not flat or a forest\n          else {\n            // Reduce the trees when incremental mode is not enabled and graph is not a forest \n            this.reduceTrees(); // Update nodes that gravity will be applied\n\n            this.graphManager.resetAllNodesToApplyGravitation();\n            var allNodes = new Set(this.getAllNodes());\n            var intersection = this.nodesWithGravity.filter(function (x) {\n              return allNodes.has(x);\n            });\n            this.graphManager.setAllNodesToApplyGravitation(intersection);\n            this.positionNodesRandomly();\n          }\n        } else {\n          if (CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL) {\n            // Reduce the trees in incremental mode if only this constant is set to true \n            this.reduceTrees(); // Update nodes that gravity will be applied\n\n            this.graphManager.resetAllNodesToApplyGravitation();\n            var allNodes = new Set(this.getAllNodes());\n            var intersection = this.nodesWithGravity.filter(function (x) {\n              return allNodes.has(x);\n            });\n            this.graphManager.setAllNodesToApplyGravitation(intersection);\n          }\n        }\n\n        this.initSpringEmbedder();\n        this.runSpringEmbedder();\n        return true;\n      };\n\n      CoSELayout.prototype.tick = function () {\n        this.totalIterations++;\n\n        if (this.totalIterations === this.maxIterations && !this.isTreeGrowing && !this.isGrowthFinished) {\n          if (this.prunedNodesAll.length > 0) {\n            this.isTreeGrowing = true;\n          } else {\n            return true;\n          }\n        }\n\n        if (this.totalIterations % FDLayoutConstants.CONVERGENCE_CHECK_PERIOD == 0 && !this.isTreeGrowing && !this.isGrowthFinished) {\n          if (this.isConverged()) {\n            if (this.prunedNodesAll.length > 0) {\n              this.isTreeGrowing = true;\n            } else {\n              return true;\n            }\n          }\n\n          this.coolingCycle++;\n\n          if (this.layoutQuality == 0) {\n            // quality - \"draft\"\n            this.coolingAdjuster = this.coolingCycle;\n          } else if (this.layoutQuality == 1) {\n            // quality - \"default\"\n            this.coolingAdjuster = this.coolingCycle / 3;\n          } // cooling schedule is based on http://www.btluke.com/simanf1.html -> cooling schedule 3\n\n\n          this.coolingFactor = Math.max(this.initialCoolingFactor - Math.pow(this.coolingCycle, Math.log(100 * (this.initialCoolingFactor - this.finalTemperature)) / Math.log(this.maxCoolingCycle)) / 100 * this.coolingAdjuster, this.finalTemperature);\n          this.animationPeriod = Math.ceil(this.initialAnimationPeriod * Math.sqrt(this.coolingFactor));\n        } // Operations while tree is growing again \n\n\n        if (this.isTreeGrowing) {\n          if (this.growTreeIterations % 10 == 0) {\n            if (this.prunedNodesAll.length > 0) {\n              this.graphManager.updateBounds();\n              this.updateGrid();\n              this.growTree(this.prunedNodesAll); // Update nodes that gravity will be applied\n\n              this.graphManager.resetAllNodesToApplyGravitation();\n              var allNodes = new Set(this.getAllNodes());\n              var intersection = this.nodesWithGravity.filter(function (x) {\n                return allNodes.has(x);\n              });\n              this.graphManager.setAllNodesToApplyGravitation(intersection);\n              this.graphManager.updateBounds();\n              this.updateGrid();\n              this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n            } else {\n              this.isTreeGrowing = false;\n              this.isGrowthFinished = true;\n            }\n          }\n\n          this.growTreeIterations++;\n        } // Operations after growth is finished\n\n\n        if (this.isGrowthFinished) {\n          if (this.isConverged()) {\n            return true;\n          }\n\n          if (this.afterGrowthIterations % 10 == 0) {\n            this.graphManager.updateBounds();\n            this.updateGrid();\n          }\n\n          this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL * ((100 - this.afterGrowthIterations) / 100);\n          this.afterGrowthIterations++;\n        }\n\n        var gridUpdateAllowed = !this.isTreeGrowing && !this.isGrowthFinished;\n        var forceToNodeSurroundingUpdate = this.growTreeIterations % 10 == 1 && this.isTreeGrowing || this.afterGrowthIterations % 10 == 1 && this.isGrowthFinished;\n        this.totalDisplacement = 0;\n        this.graphManager.updateBounds();\n        this.calcSpringForces();\n        this.calcRepulsionForces(gridUpdateAllowed, forceToNodeSurroundingUpdate);\n        this.calcGravitationalForces();\n        this.moveNodes();\n        this.animate();\n        return false; // Layout is not ended yet return false\n      };\n\n      CoSELayout.prototype.getPositionsData = function () {\n        var allNodes = this.graphManager.getAllNodes();\n        var pData = {};\n\n        for (var i = 0; i < allNodes.length; i++) {\n          var rect = allNodes[i].rect;\n          var id = allNodes[i].id;\n          pData[id] = {\n            id: id,\n            x: rect.getCenterX(),\n            y: rect.getCenterY(),\n            w: rect.width,\n            h: rect.height\n          };\n        }\n\n        return pData;\n      };\n\n      CoSELayout.prototype.runSpringEmbedder = function () {\n        this.initialAnimationPeriod = 25;\n        this.animationPeriod = this.initialAnimationPeriod;\n        var layoutEnded = false; // If aminate option is 'during' signal that layout is supposed to start iterating\n\n        if (FDLayoutConstants.ANIMATE === 'during') {\n          this.emit('layoutstarted');\n        } else {\n          // If aminate option is 'during' tick() function will be called on index.js\n          while (!layoutEnded) {\n            layoutEnded = this.tick();\n          }\n\n          this.graphManager.updateBounds();\n        }\n      };\n\n      CoSELayout.prototype.calculateNodesToApplyGravitationTo = function () {\n        var nodeList = [];\n        var graph;\n        var graphs = this.graphManager.getGraphs();\n        var size = graphs.length;\n        var i;\n\n        for (i = 0; i < size; i++) {\n          graph = graphs[i];\n          graph.updateConnected();\n\n          if (!graph.isConnected) {\n            nodeList = nodeList.concat(graph.getNodes());\n          }\n        }\n\n        return nodeList;\n      };\n\n      CoSELayout.prototype.createBendpoints = function () {\n        var edges = [];\n        edges = edges.concat(this.graphManager.getAllEdges());\n        var visited = new Set();\n        var i;\n\n        for (i = 0; i < edges.length; i++) {\n          var edge = edges[i];\n\n          if (!visited.has(edge)) {\n            var source = edge.getSource();\n            var target = edge.getTarget();\n\n            if (source == target) {\n              edge.getBendpoints().push(new PointD());\n              edge.getBendpoints().push(new PointD());\n              this.createDummyNodesForBendpoints(edge);\n              visited.add(edge);\n            } else {\n              var edgeList = [];\n              edgeList = edgeList.concat(source.getEdgeListToNode(target));\n              edgeList = edgeList.concat(target.getEdgeListToNode(source));\n\n              if (!visited.has(edgeList[0])) {\n                if (edgeList.length > 1) {\n                  var k;\n\n                  for (k = 0; k < edgeList.length; k++) {\n                    var multiEdge = edgeList[k];\n                    multiEdge.getBendpoints().push(new PointD());\n                    this.createDummyNodesForBendpoints(multiEdge);\n                  }\n                }\n\n                edgeList.forEach(function (edge) {\n                  visited.add(edge);\n                });\n              }\n            }\n          }\n\n          if (visited.size == edges.length) {\n            break;\n          }\n        }\n      };\n\n      CoSELayout.prototype.positionNodesRadially = function (forest) {\n        // We tile the trees to a grid row by row; first tree starts at (0,0)\n        var currentStartingPoint = new Point(0, 0);\n        var numberOfColumns = Math.ceil(Math.sqrt(forest.length));\n        var height = 0;\n        var currentY = 0;\n        var currentX = 0;\n        var point = new PointD(0, 0);\n\n        for (var i = 0; i < forest.length; i++) {\n          if (i % numberOfColumns == 0) {\n            // Start of a new row, make the x coordinate 0, increment the\n            // y coordinate with the max height of the previous row\n            currentX = 0;\n            currentY = height;\n\n            if (i != 0) {\n              currentY += CoSEConstants.DEFAULT_COMPONENT_SEPERATION;\n            }\n\n            height = 0;\n          }\n\n          var tree = forest[i]; // Find the center of the tree\n\n          var centerNode = Layout.findCenterOfTree(tree); // Set the staring point of the next tree\n\n          currentStartingPoint.x = currentX;\n          currentStartingPoint.y = currentY; // Do a radial layout starting with the center\n\n          point = CoSELayout.radialLayout(tree, centerNode, currentStartingPoint);\n\n          if (point.y > height) {\n            height = Math.floor(point.y);\n          }\n\n          currentX = Math.floor(point.x + CoSEConstants.DEFAULT_COMPONENT_SEPERATION);\n        }\n\n        this.transform(new PointD(LayoutConstants.WORLD_CENTER_X - point.x / 2, LayoutConstants.WORLD_CENTER_Y - point.y / 2));\n      };\n\n      CoSELayout.radialLayout = function (tree, centerNode, startingPoint) {\n        var radialSep = Math.max(this.maxDiagonalInTree(tree), CoSEConstants.DEFAULT_RADIAL_SEPARATION);\n        CoSELayout.branchRadialLayout(centerNode, null, 0, 359, 0, radialSep);\n        var bounds = LGraph.calculateBounds(tree);\n        var transform = new Transform();\n        transform.setDeviceOrgX(bounds.getMinX());\n        transform.setDeviceOrgY(bounds.getMinY());\n        transform.setWorldOrgX(startingPoint.x);\n        transform.setWorldOrgY(startingPoint.y);\n\n        for (var i = 0; i < tree.length; i++) {\n          var node = tree[i];\n          node.transform(transform);\n        }\n\n        var bottomRight = new PointD(bounds.getMaxX(), bounds.getMaxY());\n        return transform.inverseTransformPoint(bottomRight);\n      };\n\n      CoSELayout.branchRadialLayout = function (node, parentOfNode, startAngle, endAngle, distance, radialSeparation) {\n        // First, position this node by finding its angle.\n        var halfInterval = (endAngle - startAngle + 1) / 2;\n\n        if (halfInterval < 0) {\n          halfInterval += 180;\n        }\n\n        var nodeAngle = (halfInterval + startAngle) % 360;\n        var teta = nodeAngle * IGeometry.TWO_PI / 360; // Make polar to java cordinate conversion.\n\n        var cos_teta = Math.cos(teta);\n        var x_ = distance * Math.cos(teta);\n        var y_ = distance * Math.sin(teta);\n        node.setCenter(x_, y_); // Traverse all neighbors of this node and recursively call this\n        // function.\n\n        var neighborEdges = [];\n        neighborEdges = neighborEdges.concat(node.getEdges());\n        var childCount = neighborEdges.length;\n\n        if (parentOfNode != null) {\n          childCount--;\n        }\n\n        var branchCount = 0;\n        var incEdgesCount = neighborEdges.length;\n        var startIndex;\n        var edges = node.getEdgesBetween(parentOfNode); // If there are multiple edges, prune them until there remains only one\n        // edge.\n\n        while (edges.length > 1) {\n          //neighborEdges.remove(edges.remove(0));\n          var temp = edges[0];\n          edges.splice(0, 1);\n          var index = neighborEdges.indexOf(temp);\n\n          if (index >= 0) {\n            neighborEdges.splice(index, 1);\n          }\n\n          incEdgesCount--;\n          childCount--;\n        }\n\n        if (parentOfNode != null) {\n          //assert edges.length == 1;\n          startIndex = (neighborEdges.indexOf(edges[0]) + 1) % incEdgesCount;\n        } else {\n          startIndex = 0;\n        }\n\n        var stepAngle = Math.abs(endAngle - startAngle) / childCount;\n\n        for (var i = startIndex; branchCount != childCount; i = ++i % incEdgesCount) {\n          var currentNeighbor = neighborEdges[i].getOtherEnd(node); // Don't back traverse to root node in current tree.\n\n          if (currentNeighbor == parentOfNode) {\n            continue;\n          }\n\n          var childStartAngle = (startAngle + branchCount * stepAngle) % 360;\n          var childEndAngle = (childStartAngle + stepAngle) % 360;\n          CoSELayout.branchRadialLayout(currentNeighbor, node, childStartAngle, childEndAngle, distance + radialSeparation, radialSeparation);\n          branchCount++;\n        }\n      };\n\n      CoSELayout.maxDiagonalInTree = function (tree) {\n        var maxDiagonal = Integer.MIN_VALUE;\n\n        for (var i = 0; i < tree.length; i++) {\n          var node = tree[i];\n          var diagonal = node.getDiagonal();\n\n          if (diagonal > maxDiagonal) {\n            maxDiagonal = diagonal;\n          }\n        }\n\n        return maxDiagonal;\n      };\n\n      CoSELayout.prototype.calcRepulsionRange = function () {\n        // formula is 2 x (level + 1) x idealEdgeLength\n        return 2 * (this.level + 1) * this.idealEdgeLength;\n      }; // Tiling methods\n      // Group zero degree members whose parents are not to be tiled, create dummy parents where needed and fill memberGroups by their dummp parent id's\n\n\n      CoSELayout.prototype.groupZeroDegreeMembers = function () {\n        var self = this; // array of [parent_id x oneDegreeNode_id]\n\n        var tempMemberGroups = {}; // A temporary map of parent node and its zero degree members\n\n        this.memberGroups = {}; // A map of dummy parent node and its zero degree members whose parents are not to be tiled\n\n        this.idToDummyNode = {}; // A map of id to dummy node \n\n        var zeroDegree = []; // List of zero degree nodes whose parents are not to be tiled\n\n        var allNodes = this.graphManager.getAllNodes(); // Fill zero degree list\n\n        for (var i = 0; i < allNodes.length; i++) {\n          var node = allNodes[i];\n          var parent = node.getParent(); // If a node has zero degree and its parent is not to be tiled if exists add that node to zeroDegres list\n\n          if (this.getNodeDegreeWithChildren(node) === 0 && (parent.id == undefined || !this.getToBeTiled(parent))) {\n            zeroDegree.push(node);\n          }\n        } // Create a map of parent node and its zero degree members\n\n\n        for (var i = 0; i < zeroDegree.length; i++) {\n          var node = zeroDegree[i]; // Zero degree node itself\n\n          var p_id = node.getParent().id; // Parent id\n\n          if (typeof tempMemberGroups[p_id] === \"undefined\") tempMemberGroups[p_id] = [];\n          tempMemberGroups[p_id] = tempMemberGroups[p_id].concat(node); // Push node to the list belongs to its parent in tempMemberGroups\n        } // If there are at least two nodes at a level, create a dummy compound for them\n\n\n        Object.keys(tempMemberGroups).forEach(function (p_id) {\n          if (tempMemberGroups[p_id].length > 1) {\n            var dummyCompoundId = \"DummyCompound_\" + p_id; // The id of dummy compound which will be created soon\n\n            self.memberGroups[dummyCompoundId] = tempMemberGroups[p_id]; // Add dummy compound to memberGroups\n\n            var parent = tempMemberGroups[p_id][0].getParent(); // The parent of zero degree nodes will be the parent of new dummy compound\n            // Create a dummy compound with calculated id\n\n            var dummyCompound = new CoSENode(self.graphManager);\n            dummyCompound.id = dummyCompoundId;\n            dummyCompound.paddingLeft = parent.paddingLeft || 0;\n            dummyCompound.paddingRight = parent.paddingRight || 0;\n            dummyCompound.paddingBottom = parent.paddingBottom || 0;\n            dummyCompound.paddingTop = parent.paddingTop || 0;\n            self.idToDummyNode[dummyCompoundId] = dummyCompound;\n            var dummyParentGraph = self.getGraphManager().add(self.newGraph(), dummyCompound);\n            var parentGraph = parent.getChild(); // Add dummy compound to parent the graph\n\n            parentGraph.add(dummyCompound); // For each zero degree node in this level remove it from its parent graph and add it to the graph of dummy parent\n\n            for (var i = 0; i < tempMemberGroups[p_id].length; i++) {\n              var node = tempMemberGroups[p_id][i];\n              parentGraph.remove(node);\n              dummyParentGraph.add(node);\n            }\n          }\n        });\n      };\n\n      CoSELayout.prototype.clearCompounds = function () {\n        var childGraphMap = {};\n        var idToNode = {}; // Get compound ordering by finding the inner one first\n\n        this.performDFSOnCompounds();\n\n        for (var i = 0; i < this.compoundOrder.length; i++) {\n          idToNode[this.compoundOrder[i].id] = this.compoundOrder[i];\n          childGraphMap[this.compoundOrder[i].id] = [].concat(this.compoundOrder[i].getChild().getNodes()); // Remove children of compounds\n\n          this.graphManager.remove(this.compoundOrder[i].getChild());\n          this.compoundOrder[i].child = null;\n        }\n\n        this.graphManager.resetAllNodes(); // Tile the removed children\n\n        this.tileCompoundMembers(childGraphMap, idToNode);\n      };\n\n      CoSELayout.prototype.clearZeroDegreeMembers = function () {\n        var self = this;\n        var tiledZeroDegreePack = this.tiledZeroDegreePack = [];\n        Object.keys(this.memberGroups).forEach(function (id) {\n          var compoundNode = self.idToDummyNode[id]; // Get the dummy compound\n\n          tiledZeroDegreePack[id] = self.tileNodes(self.memberGroups[id], compoundNode.paddingLeft + compoundNode.paddingRight); // Set the width and height of the dummy compound as calculated\n\n          compoundNode.rect.width = tiledZeroDegreePack[id].width;\n          compoundNode.rect.height = tiledZeroDegreePack[id].height;\n        });\n      };\n\n      CoSELayout.prototype.repopulateCompounds = function () {\n        for (var i = this.compoundOrder.length - 1; i >= 0; i--) {\n          var lCompoundNode = this.compoundOrder[i];\n          var id = lCompoundNode.id;\n          var horizontalMargin = lCompoundNode.paddingLeft;\n          var verticalMargin = lCompoundNode.paddingTop;\n          this.adjustLocations(this.tiledMemberPack[id], lCompoundNode.rect.x, lCompoundNode.rect.y, horizontalMargin, verticalMargin);\n        }\n      };\n\n      CoSELayout.prototype.repopulateZeroDegreeMembers = function () {\n        var self = this;\n        var tiledPack = this.tiledZeroDegreePack;\n        Object.keys(tiledPack).forEach(function (id) {\n          var compoundNode = self.idToDummyNode[id]; // Get the dummy compound by its id\n\n          var horizontalMargin = compoundNode.paddingLeft;\n          var verticalMargin = compoundNode.paddingTop; // Adjust the positions of nodes wrt its compound\n\n          self.adjustLocations(tiledPack[id], compoundNode.rect.x, compoundNode.rect.y, horizontalMargin, verticalMargin);\n        });\n      };\n\n      CoSELayout.prototype.getToBeTiled = function (node) {\n        var id = node.id; //firstly check the previous results\n\n        if (this.toBeTiled[id] != null) {\n          return this.toBeTiled[id];\n        } //only compound nodes are to be tiled\n\n\n        var childGraph = node.getChild();\n\n        if (childGraph == null) {\n          this.toBeTiled[id] = false;\n          return false;\n        }\n\n        var children = childGraph.getNodes(); // Get the children nodes\n        //a compound node is not to be tiled if all of its compound children are not to be tiled\n\n        for (var i = 0; i < children.length; i++) {\n          var theChild = children[i];\n\n          if (this.getNodeDegree(theChild) > 0) {\n            this.toBeTiled[id] = false;\n            return false;\n          } //pass the children not having the compound structure\n\n\n          if (theChild.getChild() == null) {\n            this.toBeTiled[theChild.id] = false;\n            continue;\n          }\n\n          if (!this.getToBeTiled(theChild)) {\n            this.toBeTiled[id] = false;\n            return false;\n          }\n        }\n\n        this.toBeTiled[id] = true;\n        return true;\n      }; // Get degree of a node depending of its edges and independent of its children\n\n\n      CoSELayout.prototype.getNodeDegree = function (node) {\n        var id = node.id;\n        var edges = node.getEdges();\n        var degree = 0; // For the edges connected\n\n        for (var i = 0; i < edges.length; i++) {\n          var edge = edges[i];\n\n          if (edge.getSource().id !== edge.getTarget().id) {\n            degree = degree + 1;\n          }\n        }\n\n        return degree;\n      }; // Get degree of a node with its children\n\n\n      CoSELayout.prototype.getNodeDegreeWithChildren = function (node) {\n        var degree = this.getNodeDegree(node);\n\n        if (node.getChild() == null) {\n          return degree;\n        }\n\n        var children = node.getChild().getNodes();\n\n        for (var i = 0; i < children.length; i++) {\n          var child = children[i];\n          degree += this.getNodeDegreeWithChildren(child);\n        }\n\n        return degree;\n      };\n\n      CoSELayout.prototype.performDFSOnCompounds = function () {\n        this.compoundOrder = [];\n        this.fillCompexOrderByDFS(this.graphManager.getRoot().getNodes());\n      };\n\n      CoSELayout.prototype.fillCompexOrderByDFS = function (children) {\n        for (var i = 0; i < children.length; i++) {\n          var child = children[i];\n\n          if (child.getChild() != null) {\n            this.fillCompexOrderByDFS(child.getChild().getNodes());\n          }\n\n          if (this.getToBeTiled(child)) {\n            this.compoundOrder.push(child);\n          }\n        }\n      };\n      /**\n      * This method places each zero degree member wrt given (x,y) coordinates (top left).\n      */\n\n\n      CoSELayout.prototype.adjustLocations = function (organization, x, y, compoundHorizontalMargin, compoundVerticalMargin) {\n        x += compoundHorizontalMargin;\n        y += compoundVerticalMargin;\n        var left = x;\n\n        for (var i = 0; i < organization.rows.length; i++) {\n          var row = organization.rows[i];\n          x = left;\n          var maxHeight = 0;\n\n          for (var j = 0; j < row.length; j++) {\n            var lnode = row[j];\n            lnode.rect.x = x; // + lnode.rect.width / 2;\n\n            lnode.rect.y = y; // + lnode.rect.height / 2;\n\n            x += lnode.rect.width + organization.horizontalPadding;\n            if (lnode.rect.height > maxHeight) maxHeight = lnode.rect.height;\n          }\n\n          y += maxHeight + organization.verticalPadding;\n        }\n      };\n\n      CoSELayout.prototype.tileCompoundMembers = function (childGraphMap, idToNode) {\n        var self = this;\n        this.tiledMemberPack = [];\n        Object.keys(childGraphMap).forEach(function (id) {\n          // Get the compound node\n          var compoundNode = idToNode[id];\n          self.tiledMemberPack[id] = self.tileNodes(childGraphMap[id], compoundNode.paddingLeft + compoundNode.paddingRight);\n          compoundNode.rect.width = self.tiledMemberPack[id].width;\n          compoundNode.rect.height = self.tiledMemberPack[id].height;\n        });\n      };\n\n      CoSELayout.prototype.tileNodes = function (nodes, minWidth) {\n        var verticalPadding = CoSEConstants.TILING_PADDING_VERTICAL;\n        var horizontalPadding = CoSEConstants.TILING_PADDING_HORIZONTAL;\n        var organization = {\n          rows: [],\n          rowWidth: [],\n          rowHeight: [],\n          width: 0,\n          height: minWidth,\n          // assume minHeight equals to minWidth\n          verticalPadding: verticalPadding,\n          horizontalPadding: horizontalPadding\n        }; // Sort the nodes in ascending order of their areas\n\n        nodes.sort(function (n1, n2) {\n          if (n1.rect.width * n1.rect.height > n2.rect.width * n2.rect.height) return -1;\n          if (n1.rect.width * n1.rect.height < n2.rect.width * n2.rect.height) return 1;\n          return 0;\n        }); // Create the organization -> tile members\n\n        for (var i = 0; i < nodes.length; i++) {\n          var lNode = nodes[i];\n\n          if (organization.rows.length == 0) {\n            this.insertNodeToRow(organization, lNode, 0, minWidth);\n          } else if (this.canAddHorizontal(organization, lNode.rect.width, lNode.rect.height)) {\n            this.insertNodeToRow(organization, lNode, this.getShortestRowIndex(organization), minWidth);\n          } else {\n            this.insertNodeToRow(organization, lNode, organization.rows.length, minWidth);\n          }\n\n          this.shiftToLastRow(organization);\n        }\n\n        return organization;\n      };\n\n      CoSELayout.prototype.insertNodeToRow = function (organization, node, rowIndex, minWidth) {\n        var minCompoundSize = minWidth; // Add new row if needed\n\n        if (rowIndex == organization.rows.length) {\n          var secondDimension = [];\n          organization.rows.push(secondDimension);\n          organization.rowWidth.push(minCompoundSize);\n          organization.rowHeight.push(0);\n        } // Update row width\n\n\n        var w = organization.rowWidth[rowIndex] + node.rect.width;\n\n        if (organization.rows[rowIndex].length > 0) {\n          w += organization.horizontalPadding;\n        }\n\n        organization.rowWidth[rowIndex] = w; // Update compound width\n\n        if (organization.width < w) {\n          organization.width = w;\n        } // Update height\n\n\n        var h = node.rect.height;\n        if (rowIndex > 0) h += organization.verticalPadding;\n        var extraHeight = 0;\n\n        if (h > organization.rowHeight[rowIndex]) {\n          extraHeight = organization.rowHeight[rowIndex];\n          organization.rowHeight[rowIndex] = h;\n          extraHeight = organization.rowHeight[rowIndex] - extraHeight;\n        }\n\n        organization.height += extraHeight; // Insert node\n\n        organization.rows[rowIndex].push(node);\n      }; //Scans the rows of an organization and returns the one with the min width\n\n\n      CoSELayout.prototype.getShortestRowIndex = function (organization) {\n        var r = -1;\n        var min = Number.MAX_VALUE;\n\n        for (var i = 0; i < organization.rows.length; i++) {\n          if (organization.rowWidth[i] < min) {\n            r = i;\n            min = organization.rowWidth[i];\n          }\n        }\n\n        return r;\n      }; //Scans the rows of an organization and returns the one with the max width\n\n\n      CoSELayout.prototype.getLongestRowIndex = function (organization) {\n        var r = -1;\n        var max = Number.MIN_VALUE;\n\n        for (var i = 0; i < organization.rows.length; i++) {\n          if (organization.rowWidth[i] > max) {\n            r = i;\n            max = organization.rowWidth[i];\n          }\n        }\n\n        return r;\n      };\n      /**\n      * This method checks whether adding extra width to the organization violates\n      * the aspect ratio(1) or not.\n      */\n\n\n      CoSELayout.prototype.canAddHorizontal = function (organization, extraWidth, extraHeight) {\n        var sri = this.getShortestRowIndex(organization);\n\n        if (sri < 0) {\n          return true;\n        }\n\n        var min = organization.rowWidth[sri];\n        if (min + organization.horizontalPadding + extraWidth <= organization.width) return true;\n        var hDiff = 0; // Adding to an existing row\n\n        if (organization.rowHeight[sri] < extraHeight) {\n          if (sri > 0) hDiff = extraHeight + organization.verticalPadding - organization.rowHeight[sri];\n        }\n\n        var add_to_row_ratio;\n\n        if (organization.width - min >= extraWidth + organization.horizontalPadding) {\n          add_to_row_ratio = (organization.height + hDiff) / (min + extraWidth + organization.horizontalPadding);\n        } else {\n          add_to_row_ratio = (organization.height + hDiff) / organization.width;\n        } // Adding a new row for this node\n\n\n        hDiff = extraHeight + organization.verticalPadding;\n        var add_new_row_ratio;\n\n        if (organization.width < extraWidth) {\n          add_new_row_ratio = (organization.height + hDiff) / extraWidth;\n        } else {\n          add_new_row_ratio = (organization.height + hDiff) / organization.width;\n        }\n\n        if (add_new_row_ratio < 1) add_new_row_ratio = 1 / add_new_row_ratio;\n        if (add_to_row_ratio < 1) add_to_row_ratio = 1 / add_to_row_ratio;\n        return add_to_row_ratio < add_new_row_ratio;\n      }; //If moving the last node from the longest row and adding it to the last\n      //row makes the bounding box smaller, do it.\n\n\n      CoSELayout.prototype.shiftToLastRow = function (organization) {\n        var longest = this.getLongestRowIndex(organization);\n        var last = organization.rowWidth.length - 1;\n        var row = organization.rows[longest];\n        var node = row[row.length - 1];\n        var diff = node.width + organization.horizontalPadding; // Check if there is enough space on the last row\n\n        if (organization.width - organization.rowWidth[last] > diff && longest != last) {\n          // Remove the last element of the longest row\n          row.splice(-1, 1); // Push it to the last row\n\n          organization.rows[last].push(node);\n          organization.rowWidth[longest] = organization.rowWidth[longest] - diff;\n          organization.rowWidth[last] = organization.rowWidth[last] + diff;\n          organization.width = organization.rowWidth[instance.getLongestRowIndex(organization)]; // Update heights of the organization\n\n          var maxHeight = Number.MIN_VALUE;\n\n          for (var i = 0; i < row.length; i++) {\n            if (row[i].height > maxHeight) maxHeight = row[i].height;\n          }\n\n          if (longest > 0) maxHeight += organization.verticalPadding;\n          var prevTotal = organization.rowHeight[longest] + organization.rowHeight[last];\n          organization.rowHeight[longest] = maxHeight;\n          if (organization.rowHeight[last] < node.height + organization.verticalPadding) organization.rowHeight[last] = node.height + organization.verticalPadding;\n          var finalTotal = organization.rowHeight[longest] + organization.rowHeight[last];\n          organization.height += finalTotal - prevTotal;\n          this.shiftToLastRow(organization);\n        }\n      };\n\n      CoSELayout.prototype.tilingPreLayout = function () {\n        if (CoSEConstants.TILE) {\n          // Find zero degree nodes and create a compound for each level\n          this.groupZeroDegreeMembers(); // Tile and clear children of each compound\n\n          this.clearCompounds(); // Separately tile and clear zero degree nodes for each level\n\n          this.clearZeroDegreeMembers();\n        }\n      };\n\n      CoSELayout.prototype.tilingPostLayout = function () {\n        if (CoSEConstants.TILE) {\n          this.repopulateZeroDegreeMembers();\n          this.repopulateCompounds();\n        }\n      }; // -----------------------------------------------------------------------------\n      // Section: Tree Reduction methods\n      // -----------------------------------------------------------------------------\n      // Reduce trees \n\n\n      CoSELayout.prototype.reduceTrees = function () {\n        var prunedNodesAll = [];\n        var containsLeaf = true;\n        var node;\n\n        while (containsLeaf) {\n          var allNodes = this.graphManager.getAllNodes();\n          var prunedNodesInStepTemp = [];\n          containsLeaf = false;\n\n          for (var i = 0; i < allNodes.length; i++) {\n            node = allNodes[i];\n\n            if (node.getEdges().length == 1 && !node.getEdges()[0].isInterGraph && node.getChild() == null) {\n              prunedNodesInStepTemp.push([node, node.getEdges()[0], node.getOwner()]);\n              containsLeaf = true;\n            }\n          }\n\n          if (containsLeaf == true) {\n            var prunedNodesInStep = [];\n\n            for (var j = 0; j < prunedNodesInStepTemp.length; j++) {\n              if (prunedNodesInStepTemp[j][0].getEdges().length == 1) {\n                prunedNodesInStep.push(prunedNodesInStepTemp[j]);\n                prunedNodesInStepTemp[j][0].getOwner().remove(prunedNodesInStepTemp[j][0]);\n              }\n            }\n\n            prunedNodesAll.push(prunedNodesInStep);\n            this.graphManager.resetAllNodes();\n            this.graphManager.resetAllEdges();\n          }\n        }\n\n        this.prunedNodesAll = prunedNodesAll;\n      }; // Grow tree one step \n\n\n      CoSELayout.prototype.growTree = function (prunedNodesAll) {\n        var lengthOfPrunedNodesInStep = prunedNodesAll.length;\n        var prunedNodesInStep = prunedNodesAll[lengthOfPrunedNodesInStep - 1];\n        var nodeData;\n\n        for (var i = 0; i < prunedNodesInStep.length; i++) {\n          nodeData = prunedNodesInStep[i];\n          this.findPlaceforPrunedNode(nodeData);\n          nodeData[2].add(nodeData[0]);\n          nodeData[2].add(nodeData[1], nodeData[1].source, nodeData[1].target);\n        }\n\n        prunedNodesAll.splice(prunedNodesAll.length - 1, 1);\n        this.graphManager.resetAllNodes();\n        this.graphManager.resetAllEdges();\n      }; // Find an appropriate position to replace pruned node, this method can be improved\n\n\n      CoSELayout.prototype.findPlaceforPrunedNode = function (nodeData) {\n        var gridForPrunedNode;\n        var nodeToConnect;\n        var prunedNode = nodeData[0];\n\n        if (prunedNode == nodeData[1].source) {\n          nodeToConnect = nodeData[1].target;\n        } else {\n          nodeToConnect = nodeData[1].source;\n        }\n\n        var startGridX = nodeToConnect.startX;\n        var finishGridX = nodeToConnect.finishX;\n        var startGridY = nodeToConnect.startY;\n        var finishGridY = nodeToConnect.finishY;\n        var upNodeCount = 0;\n        var downNodeCount = 0;\n        var rightNodeCount = 0;\n        var leftNodeCount = 0;\n        var controlRegions = [upNodeCount, rightNodeCount, downNodeCount, leftNodeCount];\n\n        if (startGridY > 0) {\n          for (var i = startGridX; i <= finishGridX; i++) {\n            controlRegions[0] += this.grid[i][startGridY - 1].length + this.grid[i][startGridY].length - 1;\n          }\n        }\n\n        if (finishGridX < this.grid.length - 1) {\n          for (var i = startGridY; i <= finishGridY; i++) {\n            controlRegions[1] += this.grid[finishGridX + 1][i].length + this.grid[finishGridX][i].length - 1;\n          }\n        }\n\n        if (finishGridY < this.grid[0].length - 1) {\n          for (var i = startGridX; i <= finishGridX; i++) {\n            controlRegions[2] += this.grid[i][finishGridY + 1].length + this.grid[i][finishGridY].length - 1;\n          }\n        }\n\n        if (startGridX > 0) {\n          for (var i = startGridY; i <= finishGridY; i++) {\n            controlRegions[3] += this.grid[startGridX - 1][i].length + this.grid[startGridX][i].length - 1;\n          }\n        }\n\n        var min = Integer.MAX_VALUE;\n        var minCount;\n        var minIndex;\n\n        for (var j = 0; j < controlRegions.length; j++) {\n          if (controlRegions[j] < min) {\n            min = controlRegions[j];\n            minCount = 1;\n            minIndex = j;\n          } else if (controlRegions[j] == min) {\n            minCount++;\n          }\n        }\n\n        if (minCount == 3 && min == 0) {\n          if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[2] == 0) {\n            gridForPrunedNode = 1;\n          } else if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[3] == 0) {\n            gridForPrunedNode = 0;\n          } else if (controlRegions[0] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) {\n            gridForPrunedNode = 3;\n          } else if (controlRegions[1] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) {\n            gridForPrunedNode = 2;\n          }\n        } else if (minCount == 2 && min == 0) {\n          var random = Math.floor(Math.random() * 2);\n\n          if (controlRegions[0] == 0 && controlRegions[1] == 0) {\n            ;\n\n            if (random == 0) {\n              gridForPrunedNode = 0;\n            } else {\n              gridForPrunedNode = 1;\n            }\n          } else if (controlRegions[0] == 0 && controlRegions[2] == 0) {\n            if (random == 0) {\n              gridForPrunedNode = 0;\n            } else {\n              gridForPrunedNode = 2;\n            }\n          } else if (controlRegions[0] == 0 && controlRegions[3] == 0) {\n            if (random == 0) {\n              gridForPrunedNode = 0;\n            } else {\n              gridForPrunedNode = 3;\n            }\n          } else if (controlRegions[1] == 0 && controlRegions[2] == 0) {\n            if (random == 0) {\n              gridForPrunedNode = 1;\n            } else {\n              gridForPrunedNode = 2;\n            }\n          } else if (controlRegions[1] == 0 && controlRegions[3] == 0) {\n            if (random == 0) {\n              gridForPrunedNode = 1;\n            } else {\n              gridForPrunedNode = 3;\n            }\n          } else {\n            if (random == 0) {\n              gridForPrunedNode = 2;\n            } else {\n              gridForPrunedNode = 3;\n            }\n          }\n        } else if (minCount == 4 && min == 0) {\n          var random = Math.floor(Math.random() * 4);\n          gridForPrunedNode = random;\n        } else {\n          gridForPrunedNode = minIndex;\n        }\n\n        if (gridForPrunedNode == 0) {\n          prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() - nodeToConnect.getHeight() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getHeight() / 2);\n        } else if (gridForPrunedNode == 1) {\n          prunedNode.setCenter(nodeToConnect.getCenterX() + nodeToConnect.getWidth() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getWidth() / 2, nodeToConnect.getCenterY());\n        } else if (gridForPrunedNode == 2) {\n          prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() + nodeToConnect.getHeight() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getHeight() / 2);\n        } else {\n          prunedNode.setCenter(nodeToConnect.getCenterX() - nodeToConnect.getWidth() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getWidth() / 2, nodeToConnect.getCenterY());\n        }\n      };\n\n      module.exports = CoSELayout;\n      /***/\n    },\n    /* 7 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var coseBase = {};\n      coseBase.layoutBase = __webpack_require__(0);\n      coseBase.CoSEConstants = __webpack_require__(1);\n      coseBase.CoSEEdge = __webpack_require__(2);\n      coseBase.CoSEGraph = __webpack_require__(3);\n      coseBase.CoSEGraphManager = __webpack_require__(4);\n      coseBase.CoSELayout = __webpack_require__(6);\n      coseBase.CoSENode = __webpack_require__(5);\n      module.exports = coseBase;\n      /***/\n    }\n    /******/\n    ])\n  );\n});","map":{"version":3,"names":["webpackUniversalModuleDefinition","root","factory","exports","module","require","define","amd","__WEBPACK_EXTERNAL_MODULE_0__","modules","installedModules","__webpack_require__","moduleId","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","getDefault","getModuleExports","object","property","prototype","hasOwnProperty","p","s","FDLayoutConstants","CoSEConstants","prop","DEFAULT_USE_MULTI_LEVEL_SCALING","DEFAULT_RADIAL_SEPARATION","DEFAULT_EDGE_LENGTH","DEFAULT_COMPONENT_SEPERATION","TILE","TILING_PADDING_VERTICAL","TILING_PADDING_HORIZONTAL","TREE_REDUCTION_ON_INCREMENTAL","FDLayoutEdge","CoSEEdge","source","target","vEdge","create","LGraph","CoSEGraph","parent","graphMgr","vGraph","LGraphManager","CoSEGraphManager","layout","FDLayoutNode","IMath","CoSENode","gm","loc","size","vNode","move","graphManager","getLayout","displacementX","coolingFactor","springForceX","repulsionForceX","gravitationForceX","noOfChildren","displacementY","springForceY","repulsionForceY","gravitationForceY","Math","abs","maxNodeDisplacement","sign","child","moveBy","getNodes","length","propogateDisplacementToChildren","totalDisplacement","dX","dY","nodes","getChild","node","setPred1","pred1","getPred1","getPred2","pred2","setNext","next","getNext","setProcessed","processed","isProcessed","FDLayout","LayoutConstants","Point","PointD","Layout","Integer","IGeometry","Transform","CoSELayout","toBeTiled","newGraphManager","newGraph","newNode","newEdge","initParameters","arguments","isSubLayout","idealEdgeLength","useSmartIdealEdgeLengthCalculation","DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION","springConstant","DEFAULT_SPRING_STRENGTH","repulsionConstant","DEFAULT_REPULSION_STRENGTH","gravityConstant","DEFAULT_GRAVITY_STRENGTH","compoundGravityConstant","DEFAULT_COMPOUND_GRAVITY_STRENGTH","gravityRangeFactor","DEFAULT_GRAVITY_RANGE_FACTOR","compoundGravityRangeFactor","DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR","prunedNodesAll","growTreeIterations","afterGrowthIterations","isTreeGrowing","isGrowthFinished","coolingCycle","maxCoolingCycle","maxIterations","CONVERGENCE_CHECK_PERIOD","finalTemperature","coolingAdjuster","createBendsAsNeeded","DEFAULT_CREATE_BENDS_AS_NEEDED","createBendpoints","resetAllEdges","level","classicLayout","nodesWithGravity","calculateNodesToApplyGravitationTo","setAllNodesToApplyGravitation","calcNoOfChildrenForAllNodes","calcLowestCommonAncestors","calcInclusionTreeDepths","getRoot","calcEstimatedSize","calcIdealEdgeLengths","incremental","forest","getFlatForest","positionNodesRadially","reduceTrees","resetAllNodesToApplyGravitation","allNodes","Set","getAllNodes","intersection","filter","x","has","positionNodesRandomly","initSpringEmbedder","runSpringEmbedder","tick","totalIterations","isConverged","layoutQuality","max","initialCoolingFactor","pow","log","animationPeriod","ceil","initialAnimationPeriod","sqrt","updateBounds","updateGrid","growTree","DEFAULT_COOLING_FACTOR_INCREMENTAL","gridUpdateAllowed","forceToNodeSurroundingUpdate","calcSpringForces","calcRepulsionForces","calcGravitationalForces","moveNodes","animate","getPositionsData","pData","rect","id","getCenterX","y","getCenterY","w","width","h","height","layoutEnded","ANIMATE","emit","nodeList","graph","graphs","getGraphs","updateConnected","isConnected","concat","edges","getAllEdges","visited","edge","getSource","getTarget","getBendpoints","push","createDummyNodesForBendpoints","add","edgeList","getEdgeListToNode","k","multiEdge","forEach","currentStartingPoint","numberOfColumns","currentY","currentX","point","tree","centerNode","findCenterOfTree","radialLayout","floor","transform","WORLD_CENTER_X","WORLD_CENTER_Y","startingPoint","radialSep","maxDiagonalInTree","branchRadialLayout","bounds","calculateBounds","setDeviceOrgX","getMinX","setDeviceOrgY","getMinY","setWorldOrgX","setWorldOrgY","bottomRight","getMaxX","getMaxY","inverseTransformPoint","parentOfNode","startAngle","endAngle","distance","radialSeparation","halfInterval","nodeAngle","teta","TWO_PI","cos_teta","cos","x_","y_","sin","setCenter","neighborEdges","getEdges","childCount","branchCount","incEdgesCount","startIndex","getEdgesBetween","temp","splice","index","indexOf","stepAngle","currentNeighbor","getOtherEnd","childStartAngle","childEndAngle","maxDiagonal","MIN_VALUE","diagonal","getDiagonal","calcRepulsionRange","groupZeroDegreeMembers","self","tempMemberGroups","memberGroups","idToDummyNode","zeroDegree","getParent","getNodeDegreeWithChildren","undefined","getToBeTiled","p_id","keys","dummyCompoundId","dummyCompound","paddingLeft","paddingRight","paddingBottom","paddingTop","dummyParentGraph","getGraphManager","parentGraph","remove","clearCompounds","childGraphMap","idToNode","performDFSOnCompounds","compoundOrder","resetAllNodes","tileCompoundMembers","clearZeroDegreeMembers","tiledZeroDegreePack","compoundNode","tileNodes","repopulateCompounds","lCompoundNode","horizontalMargin","verticalMargin","adjustLocations","tiledMemberPack","repopulateZeroDegreeMembers","tiledPack","childGraph","children","theChild","getNodeDegree","degree","fillCompexOrderByDFS","organization","compoundHorizontalMargin","compoundVerticalMargin","left","rows","row","maxHeight","j","lnode","horizontalPadding","verticalPadding","minWidth","rowWidth","rowHeight","sort","n1","n2","lNode","insertNodeToRow","canAddHorizontal","getShortestRowIndex","shiftToLastRow","rowIndex","minCompoundSize","secondDimension","extraHeight","r","min","Number","MAX_VALUE","getLongestRowIndex","extraWidth","sri","hDiff","add_to_row_ratio","add_new_row_ratio","longest","last","diff","instance","prevTotal","finalTotal","tilingPreLayout","tilingPostLayout","containsLeaf","prunedNodesInStepTemp","isInterGraph","getOwner","prunedNodesInStep","lengthOfPrunedNodesInStep","nodeData","findPlaceforPrunedNode","gridForPrunedNode","nodeToConnect","prunedNode","startGridX","startX","finishGridX","finishX","startGridY","startY","finishGridY","finishY","upNodeCount","downNodeCount","rightNodeCount","leftNodeCount","controlRegions","grid","minCount","minIndex","random","getHeight","getWidth","coseBase","layoutBase"],"sources":["/Users/lord/Documents/Programmer/vue/VueProjects/blog-vue/blog-admin/node_modules/cose-base/cose-base.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"layout-base\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"layout-base\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"coseBase\"] = factory(require(\"layout-base\"));\n\telse\n\t\troot[\"coseBase\"] = factory(root[\"layoutBase\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_0__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 7);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar FDLayoutConstants = __webpack_require__(0).FDLayoutConstants;\n\nfunction CoSEConstants() {}\n\n//CoSEConstants inherits static props in FDLayoutConstants\nfor (var prop in FDLayoutConstants) {\n  CoSEConstants[prop] = FDLayoutConstants[prop];\n}\n\nCoSEConstants.DEFAULT_USE_MULTI_LEVEL_SCALING = false;\nCoSEConstants.DEFAULT_RADIAL_SEPARATION = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\nCoSEConstants.DEFAULT_COMPONENT_SEPERATION = 60;\nCoSEConstants.TILE = true;\nCoSEConstants.TILING_PADDING_VERTICAL = 10;\nCoSEConstants.TILING_PADDING_HORIZONTAL = 10;\nCoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = false; // make this true when cose is used incrementally as a part of other non-incremental layout\n\nmodule.exports = CoSEConstants;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar FDLayoutEdge = __webpack_require__(0).FDLayoutEdge;\n\nfunction CoSEEdge(source, target, vEdge) {\n  FDLayoutEdge.call(this, source, target, vEdge);\n}\n\nCoSEEdge.prototype = Object.create(FDLayoutEdge.prototype);\nfor (var prop in FDLayoutEdge) {\n  CoSEEdge[prop] = FDLayoutEdge[prop];\n}\n\nmodule.exports = CoSEEdge;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar LGraph = __webpack_require__(0).LGraph;\n\nfunction CoSEGraph(parent, graphMgr, vGraph) {\n  LGraph.call(this, parent, graphMgr, vGraph);\n}\n\nCoSEGraph.prototype = Object.create(LGraph.prototype);\nfor (var prop in LGraph) {\n  CoSEGraph[prop] = LGraph[prop];\n}\n\nmodule.exports = CoSEGraph;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar LGraphManager = __webpack_require__(0).LGraphManager;\n\nfunction CoSEGraphManager(layout) {\n  LGraphManager.call(this, layout);\n}\n\nCoSEGraphManager.prototype = Object.create(LGraphManager.prototype);\nfor (var prop in LGraphManager) {\n  CoSEGraphManager[prop] = LGraphManager[prop];\n}\n\nmodule.exports = CoSEGraphManager;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar FDLayoutNode = __webpack_require__(0).FDLayoutNode;\nvar IMath = __webpack_require__(0).IMath;\n\nfunction CoSENode(gm, loc, size, vNode) {\n  FDLayoutNode.call(this, gm, loc, size, vNode);\n}\n\nCoSENode.prototype = Object.create(FDLayoutNode.prototype);\nfor (var prop in FDLayoutNode) {\n  CoSENode[prop] = FDLayoutNode[prop];\n}\n\nCoSENode.prototype.move = function () {\n  var layout = this.graphManager.getLayout();\n  this.displacementX = layout.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.noOfChildren;\n  this.displacementY = layout.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.noOfChildren;\n\n  if (Math.abs(this.displacementX) > layout.coolingFactor * layout.maxNodeDisplacement) {\n    this.displacementX = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementX);\n  }\n\n  if (Math.abs(this.displacementY) > layout.coolingFactor * layout.maxNodeDisplacement) {\n    this.displacementY = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementY);\n  }\n\n  // a simple node, just move it\n  if (this.child == null) {\n    this.moveBy(this.displacementX, this.displacementY);\n  }\n  // an empty compound node, again just move it\n  else if (this.child.getNodes().length == 0) {\n      this.moveBy(this.displacementX, this.displacementY);\n    }\n    // non-empty compound node, propogate movement to children as well\n    else {\n        this.propogateDisplacementToChildren(this.displacementX, this.displacementY);\n      }\n\n  layout.totalDisplacement += Math.abs(this.displacementX) + Math.abs(this.displacementY);\n\n  this.springForceX = 0;\n  this.springForceY = 0;\n  this.repulsionForceX = 0;\n  this.repulsionForceY = 0;\n  this.gravitationForceX = 0;\n  this.gravitationForceY = 0;\n  this.displacementX = 0;\n  this.displacementY = 0;\n};\n\nCoSENode.prototype.propogateDisplacementToChildren = function (dX, dY) {\n  var nodes = this.getChild().getNodes();\n  var node;\n  for (var i = 0; i < nodes.length; i++) {\n    node = nodes[i];\n    if (node.getChild() == null) {\n      node.moveBy(dX, dY);\n      node.displacementX += dX;\n      node.displacementY += dY;\n    } else {\n      node.propogateDisplacementToChildren(dX, dY);\n    }\n  }\n};\n\nCoSENode.prototype.setPred1 = function (pred1) {\n  this.pred1 = pred1;\n};\n\nCoSENode.prototype.getPred1 = function () {\n  return pred1;\n};\n\nCoSENode.prototype.getPred2 = function () {\n  return pred2;\n};\n\nCoSENode.prototype.setNext = function (next) {\n  this.next = next;\n};\n\nCoSENode.prototype.getNext = function () {\n  return next;\n};\n\nCoSENode.prototype.setProcessed = function (processed) {\n  this.processed = processed;\n};\n\nCoSENode.prototype.isProcessed = function () {\n  return processed;\n};\n\nmodule.exports = CoSENode;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar FDLayout = __webpack_require__(0).FDLayout;\nvar CoSEGraphManager = __webpack_require__(4);\nvar CoSEGraph = __webpack_require__(3);\nvar CoSENode = __webpack_require__(5);\nvar CoSEEdge = __webpack_require__(2);\nvar CoSEConstants = __webpack_require__(1);\nvar FDLayoutConstants = __webpack_require__(0).FDLayoutConstants;\nvar LayoutConstants = __webpack_require__(0).LayoutConstants;\nvar Point = __webpack_require__(0).Point;\nvar PointD = __webpack_require__(0).PointD;\nvar Layout = __webpack_require__(0).Layout;\nvar Integer = __webpack_require__(0).Integer;\nvar IGeometry = __webpack_require__(0).IGeometry;\nvar LGraph = __webpack_require__(0).LGraph;\nvar Transform = __webpack_require__(0).Transform;\n\nfunction CoSELayout() {\n  FDLayout.call(this);\n\n  this.toBeTiled = {}; // Memorize if a node is to be tiled or is tiled\n}\n\nCoSELayout.prototype = Object.create(FDLayout.prototype);\n\nfor (var prop in FDLayout) {\n  CoSELayout[prop] = FDLayout[prop];\n}\n\nCoSELayout.prototype.newGraphManager = function () {\n  var gm = new CoSEGraphManager(this);\n  this.graphManager = gm;\n  return gm;\n};\n\nCoSELayout.prototype.newGraph = function (vGraph) {\n  return new CoSEGraph(null, this.graphManager, vGraph);\n};\n\nCoSELayout.prototype.newNode = function (vNode) {\n  return new CoSENode(this.graphManager, vNode);\n};\n\nCoSELayout.prototype.newEdge = function (vEdge) {\n  return new CoSEEdge(null, null, vEdge);\n};\n\nCoSELayout.prototype.initParameters = function () {\n  FDLayout.prototype.initParameters.call(this, arguments);\n  if (!this.isSubLayout) {\n    if (CoSEConstants.DEFAULT_EDGE_LENGTH < 10) {\n      this.idealEdgeLength = 10;\n    } else {\n      this.idealEdgeLength = CoSEConstants.DEFAULT_EDGE_LENGTH;\n    }\n\n    this.useSmartIdealEdgeLengthCalculation = CoSEConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION;\n    this.springConstant = FDLayoutConstants.DEFAULT_SPRING_STRENGTH;\n    this.repulsionConstant = FDLayoutConstants.DEFAULT_REPULSION_STRENGTH;\n    this.gravityConstant = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH;\n    this.compoundGravityConstant = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH;\n    this.gravityRangeFactor = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR;\n    this.compoundGravityRangeFactor = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR;\n\n    // variables for tree reduction support\n    this.prunedNodesAll = [];\n    this.growTreeIterations = 0;\n    this.afterGrowthIterations = 0;\n    this.isTreeGrowing = false;\n    this.isGrowthFinished = false;\n\n    // variables for cooling\n    this.coolingCycle = 0;\n    this.maxCoolingCycle = this.maxIterations / FDLayoutConstants.CONVERGENCE_CHECK_PERIOD;\n    this.finalTemperature = FDLayoutConstants.CONVERGENCE_CHECK_PERIOD / this.maxIterations;\n    this.coolingAdjuster = 1;\n  }\n};\n\nCoSELayout.prototype.layout = function () {\n  var createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n  if (createBendsAsNeeded) {\n    this.createBendpoints();\n    this.graphManager.resetAllEdges();\n  }\n\n  this.level = 0;\n  return this.classicLayout();\n};\n\nCoSELayout.prototype.classicLayout = function () {\n  this.nodesWithGravity = this.calculateNodesToApplyGravitationTo();\n  this.graphManager.setAllNodesToApplyGravitation(this.nodesWithGravity);\n  this.calcNoOfChildrenForAllNodes();\n  this.graphManager.calcLowestCommonAncestors();\n  this.graphManager.calcInclusionTreeDepths();\n  this.graphManager.getRoot().calcEstimatedSize();\n  this.calcIdealEdgeLengths();\n\n  if (!this.incremental) {\n    var forest = this.getFlatForest();\n\n    // The graph associated with this layout is flat and a forest\n    if (forest.length > 0) {\n      this.positionNodesRadially(forest);\n    }\n    // The graph associated with this layout is not flat or a forest\n    else {\n        // Reduce the trees when incremental mode is not enabled and graph is not a forest \n        this.reduceTrees();\n        // Update nodes that gravity will be applied\n        this.graphManager.resetAllNodesToApplyGravitation();\n        var allNodes = new Set(this.getAllNodes());\n        var intersection = this.nodesWithGravity.filter(function (x) {\n          return allNodes.has(x);\n        });\n        this.graphManager.setAllNodesToApplyGravitation(intersection);\n\n        this.positionNodesRandomly();\n      }\n  } else {\n    if (CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL) {\n      // Reduce the trees in incremental mode if only this constant is set to true \n      this.reduceTrees();\n      // Update nodes that gravity will be applied\n      this.graphManager.resetAllNodesToApplyGravitation();\n      var allNodes = new Set(this.getAllNodes());\n      var intersection = this.nodesWithGravity.filter(function (x) {\n        return allNodes.has(x);\n      });\n      this.graphManager.setAllNodesToApplyGravitation(intersection);\n    }\n  }\n\n  this.initSpringEmbedder();\n  this.runSpringEmbedder();\n\n  return true;\n};\n\nCoSELayout.prototype.tick = function () {\n  this.totalIterations++;\n\n  if (this.totalIterations === this.maxIterations && !this.isTreeGrowing && !this.isGrowthFinished) {\n    if (this.prunedNodesAll.length > 0) {\n      this.isTreeGrowing = true;\n    } else {\n      return true;\n    }\n  }\n\n  if (this.totalIterations % FDLayoutConstants.CONVERGENCE_CHECK_PERIOD == 0 && !this.isTreeGrowing && !this.isGrowthFinished) {\n    if (this.isConverged()) {\n      if (this.prunedNodesAll.length > 0) {\n        this.isTreeGrowing = true;\n      } else {\n        return true;\n      }\n    }\n\n    this.coolingCycle++;\n\n    if (this.layoutQuality == 0) {\n      // quality - \"draft\"\n      this.coolingAdjuster = this.coolingCycle;\n    } else if (this.layoutQuality == 1) {\n      // quality - \"default\"\n      this.coolingAdjuster = this.coolingCycle / 3;\n    }\n\n    // cooling schedule is based on http://www.btluke.com/simanf1.html -> cooling schedule 3\n    this.coolingFactor = Math.max(this.initialCoolingFactor - Math.pow(this.coolingCycle, Math.log(100 * (this.initialCoolingFactor - this.finalTemperature)) / Math.log(this.maxCoolingCycle)) / 100 * this.coolingAdjuster, this.finalTemperature);\n    this.animationPeriod = Math.ceil(this.initialAnimationPeriod * Math.sqrt(this.coolingFactor));\n  }\n  // Operations while tree is growing again \n  if (this.isTreeGrowing) {\n    if (this.growTreeIterations % 10 == 0) {\n      if (this.prunedNodesAll.length > 0) {\n        this.graphManager.updateBounds();\n        this.updateGrid();\n        this.growTree(this.prunedNodesAll);\n        // Update nodes that gravity will be applied\n        this.graphManager.resetAllNodesToApplyGravitation();\n        var allNodes = new Set(this.getAllNodes());\n        var intersection = this.nodesWithGravity.filter(function (x) {\n          return allNodes.has(x);\n        });\n        this.graphManager.setAllNodesToApplyGravitation(intersection);\n\n        this.graphManager.updateBounds();\n        this.updateGrid();\n        this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n      } else {\n        this.isTreeGrowing = false;\n        this.isGrowthFinished = true;\n      }\n    }\n    this.growTreeIterations++;\n  }\n  // Operations after growth is finished\n  if (this.isGrowthFinished) {\n    if (this.isConverged()) {\n      return true;\n    }\n    if (this.afterGrowthIterations % 10 == 0) {\n      this.graphManager.updateBounds();\n      this.updateGrid();\n    }\n    this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL * ((100 - this.afterGrowthIterations) / 100);\n    this.afterGrowthIterations++;\n  }\n\n  var gridUpdateAllowed = !this.isTreeGrowing && !this.isGrowthFinished;\n  var forceToNodeSurroundingUpdate = this.growTreeIterations % 10 == 1 && this.isTreeGrowing || this.afterGrowthIterations % 10 == 1 && this.isGrowthFinished;\n\n  this.totalDisplacement = 0;\n  this.graphManager.updateBounds();\n  this.calcSpringForces();\n  this.calcRepulsionForces(gridUpdateAllowed, forceToNodeSurroundingUpdate);\n  this.calcGravitationalForces();\n  this.moveNodes();\n  this.animate();\n\n  return false; // Layout is not ended yet return false\n};\n\nCoSELayout.prototype.getPositionsData = function () {\n  var allNodes = this.graphManager.getAllNodes();\n  var pData = {};\n  for (var i = 0; i < allNodes.length; i++) {\n    var rect = allNodes[i].rect;\n    var id = allNodes[i].id;\n    pData[id] = {\n      id: id,\n      x: rect.getCenterX(),\n      y: rect.getCenterY(),\n      w: rect.width,\n      h: rect.height\n    };\n  }\n\n  return pData;\n};\n\nCoSELayout.prototype.runSpringEmbedder = function () {\n  this.initialAnimationPeriod = 25;\n  this.animationPeriod = this.initialAnimationPeriod;\n  var layoutEnded = false;\n\n  // If aminate option is 'during' signal that layout is supposed to start iterating\n  if (FDLayoutConstants.ANIMATE === 'during') {\n    this.emit('layoutstarted');\n  } else {\n    // If aminate option is 'during' tick() function will be called on index.js\n    while (!layoutEnded) {\n      layoutEnded = this.tick();\n    }\n\n    this.graphManager.updateBounds();\n  }\n};\n\nCoSELayout.prototype.calculateNodesToApplyGravitationTo = function () {\n  var nodeList = [];\n  var graph;\n\n  var graphs = this.graphManager.getGraphs();\n  var size = graphs.length;\n  var i;\n  for (i = 0; i < size; i++) {\n    graph = graphs[i];\n\n    graph.updateConnected();\n\n    if (!graph.isConnected) {\n      nodeList = nodeList.concat(graph.getNodes());\n    }\n  }\n\n  return nodeList;\n};\n\nCoSELayout.prototype.createBendpoints = function () {\n  var edges = [];\n  edges = edges.concat(this.graphManager.getAllEdges());\n  var visited = new Set();\n  var i;\n  for (i = 0; i < edges.length; i++) {\n    var edge = edges[i];\n\n    if (!visited.has(edge)) {\n      var source = edge.getSource();\n      var target = edge.getTarget();\n\n      if (source == target) {\n        edge.getBendpoints().push(new PointD());\n        edge.getBendpoints().push(new PointD());\n        this.createDummyNodesForBendpoints(edge);\n        visited.add(edge);\n      } else {\n        var edgeList = [];\n\n        edgeList = edgeList.concat(source.getEdgeListToNode(target));\n        edgeList = edgeList.concat(target.getEdgeListToNode(source));\n\n        if (!visited.has(edgeList[0])) {\n          if (edgeList.length > 1) {\n            var k;\n            for (k = 0; k < edgeList.length; k++) {\n              var multiEdge = edgeList[k];\n              multiEdge.getBendpoints().push(new PointD());\n              this.createDummyNodesForBendpoints(multiEdge);\n            }\n          }\n          edgeList.forEach(function (edge) {\n            visited.add(edge);\n          });\n        }\n      }\n    }\n\n    if (visited.size == edges.length) {\n      break;\n    }\n  }\n};\n\nCoSELayout.prototype.positionNodesRadially = function (forest) {\n  // We tile the trees to a grid row by row; first tree starts at (0,0)\n  var currentStartingPoint = new Point(0, 0);\n  var numberOfColumns = Math.ceil(Math.sqrt(forest.length));\n  var height = 0;\n  var currentY = 0;\n  var currentX = 0;\n  var point = new PointD(0, 0);\n\n  for (var i = 0; i < forest.length; i++) {\n    if (i % numberOfColumns == 0) {\n      // Start of a new row, make the x coordinate 0, increment the\n      // y coordinate with the max height of the previous row\n      currentX = 0;\n      currentY = height;\n\n      if (i != 0) {\n        currentY += CoSEConstants.DEFAULT_COMPONENT_SEPERATION;\n      }\n\n      height = 0;\n    }\n\n    var tree = forest[i];\n\n    // Find the center of the tree\n    var centerNode = Layout.findCenterOfTree(tree);\n\n    // Set the staring point of the next tree\n    currentStartingPoint.x = currentX;\n    currentStartingPoint.y = currentY;\n\n    // Do a radial layout starting with the center\n    point = CoSELayout.radialLayout(tree, centerNode, currentStartingPoint);\n\n    if (point.y > height) {\n      height = Math.floor(point.y);\n    }\n\n    currentX = Math.floor(point.x + CoSEConstants.DEFAULT_COMPONENT_SEPERATION);\n  }\n\n  this.transform(new PointD(LayoutConstants.WORLD_CENTER_X - point.x / 2, LayoutConstants.WORLD_CENTER_Y - point.y / 2));\n};\n\nCoSELayout.radialLayout = function (tree, centerNode, startingPoint) {\n  var radialSep = Math.max(this.maxDiagonalInTree(tree), CoSEConstants.DEFAULT_RADIAL_SEPARATION);\n  CoSELayout.branchRadialLayout(centerNode, null, 0, 359, 0, radialSep);\n  var bounds = LGraph.calculateBounds(tree);\n\n  var transform = new Transform();\n  transform.setDeviceOrgX(bounds.getMinX());\n  transform.setDeviceOrgY(bounds.getMinY());\n  transform.setWorldOrgX(startingPoint.x);\n  transform.setWorldOrgY(startingPoint.y);\n\n  for (var i = 0; i < tree.length; i++) {\n    var node = tree[i];\n    node.transform(transform);\n  }\n\n  var bottomRight = new PointD(bounds.getMaxX(), bounds.getMaxY());\n\n  return transform.inverseTransformPoint(bottomRight);\n};\n\nCoSELayout.branchRadialLayout = function (node, parentOfNode, startAngle, endAngle, distance, radialSeparation) {\n  // First, position this node by finding its angle.\n  var halfInterval = (endAngle - startAngle + 1) / 2;\n\n  if (halfInterval < 0) {\n    halfInterval += 180;\n  }\n\n  var nodeAngle = (halfInterval + startAngle) % 360;\n  var teta = nodeAngle * IGeometry.TWO_PI / 360;\n\n  // Make polar to java cordinate conversion.\n  var cos_teta = Math.cos(teta);\n  var x_ = distance * Math.cos(teta);\n  var y_ = distance * Math.sin(teta);\n\n  node.setCenter(x_, y_);\n\n  // Traverse all neighbors of this node and recursively call this\n  // function.\n  var neighborEdges = [];\n  neighborEdges = neighborEdges.concat(node.getEdges());\n  var childCount = neighborEdges.length;\n\n  if (parentOfNode != null) {\n    childCount--;\n  }\n\n  var branchCount = 0;\n\n  var incEdgesCount = neighborEdges.length;\n  var startIndex;\n\n  var edges = node.getEdgesBetween(parentOfNode);\n\n  // If there are multiple edges, prune them until there remains only one\n  // edge.\n  while (edges.length > 1) {\n    //neighborEdges.remove(edges.remove(0));\n    var temp = edges[0];\n    edges.splice(0, 1);\n    var index = neighborEdges.indexOf(temp);\n    if (index >= 0) {\n      neighborEdges.splice(index, 1);\n    }\n    incEdgesCount--;\n    childCount--;\n  }\n\n  if (parentOfNode != null) {\n    //assert edges.length == 1;\n    startIndex = (neighborEdges.indexOf(edges[0]) + 1) % incEdgesCount;\n  } else {\n    startIndex = 0;\n  }\n\n  var stepAngle = Math.abs(endAngle - startAngle) / childCount;\n\n  for (var i = startIndex; branchCount != childCount; i = ++i % incEdgesCount) {\n    var currentNeighbor = neighborEdges[i].getOtherEnd(node);\n\n    // Don't back traverse to root node in current tree.\n    if (currentNeighbor == parentOfNode) {\n      continue;\n    }\n\n    var childStartAngle = (startAngle + branchCount * stepAngle) % 360;\n    var childEndAngle = (childStartAngle + stepAngle) % 360;\n\n    CoSELayout.branchRadialLayout(currentNeighbor, node, childStartAngle, childEndAngle, distance + radialSeparation, radialSeparation);\n\n    branchCount++;\n  }\n};\n\nCoSELayout.maxDiagonalInTree = function (tree) {\n  var maxDiagonal = Integer.MIN_VALUE;\n\n  for (var i = 0; i < tree.length; i++) {\n    var node = tree[i];\n    var diagonal = node.getDiagonal();\n\n    if (diagonal > maxDiagonal) {\n      maxDiagonal = diagonal;\n    }\n  }\n\n  return maxDiagonal;\n};\n\nCoSELayout.prototype.calcRepulsionRange = function () {\n  // formula is 2 x (level + 1) x idealEdgeLength\n  return 2 * (this.level + 1) * this.idealEdgeLength;\n};\n\n// Tiling methods\n\n// Group zero degree members whose parents are not to be tiled, create dummy parents where needed and fill memberGroups by their dummp parent id's\nCoSELayout.prototype.groupZeroDegreeMembers = function () {\n  var self = this;\n  // array of [parent_id x oneDegreeNode_id]\n  var tempMemberGroups = {}; // A temporary map of parent node and its zero degree members\n  this.memberGroups = {}; // A map of dummy parent node and its zero degree members whose parents are not to be tiled\n  this.idToDummyNode = {}; // A map of id to dummy node \n\n  var zeroDegree = []; // List of zero degree nodes whose parents are not to be tiled\n  var allNodes = this.graphManager.getAllNodes();\n\n  // Fill zero degree list\n  for (var i = 0; i < allNodes.length; i++) {\n    var node = allNodes[i];\n    var parent = node.getParent();\n    // If a node has zero degree and its parent is not to be tiled if exists add that node to zeroDegres list\n    if (this.getNodeDegreeWithChildren(node) === 0 && (parent.id == undefined || !this.getToBeTiled(parent))) {\n      zeroDegree.push(node);\n    }\n  }\n\n  // Create a map of parent node and its zero degree members\n  for (var i = 0; i < zeroDegree.length; i++) {\n    var node = zeroDegree[i]; // Zero degree node itself\n    var p_id = node.getParent().id; // Parent id\n\n    if (typeof tempMemberGroups[p_id] === \"undefined\") tempMemberGroups[p_id] = [];\n\n    tempMemberGroups[p_id] = tempMemberGroups[p_id].concat(node); // Push node to the list belongs to its parent in tempMemberGroups\n  }\n\n  // If there are at least two nodes at a level, create a dummy compound for them\n  Object.keys(tempMemberGroups).forEach(function (p_id) {\n    if (tempMemberGroups[p_id].length > 1) {\n      var dummyCompoundId = \"DummyCompound_\" + p_id; // The id of dummy compound which will be created soon\n      self.memberGroups[dummyCompoundId] = tempMemberGroups[p_id]; // Add dummy compound to memberGroups\n\n      var parent = tempMemberGroups[p_id][0].getParent(); // The parent of zero degree nodes will be the parent of new dummy compound\n\n      // Create a dummy compound with calculated id\n      var dummyCompound = new CoSENode(self.graphManager);\n      dummyCompound.id = dummyCompoundId;\n      dummyCompound.paddingLeft = parent.paddingLeft || 0;\n      dummyCompound.paddingRight = parent.paddingRight || 0;\n      dummyCompound.paddingBottom = parent.paddingBottom || 0;\n      dummyCompound.paddingTop = parent.paddingTop || 0;\n\n      self.idToDummyNode[dummyCompoundId] = dummyCompound;\n\n      var dummyParentGraph = self.getGraphManager().add(self.newGraph(), dummyCompound);\n      var parentGraph = parent.getChild();\n\n      // Add dummy compound to parent the graph\n      parentGraph.add(dummyCompound);\n\n      // For each zero degree node in this level remove it from its parent graph and add it to the graph of dummy parent\n      for (var i = 0; i < tempMemberGroups[p_id].length; i++) {\n        var node = tempMemberGroups[p_id][i];\n\n        parentGraph.remove(node);\n        dummyParentGraph.add(node);\n      }\n    }\n  });\n};\n\nCoSELayout.prototype.clearCompounds = function () {\n  var childGraphMap = {};\n  var idToNode = {};\n\n  // Get compound ordering by finding the inner one first\n  this.performDFSOnCompounds();\n\n  for (var i = 0; i < this.compoundOrder.length; i++) {\n\n    idToNode[this.compoundOrder[i].id] = this.compoundOrder[i];\n    childGraphMap[this.compoundOrder[i].id] = [].concat(this.compoundOrder[i].getChild().getNodes());\n\n    // Remove children of compounds\n    this.graphManager.remove(this.compoundOrder[i].getChild());\n    this.compoundOrder[i].child = null;\n  }\n\n  this.graphManager.resetAllNodes();\n\n  // Tile the removed children\n  this.tileCompoundMembers(childGraphMap, idToNode);\n};\n\nCoSELayout.prototype.clearZeroDegreeMembers = function () {\n  var self = this;\n  var tiledZeroDegreePack = this.tiledZeroDegreePack = [];\n\n  Object.keys(this.memberGroups).forEach(function (id) {\n    var compoundNode = self.idToDummyNode[id]; // Get the dummy compound\n\n    tiledZeroDegreePack[id] = self.tileNodes(self.memberGroups[id], compoundNode.paddingLeft + compoundNode.paddingRight);\n\n    // Set the width and height of the dummy compound as calculated\n    compoundNode.rect.width = tiledZeroDegreePack[id].width;\n    compoundNode.rect.height = tiledZeroDegreePack[id].height;\n  });\n};\n\nCoSELayout.prototype.repopulateCompounds = function () {\n  for (var i = this.compoundOrder.length - 1; i >= 0; i--) {\n    var lCompoundNode = this.compoundOrder[i];\n    var id = lCompoundNode.id;\n    var horizontalMargin = lCompoundNode.paddingLeft;\n    var verticalMargin = lCompoundNode.paddingTop;\n\n    this.adjustLocations(this.tiledMemberPack[id], lCompoundNode.rect.x, lCompoundNode.rect.y, horizontalMargin, verticalMargin);\n  }\n};\n\nCoSELayout.prototype.repopulateZeroDegreeMembers = function () {\n  var self = this;\n  var tiledPack = this.tiledZeroDegreePack;\n\n  Object.keys(tiledPack).forEach(function (id) {\n    var compoundNode = self.idToDummyNode[id]; // Get the dummy compound by its id\n    var horizontalMargin = compoundNode.paddingLeft;\n    var verticalMargin = compoundNode.paddingTop;\n\n    // Adjust the positions of nodes wrt its compound\n    self.adjustLocations(tiledPack[id], compoundNode.rect.x, compoundNode.rect.y, horizontalMargin, verticalMargin);\n  });\n};\n\nCoSELayout.prototype.getToBeTiled = function (node) {\n  var id = node.id;\n  //firstly check the previous results\n  if (this.toBeTiled[id] != null) {\n    return this.toBeTiled[id];\n  }\n\n  //only compound nodes are to be tiled\n  var childGraph = node.getChild();\n  if (childGraph == null) {\n    this.toBeTiled[id] = false;\n    return false;\n  }\n\n  var children = childGraph.getNodes(); // Get the children nodes\n\n  //a compound node is not to be tiled if all of its compound children are not to be tiled\n  for (var i = 0; i < children.length; i++) {\n    var theChild = children[i];\n\n    if (this.getNodeDegree(theChild) > 0) {\n      this.toBeTiled[id] = false;\n      return false;\n    }\n\n    //pass the children not having the compound structure\n    if (theChild.getChild() == null) {\n      this.toBeTiled[theChild.id] = false;\n      continue;\n    }\n\n    if (!this.getToBeTiled(theChild)) {\n      this.toBeTiled[id] = false;\n      return false;\n    }\n  }\n  this.toBeTiled[id] = true;\n  return true;\n};\n\n// Get degree of a node depending of its edges and independent of its children\nCoSELayout.prototype.getNodeDegree = function (node) {\n  var id = node.id;\n  var edges = node.getEdges();\n  var degree = 0;\n\n  // For the edges connected\n  for (var i = 0; i < edges.length; i++) {\n    var edge = edges[i];\n    if (edge.getSource().id !== edge.getTarget().id) {\n      degree = degree + 1;\n    }\n  }\n  return degree;\n};\n\n// Get degree of a node with its children\nCoSELayout.prototype.getNodeDegreeWithChildren = function (node) {\n  var degree = this.getNodeDegree(node);\n  if (node.getChild() == null) {\n    return degree;\n  }\n  var children = node.getChild().getNodes();\n  for (var i = 0; i < children.length; i++) {\n    var child = children[i];\n    degree += this.getNodeDegreeWithChildren(child);\n  }\n  return degree;\n};\n\nCoSELayout.prototype.performDFSOnCompounds = function () {\n  this.compoundOrder = [];\n  this.fillCompexOrderByDFS(this.graphManager.getRoot().getNodes());\n};\n\nCoSELayout.prototype.fillCompexOrderByDFS = function (children) {\n  for (var i = 0; i < children.length; i++) {\n    var child = children[i];\n    if (child.getChild() != null) {\n      this.fillCompexOrderByDFS(child.getChild().getNodes());\n    }\n    if (this.getToBeTiled(child)) {\n      this.compoundOrder.push(child);\n    }\n  }\n};\n\n/**\n* This method places each zero degree member wrt given (x,y) coordinates (top left).\n*/\nCoSELayout.prototype.adjustLocations = function (organization, x, y, compoundHorizontalMargin, compoundVerticalMargin) {\n  x += compoundHorizontalMargin;\n  y += compoundVerticalMargin;\n\n  var left = x;\n\n  for (var i = 0; i < organization.rows.length; i++) {\n    var row = organization.rows[i];\n    x = left;\n    var maxHeight = 0;\n\n    for (var j = 0; j < row.length; j++) {\n      var lnode = row[j];\n\n      lnode.rect.x = x; // + lnode.rect.width / 2;\n      lnode.rect.y = y; // + lnode.rect.height / 2;\n\n      x += lnode.rect.width + organization.horizontalPadding;\n\n      if (lnode.rect.height > maxHeight) maxHeight = lnode.rect.height;\n    }\n\n    y += maxHeight + organization.verticalPadding;\n  }\n};\n\nCoSELayout.prototype.tileCompoundMembers = function (childGraphMap, idToNode) {\n  var self = this;\n  this.tiledMemberPack = [];\n\n  Object.keys(childGraphMap).forEach(function (id) {\n    // Get the compound node\n    var compoundNode = idToNode[id];\n\n    self.tiledMemberPack[id] = self.tileNodes(childGraphMap[id], compoundNode.paddingLeft + compoundNode.paddingRight);\n\n    compoundNode.rect.width = self.tiledMemberPack[id].width;\n    compoundNode.rect.height = self.tiledMemberPack[id].height;\n  });\n};\n\nCoSELayout.prototype.tileNodes = function (nodes, minWidth) {\n  var verticalPadding = CoSEConstants.TILING_PADDING_VERTICAL;\n  var horizontalPadding = CoSEConstants.TILING_PADDING_HORIZONTAL;\n  var organization = {\n    rows: [],\n    rowWidth: [],\n    rowHeight: [],\n    width: 0,\n    height: minWidth, // assume minHeight equals to minWidth\n    verticalPadding: verticalPadding,\n    horizontalPadding: horizontalPadding\n  };\n\n  // Sort the nodes in ascending order of their areas\n  nodes.sort(function (n1, n2) {\n    if (n1.rect.width * n1.rect.height > n2.rect.width * n2.rect.height) return -1;\n    if (n1.rect.width * n1.rect.height < n2.rect.width * n2.rect.height) return 1;\n    return 0;\n  });\n\n  // Create the organization -> tile members\n  for (var i = 0; i < nodes.length; i++) {\n    var lNode = nodes[i];\n\n    if (organization.rows.length == 0) {\n      this.insertNodeToRow(organization, lNode, 0, minWidth);\n    } else if (this.canAddHorizontal(organization, lNode.rect.width, lNode.rect.height)) {\n      this.insertNodeToRow(organization, lNode, this.getShortestRowIndex(organization), minWidth);\n    } else {\n      this.insertNodeToRow(organization, lNode, organization.rows.length, minWidth);\n    }\n\n    this.shiftToLastRow(organization);\n  }\n\n  return organization;\n};\n\nCoSELayout.prototype.insertNodeToRow = function (organization, node, rowIndex, minWidth) {\n  var minCompoundSize = minWidth;\n\n  // Add new row if needed\n  if (rowIndex == organization.rows.length) {\n    var secondDimension = [];\n\n    organization.rows.push(secondDimension);\n    organization.rowWidth.push(minCompoundSize);\n    organization.rowHeight.push(0);\n  }\n\n  // Update row width\n  var w = organization.rowWidth[rowIndex] + node.rect.width;\n\n  if (organization.rows[rowIndex].length > 0) {\n    w += organization.horizontalPadding;\n  }\n\n  organization.rowWidth[rowIndex] = w;\n  // Update compound width\n  if (organization.width < w) {\n    organization.width = w;\n  }\n\n  // Update height\n  var h = node.rect.height;\n  if (rowIndex > 0) h += organization.verticalPadding;\n\n  var extraHeight = 0;\n  if (h > organization.rowHeight[rowIndex]) {\n    extraHeight = organization.rowHeight[rowIndex];\n    organization.rowHeight[rowIndex] = h;\n    extraHeight = organization.rowHeight[rowIndex] - extraHeight;\n  }\n\n  organization.height += extraHeight;\n\n  // Insert node\n  organization.rows[rowIndex].push(node);\n};\n\n//Scans the rows of an organization and returns the one with the min width\nCoSELayout.prototype.getShortestRowIndex = function (organization) {\n  var r = -1;\n  var min = Number.MAX_VALUE;\n\n  for (var i = 0; i < organization.rows.length; i++) {\n    if (organization.rowWidth[i] < min) {\n      r = i;\n      min = organization.rowWidth[i];\n    }\n  }\n  return r;\n};\n\n//Scans the rows of an organization and returns the one with the max width\nCoSELayout.prototype.getLongestRowIndex = function (organization) {\n  var r = -1;\n  var max = Number.MIN_VALUE;\n\n  for (var i = 0; i < organization.rows.length; i++) {\n\n    if (organization.rowWidth[i] > max) {\n      r = i;\n      max = organization.rowWidth[i];\n    }\n  }\n\n  return r;\n};\n\n/**\n* This method checks whether adding extra width to the organization violates\n* the aspect ratio(1) or not.\n*/\nCoSELayout.prototype.canAddHorizontal = function (organization, extraWidth, extraHeight) {\n\n  var sri = this.getShortestRowIndex(organization);\n\n  if (sri < 0) {\n    return true;\n  }\n\n  var min = organization.rowWidth[sri];\n\n  if (min + organization.horizontalPadding + extraWidth <= organization.width) return true;\n\n  var hDiff = 0;\n\n  // Adding to an existing row\n  if (organization.rowHeight[sri] < extraHeight) {\n    if (sri > 0) hDiff = extraHeight + organization.verticalPadding - organization.rowHeight[sri];\n  }\n\n  var add_to_row_ratio;\n  if (organization.width - min >= extraWidth + organization.horizontalPadding) {\n    add_to_row_ratio = (organization.height + hDiff) / (min + extraWidth + organization.horizontalPadding);\n  } else {\n    add_to_row_ratio = (organization.height + hDiff) / organization.width;\n  }\n\n  // Adding a new row for this node\n  hDiff = extraHeight + organization.verticalPadding;\n  var add_new_row_ratio;\n  if (organization.width < extraWidth) {\n    add_new_row_ratio = (organization.height + hDiff) / extraWidth;\n  } else {\n    add_new_row_ratio = (organization.height + hDiff) / organization.width;\n  }\n\n  if (add_new_row_ratio < 1) add_new_row_ratio = 1 / add_new_row_ratio;\n\n  if (add_to_row_ratio < 1) add_to_row_ratio = 1 / add_to_row_ratio;\n\n  return add_to_row_ratio < add_new_row_ratio;\n};\n\n//If moving the last node from the longest row and adding it to the last\n//row makes the bounding box smaller, do it.\nCoSELayout.prototype.shiftToLastRow = function (organization) {\n  var longest = this.getLongestRowIndex(organization);\n  var last = organization.rowWidth.length - 1;\n  var row = organization.rows[longest];\n  var node = row[row.length - 1];\n\n  var diff = node.width + organization.horizontalPadding;\n\n  // Check if there is enough space on the last row\n  if (organization.width - organization.rowWidth[last] > diff && longest != last) {\n    // Remove the last element of the longest row\n    row.splice(-1, 1);\n\n    // Push it to the last row\n    organization.rows[last].push(node);\n\n    organization.rowWidth[longest] = organization.rowWidth[longest] - diff;\n    organization.rowWidth[last] = organization.rowWidth[last] + diff;\n    organization.width = organization.rowWidth[instance.getLongestRowIndex(organization)];\n\n    // Update heights of the organization\n    var maxHeight = Number.MIN_VALUE;\n    for (var i = 0; i < row.length; i++) {\n      if (row[i].height > maxHeight) maxHeight = row[i].height;\n    }\n    if (longest > 0) maxHeight += organization.verticalPadding;\n\n    var prevTotal = organization.rowHeight[longest] + organization.rowHeight[last];\n\n    organization.rowHeight[longest] = maxHeight;\n    if (organization.rowHeight[last] < node.height + organization.verticalPadding) organization.rowHeight[last] = node.height + organization.verticalPadding;\n\n    var finalTotal = organization.rowHeight[longest] + organization.rowHeight[last];\n    organization.height += finalTotal - prevTotal;\n\n    this.shiftToLastRow(organization);\n  }\n};\n\nCoSELayout.prototype.tilingPreLayout = function () {\n  if (CoSEConstants.TILE) {\n    // Find zero degree nodes and create a compound for each level\n    this.groupZeroDegreeMembers();\n    // Tile and clear children of each compound\n    this.clearCompounds();\n    // Separately tile and clear zero degree nodes for each level\n    this.clearZeroDegreeMembers();\n  }\n};\n\nCoSELayout.prototype.tilingPostLayout = function () {\n  if (CoSEConstants.TILE) {\n    this.repopulateZeroDegreeMembers();\n    this.repopulateCompounds();\n  }\n};\n\n// -----------------------------------------------------------------------------\n// Section: Tree Reduction methods\n// -----------------------------------------------------------------------------\n// Reduce trees \nCoSELayout.prototype.reduceTrees = function () {\n  var prunedNodesAll = [];\n  var containsLeaf = true;\n  var node;\n\n  while (containsLeaf) {\n    var allNodes = this.graphManager.getAllNodes();\n    var prunedNodesInStepTemp = [];\n    containsLeaf = false;\n\n    for (var i = 0; i < allNodes.length; i++) {\n      node = allNodes[i];\n      if (node.getEdges().length == 1 && !node.getEdges()[0].isInterGraph && node.getChild() == null) {\n        prunedNodesInStepTemp.push([node, node.getEdges()[0], node.getOwner()]);\n        containsLeaf = true;\n      }\n    }\n    if (containsLeaf == true) {\n      var prunedNodesInStep = [];\n      for (var j = 0; j < prunedNodesInStepTemp.length; j++) {\n        if (prunedNodesInStepTemp[j][0].getEdges().length == 1) {\n          prunedNodesInStep.push(prunedNodesInStepTemp[j]);\n          prunedNodesInStepTemp[j][0].getOwner().remove(prunedNodesInStepTemp[j][0]);\n        }\n      }\n      prunedNodesAll.push(prunedNodesInStep);\n      this.graphManager.resetAllNodes();\n      this.graphManager.resetAllEdges();\n    }\n  }\n  this.prunedNodesAll = prunedNodesAll;\n};\n\n// Grow tree one step \nCoSELayout.prototype.growTree = function (prunedNodesAll) {\n  var lengthOfPrunedNodesInStep = prunedNodesAll.length;\n  var prunedNodesInStep = prunedNodesAll[lengthOfPrunedNodesInStep - 1];\n\n  var nodeData;\n  for (var i = 0; i < prunedNodesInStep.length; i++) {\n    nodeData = prunedNodesInStep[i];\n\n    this.findPlaceforPrunedNode(nodeData);\n\n    nodeData[2].add(nodeData[0]);\n    nodeData[2].add(nodeData[1], nodeData[1].source, nodeData[1].target);\n  }\n\n  prunedNodesAll.splice(prunedNodesAll.length - 1, 1);\n  this.graphManager.resetAllNodes();\n  this.graphManager.resetAllEdges();\n};\n\n// Find an appropriate position to replace pruned node, this method can be improved\nCoSELayout.prototype.findPlaceforPrunedNode = function (nodeData) {\n\n  var gridForPrunedNode;\n  var nodeToConnect;\n  var prunedNode = nodeData[0];\n  if (prunedNode == nodeData[1].source) {\n    nodeToConnect = nodeData[1].target;\n  } else {\n    nodeToConnect = nodeData[1].source;\n  }\n  var startGridX = nodeToConnect.startX;\n  var finishGridX = nodeToConnect.finishX;\n  var startGridY = nodeToConnect.startY;\n  var finishGridY = nodeToConnect.finishY;\n\n  var upNodeCount = 0;\n  var downNodeCount = 0;\n  var rightNodeCount = 0;\n  var leftNodeCount = 0;\n  var controlRegions = [upNodeCount, rightNodeCount, downNodeCount, leftNodeCount];\n\n  if (startGridY > 0) {\n    for (var i = startGridX; i <= finishGridX; i++) {\n      controlRegions[0] += this.grid[i][startGridY - 1].length + this.grid[i][startGridY].length - 1;\n    }\n  }\n  if (finishGridX < this.grid.length - 1) {\n    for (var i = startGridY; i <= finishGridY; i++) {\n      controlRegions[1] += this.grid[finishGridX + 1][i].length + this.grid[finishGridX][i].length - 1;\n    }\n  }\n  if (finishGridY < this.grid[0].length - 1) {\n    for (var i = startGridX; i <= finishGridX; i++) {\n      controlRegions[2] += this.grid[i][finishGridY + 1].length + this.grid[i][finishGridY].length - 1;\n    }\n  }\n  if (startGridX > 0) {\n    for (var i = startGridY; i <= finishGridY; i++) {\n      controlRegions[3] += this.grid[startGridX - 1][i].length + this.grid[startGridX][i].length - 1;\n    }\n  }\n  var min = Integer.MAX_VALUE;\n  var minCount;\n  var minIndex;\n  for (var j = 0; j < controlRegions.length; j++) {\n    if (controlRegions[j] < min) {\n      min = controlRegions[j];\n      minCount = 1;\n      minIndex = j;\n    } else if (controlRegions[j] == min) {\n      minCount++;\n    }\n  }\n\n  if (minCount == 3 && min == 0) {\n    if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[2] == 0) {\n      gridForPrunedNode = 1;\n    } else if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[3] == 0) {\n      gridForPrunedNode = 0;\n    } else if (controlRegions[0] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) {\n      gridForPrunedNode = 3;\n    } else if (controlRegions[1] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) {\n      gridForPrunedNode = 2;\n    }\n  } else if (minCount == 2 && min == 0) {\n    var random = Math.floor(Math.random() * 2);\n    if (controlRegions[0] == 0 && controlRegions[1] == 0) {\n      ;\n      if (random == 0) {\n        gridForPrunedNode = 0;\n      } else {\n        gridForPrunedNode = 1;\n      }\n    } else if (controlRegions[0] == 0 && controlRegions[2] == 0) {\n      if (random == 0) {\n        gridForPrunedNode = 0;\n      } else {\n        gridForPrunedNode = 2;\n      }\n    } else if (controlRegions[0] == 0 && controlRegions[3] == 0) {\n      if (random == 0) {\n        gridForPrunedNode = 0;\n      } else {\n        gridForPrunedNode = 3;\n      }\n    } else if (controlRegions[1] == 0 && controlRegions[2] == 0) {\n      if (random == 0) {\n        gridForPrunedNode = 1;\n      } else {\n        gridForPrunedNode = 2;\n      }\n    } else if (controlRegions[1] == 0 && controlRegions[3] == 0) {\n      if (random == 0) {\n        gridForPrunedNode = 1;\n      } else {\n        gridForPrunedNode = 3;\n      }\n    } else {\n      if (random == 0) {\n        gridForPrunedNode = 2;\n      } else {\n        gridForPrunedNode = 3;\n      }\n    }\n  } else if (minCount == 4 && min == 0) {\n    var random = Math.floor(Math.random() * 4);\n    gridForPrunedNode = random;\n  } else {\n    gridForPrunedNode = minIndex;\n  }\n\n  if (gridForPrunedNode == 0) {\n    prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() - nodeToConnect.getHeight() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getHeight() / 2);\n  } else if (gridForPrunedNode == 1) {\n    prunedNode.setCenter(nodeToConnect.getCenterX() + nodeToConnect.getWidth() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getWidth() / 2, nodeToConnect.getCenterY());\n  } else if (gridForPrunedNode == 2) {\n    prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() + nodeToConnect.getHeight() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getHeight() / 2);\n  } else {\n    prunedNode.setCenter(nodeToConnect.getCenterX() - nodeToConnect.getWidth() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getWidth() / 2, nodeToConnect.getCenterY());\n  }\n};\n\nmodule.exports = CoSELayout;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar coseBase = {};\n\ncoseBase.layoutBase = __webpack_require__(0);\ncoseBase.CoSEConstants = __webpack_require__(1);\ncoseBase.CoSEEdge = __webpack_require__(2);\ncoseBase.CoSEGraph = __webpack_require__(3);\ncoseBase.CoSEGraphManager = __webpack_require__(4);\ncoseBase.CoSELayout = __webpack_require__(6);\ncoseBase.CoSENode = __webpack_require__(5);\n\nmodule.exports = coseBase;\n\n/***/ })\n/******/ ]);\n});"],"mappings":"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"},"metadata":{},"sourceType":"script"}