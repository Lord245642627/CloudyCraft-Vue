{"ast":null,"code":"var _config = require(\"./config\");\n\nvar devicePixelRatio = _config.devicePixelRatio;\n\nvar util = require(\"./core/util\");\n\nvar logError = require(\"./core/log\");\n\nvar BoundingRect = require(\"./core/BoundingRect\");\n\nvar timsort = require(\"./core/timsort\");\n\nvar Layer = require(\"./Layer\");\n\nvar requestAnimationFrame = require(\"./animation/requestAnimationFrame\");\n\nvar Image = require(\"./graphic/Image\");\n\nvar env = require(\"./core/env\");\n\nvar HOVER_LAYER_ZLEVEL = 1e5;\nvar CANVAS_ZLEVEL = 314159;\nvar EL_AFTER_INCREMENTAL_INC = 0.01;\nvar INCREMENTAL_INC = 0.001;\n\nfunction parseInt10(val) {\n  return parseInt(val, 10);\n}\n\nfunction isLayerValid(layer) {\n  if (!layer) {\n    return false;\n  }\n\n  if (layer.__builtin__) {\n    return true;\n  }\n\n  if (typeof layer.resize !== 'function' || typeof layer.refresh !== 'function') {\n    return false;\n  }\n\n  return true;\n}\n\nvar tmpRect = new BoundingRect(0, 0, 0, 0);\nvar viewRect = new BoundingRect(0, 0, 0, 0);\n\nfunction isDisplayableCulled(el, width, height) {\n  tmpRect.copy(el.getBoundingRect());\n\n  if (el.transform) {\n    tmpRect.applyTransform(el.transform);\n  }\n\n  viewRect.width = width;\n  viewRect.height = height;\n  return !tmpRect.intersect(viewRect);\n}\n\nfunction isClipPathChanged(clipPaths, prevClipPaths) {\n  // displayable.__clipPaths can only be `null`/`undefined` or an non-empty array.\n  if (clipPaths === prevClipPaths) {\n    return false;\n  }\n\n  if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {\n    return true;\n  }\n\n  for (var i = 0; i < clipPaths.length; i++) {\n    if (clipPaths[i] !== prevClipPaths[i]) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction doClip(clipPaths, ctx) {\n  for (var i = 0; i < clipPaths.length; i++) {\n    var clipPath = clipPaths[i];\n    clipPath.setTransform(ctx);\n    ctx.beginPath();\n    clipPath.buildPath(ctx, clipPath.shape);\n    ctx.clip(); // Transform back\n\n    clipPath.restoreTransform(ctx);\n  }\n}\n\nfunction createRoot(width, height) {\n  var domRoot = document.createElement('div'); // domRoot.onselectstart = returnFalse; // Avoid page selected\n\n  domRoot.style.cssText = ['position:relative', // IOS13 safari probably has a compositing bug (z order of the canvas and the consequent\n  // dom does not act as expected) when some of the parent dom has\n  // `-webkit-overflow-scrolling: touch;` and the webpage is longer than one screen and\n  // the canvas is not at the top part of the page.\n  // Check `https://bugs.webkit.org/show_bug.cgi?id=203681` for more details. We remove\n  // this `overflow:hidden` to avoid the bug.\n  // 'overflow:hidden',\n  'width:' + width + 'px', 'height:' + height + 'px', 'padding:0', 'margin:0', 'border-width:0'].join(';') + ';';\n  return domRoot;\n}\n/**\n * @alias module:zrender/Painter\n * @constructor\n * @param {HTMLElement} root 绘图容器\n * @param {module:zrender/Storage} storage\n * @param {Object} opts\n */\n\n\nvar Painter = function (root, storage, opts) {\n  this.type = 'canvas'; // In node environment using node-canvas\n\n  var singleCanvas = !root.nodeName // In node ?\n  || root.nodeName.toUpperCase() === 'CANVAS';\n  this._opts = opts = util.extend({}, opts || {});\n  /**\n   * @type {number}\n   */\n\n  this.dpr = opts.devicePixelRatio || devicePixelRatio;\n  /**\n   * @type {boolean}\n   * @private\n   */\n\n  this._singleCanvas = singleCanvas;\n  /**\n   * 绘图容器\n   * @type {HTMLElement}\n   */\n\n  this.root = root;\n  var rootStyle = root.style;\n\n  if (rootStyle) {\n    rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n    rootStyle['-webkit-user-select'] = rootStyle['user-select'] = rootStyle['-webkit-touch-callout'] = 'none';\n    root.innerHTML = '';\n  }\n  /**\n   * @type {module:zrender/Storage}\n   */\n\n\n  this.storage = storage;\n  /**\n   * @type {Array.<number>}\n   * @private\n   */\n\n  var zlevelList = this._zlevelList = [];\n  /**\n   * @type {Object.<string, module:zrender/Layer>}\n   * @private\n   */\n\n  var layers = this._layers = {};\n  /**\n   * @type {Object.<string, Object>}\n   * @private\n   */\n\n  this._layerConfig = {};\n  /**\n   * zrender will do compositing when root is a canvas and have multiple zlevels.\n   */\n\n  this._needsManuallyCompositing = false;\n\n  if (!singleCanvas) {\n    this._width = this._getSize(0);\n    this._height = this._getSize(1);\n    var domRoot = this._domRoot = createRoot(this._width, this._height);\n    root.appendChild(domRoot);\n  } else {\n    var width = root.width;\n    var height = root.height;\n\n    if (opts.width != null) {\n      width = opts.width;\n    }\n\n    if (opts.height != null) {\n      height = opts.height;\n    }\n\n    this.dpr = opts.devicePixelRatio || 1; // Use canvas width and height directly\n\n    root.width = width * this.dpr;\n    root.height = height * this.dpr;\n    this._width = width;\n    this._height = height; // Create layer if only one given canvas\n    // Device can be specified to create a high dpi image.\n\n    var mainLayer = new Layer(root, this, this.dpr);\n    mainLayer.__builtin__ = true;\n    mainLayer.initContext(); // FIXME Use canvas width and height\n    // mainLayer.resize(width, height);\n\n    layers[CANVAS_ZLEVEL] = mainLayer;\n    mainLayer.zlevel = CANVAS_ZLEVEL; // Not use common zlevel.\n\n    zlevelList.push(CANVAS_ZLEVEL);\n    this._domRoot = root;\n  }\n  /**\n   * @type {module:zrender/Layer}\n   * @private\n   */\n\n\n  this._hoverlayer = null;\n  this._hoverElements = [];\n};\n\nPainter.prototype = {\n  constructor: Painter,\n  getType: function () {\n    return 'canvas';\n  },\n\n  /**\n   * If painter use a single canvas\n   * @return {boolean}\n   */\n  isSingleCanvas: function () {\n    return this._singleCanvas;\n  },\n\n  /**\n   * @return {HTMLDivElement}\n   */\n  getViewportRoot: function () {\n    return this._domRoot;\n  },\n  getViewportRootOffset: function () {\n    var viewportRoot = this.getViewportRoot();\n\n    if (viewportRoot) {\n      return {\n        offsetLeft: viewportRoot.offsetLeft || 0,\n        offsetTop: viewportRoot.offsetTop || 0\n      };\n    }\n  },\n\n  /**\n   * 刷新\n   * @param {boolean} [paintAll=false] 强制绘制所有displayable\n   */\n  refresh: function (paintAll) {\n    var list = this.storage.getDisplayList(true);\n    var zlevelList = this._zlevelList;\n    this._redrawId = Math.random();\n\n    this._paintList(list, paintAll, this._redrawId); // Paint custum layers\n\n\n    for (var i = 0; i < zlevelList.length; i++) {\n      var z = zlevelList[i];\n      var layer = this._layers[z];\n\n      if (!layer.__builtin__ && layer.refresh) {\n        var clearColor = i === 0 ? this._backgroundColor : null;\n        layer.refresh(clearColor);\n      }\n    }\n\n    this.refreshHover();\n    return this;\n  },\n  addHover: function (el, hoverStyle) {\n    if (el.__hoverMir) {\n      return;\n    }\n\n    var elMirror = new el.constructor({\n      style: el.style,\n      shape: el.shape,\n      z: el.z,\n      z2: el.z2,\n      silent: el.silent\n    });\n    elMirror.__from = el;\n    el.__hoverMir = elMirror;\n    hoverStyle && elMirror.setStyle(hoverStyle);\n\n    this._hoverElements.push(elMirror);\n\n    return elMirror;\n  },\n  removeHover: function (el) {\n    var elMirror = el.__hoverMir;\n    var hoverElements = this._hoverElements;\n    var idx = util.indexOf(hoverElements, elMirror);\n\n    if (idx >= 0) {\n      hoverElements.splice(idx, 1);\n    }\n\n    el.__hoverMir = null;\n  },\n  clearHover: function (el) {\n    var hoverElements = this._hoverElements;\n\n    for (var i = 0; i < hoverElements.length; i++) {\n      var from = hoverElements[i].__from;\n\n      if (from) {\n        from.__hoverMir = null;\n      }\n    }\n\n    hoverElements.length = 0;\n  },\n  refreshHover: function () {\n    var hoverElements = this._hoverElements;\n    var len = hoverElements.length;\n    var hoverLayer = this._hoverlayer;\n    hoverLayer && hoverLayer.clear();\n\n    if (!len) {\n      return;\n    }\n\n    timsort(hoverElements, this.storage.displayableSortFunc); // Use a extream large zlevel\n    // FIXME?\n\n    if (!hoverLayer) {\n      hoverLayer = this._hoverlayer = this.getLayer(HOVER_LAYER_ZLEVEL);\n    }\n\n    var scope = {};\n    hoverLayer.ctx.save();\n\n    for (var i = 0; i < len;) {\n      var el = hoverElements[i];\n      var originalEl = el.__from; // Original el is removed\n      // PENDING\n\n      if (!(originalEl && originalEl.__zr)) {\n        hoverElements.splice(i, 1);\n        originalEl.__hoverMir = null;\n        len--;\n        continue;\n      }\n\n      i++; // Use transform\n      // FIXME style and shape ?\n\n      if (!originalEl.invisible) {\n        el.transform = originalEl.transform;\n        el.invTransform = originalEl.invTransform;\n        el.__clipPaths = originalEl.__clipPaths; // el.\n\n        this._doPaintEl(el, hoverLayer, true, scope);\n      }\n    }\n\n    hoverLayer.ctx.restore();\n  },\n  getHoverLayer: function () {\n    return this.getLayer(HOVER_LAYER_ZLEVEL);\n  },\n  _paintList: function (list, paintAll, redrawId) {\n    if (this._redrawId !== redrawId) {\n      return;\n    }\n\n    paintAll = paintAll || false;\n\n    this._updateLayerStatus(list);\n\n    var finished = this._doPaintList(list, paintAll);\n\n    if (this._needsManuallyCompositing) {\n      this._compositeManually();\n    }\n\n    if (!finished) {\n      var self = this;\n      requestAnimationFrame(function () {\n        self._paintList(list, paintAll, redrawId);\n      });\n    }\n  },\n  _compositeManually: function () {\n    var ctx = this.getLayer(CANVAS_ZLEVEL).ctx;\n    var width = this._domRoot.width;\n    var height = this._domRoot.height;\n    ctx.clearRect(0, 0, width, height); // PENDING, If only builtin layer?\n\n    this.eachBuiltinLayer(function (layer) {\n      if (layer.virtual) {\n        ctx.drawImage(layer.dom, 0, 0, width, height);\n      }\n    });\n  },\n  _doPaintList: function (list, paintAll) {\n    var layerList = [];\n\n    for (var zi = 0; zi < this._zlevelList.length; zi++) {\n      var zlevel = this._zlevelList[zi];\n      var layer = this._layers[zlevel];\n\n      if (layer.__builtin__ && layer !== this._hoverlayer && (layer.__dirty || paintAll)) {\n        layerList.push(layer);\n      }\n    }\n\n    var finished = true;\n\n    for (var k = 0; k < layerList.length; k++) {\n      var layer = layerList[k];\n      var ctx = layer.ctx;\n      var scope = {};\n      ctx.save();\n      var start = paintAll ? layer.__startIndex : layer.__drawIndex;\n      var useTimer = !paintAll && layer.incremental && Date.now;\n      var startTime = useTimer && Date.now();\n      var clearColor = layer.zlevel === this._zlevelList[0] ? this._backgroundColor : null; // All elements in this layer are cleared.\n\n      if (layer.__startIndex === layer.__endIndex) {\n        layer.clear(false, clearColor);\n      } else if (start === layer.__startIndex) {\n        var firstEl = list[start];\n\n        if (!firstEl.incremental || !firstEl.notClear || paintAll) {\n          layer.clear(false, clearColor);\n        }\n      }\n\n      if (start === -1) {\n        console.error('For some unknown reason. drawIndex is -1');\n        start = layer.__startIndex;\n      }\n\n      for (var i = start; i < layer.__endIndex; i++) {\n        var el = list[i];\n\n        this._doPaintEl(el, layer, paintAll, scope);\n\n        el.__dirty = el.__dirtyText = false;\n\n        if (useTimer) {\n          // Date.now can be executed in 13,025,305 ops/second.\n          var dTime = Date.now() - startTime; // Give 15 millisecond to draw.\n          // The rest elements will be drawn in the next frame.\n\n          if (dTime > 15) {\n            break;\n          }\n        }\n      }\n\n      layer.__drawIndex = i;\n\n      if (layer.__drawIndex < layer.__endIndex) {\n        finished = false;\n      }\n\n      if (scope.prevElClipPaths) {\n        // Needs restore the state. If last drawn element is in the clipping area.\n        ctx.restore();\n      }\n\n      ctx.restore();\n    }\n\n    if (env.wxa) {\n      // Flush for weixin application\n      util.each(this._layers, function (layer) {\n        if (layer && layer.ctx && layer.ctx.draw) {\n          layer.ctx.draw();\n        }\n      });\n    }\n\n    return finished;\n  },\n  _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n    var ctx = currentLayer.ctx;\n    var m = el.transform;\n\n    if ((currentLayer.__dirty || forcePaint) && // Ignore invisible element\n    !el.invisible // Ignore transparent element\n    && el.style.opacity !== 0 // Ignore scale 0 element, in some environment like node-canvas\n    // Draw a scale 0 element can cause all following draw wrong\n    // And setTransform with scale 0 will cause set back transform failed.\n    && !(m && !m[0] && !m[3]) // Ignore culled element\n    && !(el.culling && isDisplayableCulled(el, this._width, this._height))) {\n      var clipPaths = el.__clipPaths;\n      var prevElClipPaths = scope.prevElClipPaths; // Optimize when clipping on group with several elements\n\n      if (!prevElClipPaths || isClipPathChanged(clipPaths, prevElClipPaths)) {\n        // If has previous clipping state, restore from it\n        if (prevElClipPaths) {\n          ctx.restore();\n          scope.prevElClipPaths = null; // Reset prevEl since context has been restored\n\n          scope.prevEl = null;\n        } // New clipping state\n\n\n        if (clipPaths) {\n          ctx.save();\n          doClip(clipPaths, ctx);\n          scope.prevElClipPaths = clipPaths;\n        }\n      }\n\n      el.beforeBrush && el.beforeBrush(ctx);\n      el.brush(ctx, scope.prevEl || null);\n      scope.prevEl = el;\n      el.afterBrush && el.afterBrush(ctx);\n    }\n  },\n\n  /**\n   * 获取 zlevel 所在层，如果不存在则会创建一个新的层\n   * @param {number} zlevel\n   * @param {boolean} virtual Virtual layer will not be inserted into dom.\n   * @return {module:zrender/Layer}\n   */\n  getLayer: function (zlevel, virtual) {\n    if (this._singleCanvas && !this._needsManuallyCompositing) {\n      zlevel = CANVAS_ZLEVEL;\n    }\n\n    var layer = this._layers[zlevel];\n\n    if (!layer) {\n      // Create a new layer\n      layer = new Layer('zr_' + zlevel, this, this.dpr);\n      layer.zlevel = zlevel;\n      layer.__builtin__ = true;\n\n      if (this._layerConfig[zlevel]) {\n        util.merge(layer, this._layerConfig[zlevel], true);\n      } // TODO Remove EL_AFTER_INCREMENTAL_INC magic number\n      else if (this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC]) {\n        util.merge(layer, this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC], true);\n      }\n\n      if (virtual) {\n        layer.virtual = virtual;\n      }\n\n      this.insertLayer(zlevel, layer); // Context is created after dom inserted to document\n      // Or excanvas will get 0px clientWidth and clientHeight\n\n      layer.initContext();\n    }\n\n    return layer;\n  },\n  insertLayer: function (zlevel, layer) {\n    var layersMap = this._layers;\n    var zlevelList = this._zlevelList;\n    var len = zlevelList.length;\n    var prevLayer = null;\n    var i = -1;\n    var domRoot = this._domRoot;\n\n    if (layersMap[zlevel]) {\n      logError('ZLevel ' + zlevel + ' has been used already');\n      return;\n    } // Check if is a valid layer\n\n\n    if (!isLayerValid(layer)) {\n      logError('Layer of zlevel ' + zlevel + ' is not valid');\n      return;\n    }\n\n    if (len > 0 && zlevel > zlevelList[0]) {\n      for (i = 0; i < len - 1; i++) {\n        if (zlevelList[i] < zlevel && zlevelList[i + 1] > zlevel) {\n          break;\n        }\n      }\n\n      prevLayer = layersMap[zlevelList[i]];\n    }\n\n    zlevelList.splice(i + 1, 0, zlevel);\n    layersMap[zlevel] = layer; // Vitual layer will not directly show on the screen.\n    // (It can be a WebGL layer and assigned to a ZImage element)\n    // But it still under management of zrender.\n\n    if (!layer.virtual) {\n      if (prevLayer) {\n        var prevDom = prevLayer.dom;\n\n        if (prevDom.nextSibling) {\n          domRoot.insertBefore(layer.dom, prevDom.nextSibling);\n        } else {\n          domRoot.appendChild(layer.dom);\n        }\n      } else {\n        if (domRoot.firstChild) {\n          domRoot.insertBefore(layer.dom, domRoot.firstChild);\n        } else {\n          domRoot.appendChild(layer.dom);\n        }\n      }\n    }\n  },\n  // Iterate each layer\n  eachLayer: function (cb, context) {\n    var zlevelList = this._zlevelList;\n    var z;\n    var i;\n\n    for (i = 0; i < zlevelList.length; i++) {\n      z = zlevelList[i];\n      cb.call(context, this._layers[z], z);\n    }\n  },\n  // Iterate each buildin layer\n  eachBuiltinLayer: function (cb, context) {\n    var zlevelList = this._zlevelList;\n    var layer;\n    var z;\n    var i;\n\n    for (i = 0; i < zlevelList.length; i++) {\n      z = zlevelList[i];\n      layer = this._layers[z];\n\n      if (layer.__builtin__) {\n        cb.call(context, layer, z);\n      }\n    }\n  },\n  // Iterate each other layer except buildin layer\n  eachOtherLayer: function (cb, context) {\n    var zlevelList = this._zlevelList;\n    var layer;\n    var z;\n    var i;\n\n    for (i = 0; i < zlevelList.length; i++) {\n      z = zlevelList[i];\n      layer = this._layers[z];\n\n      if (!layer.__builtin__) {\n        cb.call(context, layer, z);\n      }\n    }\n  },\n\n  /**\n   * 获取所有已创建的层\n   * @param {Array.<module:zrender/Layer>} [prevLayer]\n   */\n  getLayers: function () {\n    return this._layers;\n  },\n  _updateLayerStatus: function (list) {\n    this.eachBuiltinLayer(function (layer, z) {\n      layer.__dirty = layer.__used = false;\n    });\n\n    function updatePrevLayer(idx) {\n      if (prevLayer) {\n        if (prevLayer.__endIndex !== idx) {\n          prevLayer.__dirty = true;\n        }\n\n        prevLayer.__endIndex = idx;\n      }\n    }\n\n    if (this._singleCanvas) {\n      for (var i = 1; i < list.length; i++) {\n        var el = list[i];\n\n        if (el.zlevel !== list[i - 1].zlevel || el.incremental) {\n          this._needsManuallyCompositing = true;\n          break;\n        }\n      }\n    }\n\n    var prevLayer = null;\n    var incrementalLayerCount = 0;\n    var prevZlevel;\n\n    for (var i = 0; i < list.length; i++) {\n      var el = list[i];\n      var zlevel = el.zlevel;\n      var layer;\n\n      if (prevZlevel !== zlevel) {\n        prevZlevel = zlevel;\n        incrementalLayerCount = 0;\n      } // TODO Not use magic number on zlevel.\n      // Each layer with increment element can be separated to 3 layers.\n      //          (Other Element drawn after incremental element)\n      // -----------------zlevel + EL_AFTER_INCREMENTAL_INC--------------------\n      //                      (Incremental element)\n      // ----------------------zlevel + INCREMENTAL_INC------------------------\n      //              (Element drawn before incremental element)\n      // --------------------------------zlevel--------------------------------\n\n\n      if (el.incremental) {\n        layer = this.getLayer(zlevel + INCREMENTAL_INC, this._needsManuallyCompositing);\n        layer.incremental = true;\n        incrementalLayerCount = 1;\n      } else {\n        layer = this.getLayer(zlevel + (incrementalLayerCount > 0 ? EL_AFTER_INCREMENTAL_INC : 0), this._needsManuallyCompositing);\n      }\n\n      if (!layer.__builtin__) {\n        logError('ZLevel ' + zlevel + ' has been used by unkown layer ' + layer.id);\n      }\n\n      if (layer !== prevLayer) {\n        layer.__used = true;\n\n        if (layer.__startIndex !== i) {\n          layer.__dirty = true;\n        }\n\n        layer.__startIndex = i;\n\n        if (!layer.incremental) {\n          layer.__drawIndex = i;\n        } else {\n          // Mark layer draw index needs to update.\n          layer.__drawIndex = -1;\n        }\n\n        updatePrevLayer(i);\n        prevLayer = layer;\n      }\n\n      if (el.__dirty) {\n        layer.__dirty = true;\n\n        if (layer.incremental && layer.__drawIndex < 0) {\n          // Start draw from the first dirty element.\n          layer.__drawIndex = i;\n        }\n      }\n    }\n\n    updatePrevLayer(i);\n    this.eachBuiltinLayer(function (layer, z) {\n      // Used in last frame but not in this frame. Needs clear\n      if (!layer.__used && layer.getElementCount() > 0) {\n        layer.__dirty = true;\n        layer.__startIndex = layer.__endIndex = layer.__drawIndex = 0;\n      } // For incremental layer. In case start index changed and no elements are dirty.\n\n\n      if (layer.__dirty && layer.__drawIndex < 0) {\n        layer.__drawIndex = layer.__startIndex;\n      }\n    });\n  },\n\n  /**\n   * 清除hover层外所有内容\n   */\n  clear: function () {\n    this.eachBuiltinLayer(this._clearLayer);\n    return this;\n  },\n  _clearLayer: function (layer) {\n    layer.clear();\n  },\n  setBackgroundColor: function (backgroundColor) {\n    this._backgroundColor = backgroundColor;\n  },\n\n  /**\n   * 修改指定zlevel的绘制参数\n   *\n   * @param {string} zlevel\n   * @param {Object} config 配置对象\n   * @param {string} [config.clearColor=0] 每次清空画布的颜色\n   * @param {string} [config.motionBlur=false] 是否开启动态模糊\n   * @param {number} [config.lastFrameAlpha=0.7]\n   *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n   */\n  configLayer: function (zlevel, config) {\n    if (config) {\n      var layerConfig = this._layerConfig;\n\n      if (!layerConfig[zlevel]) {\n        layerConfig[zlevel] = config;\n      } else {\n        util.merge(layerConfig[zlevel], config, true);\n      }\n\n      for (var i = 0; i < this._zlevelList.length; i++) {\n        var _zlevel = this._zlevelList[i]; // TODO Remove EL_AFTER_INCREMENTAL_INC magic number\n\n        if (_zlevel === zlevel || _zlevel === zlevel + EL_AFTER_INCREMENTAL_INC) {\n          var layer = this._layers[_zlevel];\n          util.merge(layer, layerConfig[zlevel], true);\n        }\n      }\n    }\n  },\n\n  /**\n   * 删除指定层\n   * @param {number} zlevel 层所在的zlevel\n   */\n  delLayer: function (zlevel) {\n    var layers = this._layers;\n    var zlevelList = this._zlevelList;\n    var layer = layers[zlevel];\n\n    if (!layer) {\n      return;\n    }\n\n    layer.dom.parentNode.removeChild(layer.dom);\n    delete layers[zlevel];\n    zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n  },\n\n  /**\n   * 区域大小变化后重绘\n   */\n  resize: function (width, height) {\n    if (!this._domRoot.style) {\n      // Maybe in node or worker\n      if (width == null || height == null) {\n        return;\n      }\n\n      this._width = width;\n      this._height = height;\n      this.getLayer(CANVAS_ZLEVEL).resize(width, height);\n    } else {\n      var domRoot = this._domRoot; // FIXME Why ?\n\n      domRoot.style.display = 'none'; // Save input w/h\n\n      var opts = this._opts;\n      width != null && (opts.width = width);\n      height != null && (opts.height = height);\n      width = this._getSize(0);\n      height = this._getSize(1);\n      domRoot.style.display = ''; // 优化没有实际改变的resize\n\n      if (this._width !== width || height !== this._height) {\n        domRoot.style.width = width + 'px';\n        domRoot.style.height = height + 'px';\n\n        for (var id in this._layers) {\n          if (this._layers.hasOwnProperty(id)) {\n            this._layers[id].resize(width, height);\n          }\n        }\n\n        util.each(this._progressiveLayers, function (layer) {\n          layer.resize(width, height);\n        });\n        this.refresh(true);\n      }\n\n      this._width = width;\n      this._height = height;\n    }\n\n    return this;\n  },\n\n  /**\n   * 清除单独的一个层\n   * @param {number} zlevel\n   */\n  clearLayer: function (zlevel) {\n    var layer = this._layers[zlevel];\n\n    if (layer) {\n      layer.clear();\n    }\n  },\n\n  /**\n   * 释放\n   */\n  dispose: function () {\n    this.root.innerHTML = '';\n    this.root = this.storage = this._domRoot = this._layers = null;\n  },\n\n  /**\n   * Get canvas which has all thing rendered\n   * @param {Object} opts\n   * @param {string} [opts.backgroundColor]\n   * @param {number} [opts.pixelRatio]\n   */\n  getRenderedCanvas: function (opts) {\n    opts = opts || {};\n\n    if (this._singleCanvas && !this._compositeManually) {\n      return this._layers[CANVAS_ZLEVEL].dom;\n    }\n\n    var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n    imageLayer.initContext();\n    imageLayer.clear(false, opts.backgroundColor || this._backgroundColor);\n\n    if (opts.pixelRatio <= this.dpr) {\n      this.refresh();\n      var width = imageLayer.dom.width;\n      var height = imageLayer.dom.height;\n      var ctx = imageLayer.ctx;\n      this.eachLayer(function (layer) {\n        if (layer.__builtin__) {\n          ctx.drawImage(layer.dom, 0, 0, width, height);\n        } else if (layer.renderToCanvas) {\n          imageLayer.ctx.save();\n          layer.renderToCanvas(imageLayer.ctx);\n          imageLayer.ctx.restore();\n        }\n      });\n    } else {\n      // PENDING, echarts-gl and incremental rendering.\n      var scope = {};\n      var displayList = this.storage.getDisplayList(true);\n\n      for (var i = 0; i < displayList.length; i++) {\n        var el = displayList[i];\n\n        this._doPaintEl(el, imageLayer, true, scope);\n      }\n    }\n\n    return imageLayer.dom;\n  },\n\n  /**\n   * 获取绘图区域宽度\n   */\n  getWidth: function () {\n    return this._width;\n  },\n\n  /**\n   * 获取绘图区域高度\n   */\n  getHeight: function () {\n    return this._height;\n  },\n  _getSize: function (whIdx) {\n    var opts = this._opts;\n    var wh = ['width', 'height'][whIdx];\n    var cwh = ['clientWidth', 'clientHeight'][whIdx];\n    var plt = ['paddingLeft', 'paddingTop'][whIdx];\n    var prb = ['paddingRight', 'paddingBottom'][whIdx];\n\n    if (opts[wh] != null && opts[wh] !== 'auto') {\n      return parseFloat(opts[wh]);\n    }\n\n    var root = this.root; // IE8 does not support getComputedStyle, but it use VML.\n\n    var stl = document.defaultView.getComputedStyle(root);\n    return (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;\n  },\n  pathToImage: function (path, dpr) {\n    dpr = dpr || this.dpr;\n    var canvas = document.createElement('canvas');\n    var ctx = canvas.getContext('2d');\n    var rect = path.getBoundingRect();\n    var style = path.style;\n    var shadowBlurSize = style.shadowBlur * dpr;\n    var shadowOffsetX = style.shadowOffsetX * dpr;\n    var shadowOffsetY = style.shadowOffsetY * dpr;\n    var lineWidth = style.hasStroke() ? style.lineWidth : 0;\n    var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);\n    var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);\n    var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);\n    var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);\n    var width = rect.width + leftMargin + rightMargin;\n    var height = rect.height + topMargin + bottomMargin;\n    canvas.width = width * dpr;\n    canvas.height = height * dpr;\n    ctx.scale(dpr, dpr);\n    ctx.clearRect(0, 0, width, height);\n    ctx.dpr = dpr;\n    var pathTransform = {\n      position: path.position,\n      rotation: path.rotation,\n      scale: path.scale\n    };\n    path.position = [leftMargin - rect.x, topMargin - rect.y];\n    path.rotation = 0;\n    path.scale = [1, 1];\n    path.updateTransform();\n\n    if (path) {\n      path.brush(ctx);\n    }\n\n    var ImageShape = Image;\n    var imgShape = new ImageShape({\n      style: {\n        x: 0,\n        y: 0,\n        image: canvas\n      }\n    });\n\n    if (pathTransform.position != null) {\n      imgShape.position = path.position = pathTransform.position;\n    }\n\n    if (pathTransform.rotation != null) {\n      imgShape.rotation = path.rotation = pathTransform.rotation;\n    }\n\n    if (pathTransform.scale != null) {\n      imgShape.scale = path.scale = pathTransform.scale;\n    }\n\n    return imgShape;\n  }\n};\nvar _default = Painter;\nmodule.exports = _default;","map":{"version":3,"names":["_config","require","devicePixelRatio","util","logError","BoundingRect","timsort","Layer","requestAnimationFrame","Image","env","HOVER_LAYER_ZLEVEL","CANVAS_ZLEVEL","EL_AFTER_INCREMENTAL_INC","INCREMENTAL_INC","parseInt10","val","parseInt","isLayerValid","layer","__builtin__","resize","refresh","tmpRect","viewRect","isDisplayableCulled","el","width","height","copy","getBoundingRect","transform","applyTransform","intersect","isClipPathChanged","clipPaths","prevClipPaths","length","i","doClip","ctx","clipPath","setTransform","beginPath","buildPath","shape","clip","restoreTransform","createRoot","domRoot","document","createElement","style","cssText","join","Painter","root","storage","opts","type","singleCanvas","nodeName","toUpperCase","_opts","extend","dpr","_singleCanvas","rootStyle","innerHTML","zlevelList","_zlevelList","layers","_layers","_layerConfig","_needsManuallyCompositing","_width","_getSize","_height","_domRoot","appendChild","mainLayer","initContext","zlevel","push","_hoverlayer","_hoverElements","prototype","constructor","getType","isSingleCanvas","getViewportRoot","getViewportRootOffset","viewportRoot","offsetLeft","offsetTop","paintAll","list","getDisplayList","_redrawId","Math","random","_paintList","z","clearColor","_backgroundColor","refreshHover","addHover","hoverStyle","__hoverMir","elMirror","z2","silent","__from","setStyle","removeHover","hoverElements","idx","indexOf","splice","clearHover","from","len","hoverLayer","clear","displayableSortFunc","getLayer","scope","save","originalEl","__zr","invisible","invTransform","__clipPaths","_doPaintEl","restore","getHoverLayer","redrawId","_updateLayerStatus","finished","_doPaintList","_compositeManually","self","clearRect","eachBuiltinLayer","virtual","drawImage","dom","layerList","zi","__dirty","k","start","__startIndex","__drawIndex","useTimer","incremental","Date","now","startTime","__endIndex","firstEl","notClear","console","error","__dirtyText","dTime","prevElClipPaths","wxa","each","draw","currentLayer","forcePaint","m","opacity","culling","prevEl","beforeBrush","brush","afterBrush","merge","insertLayer","layersMap","prevLayer","prevDom","nextSibling","insertBefore","firstChild","eachLayer","cb","context","call","eachOtherLayer","getLayers","__used","updatePrevLayer","incrementalLayerCount","prevZlevel","id","getElementCount","_clearLayer","setBackgroundColor","backgroundColor","configLayer","config","layerConfig","_zlevel","delLayer","parentNode","removeChild","display","hasOwnProperty","_progressiveLayers","clearLayer","dispose","getRenderedCanvas","imageLayer","pixelRatio","renderToCanvas","displayList","getWidth","getHeight","whIdx","wh","cwh","plt","prb","parseFloat","stl","defaultView","getComputedStyle","pathToImage","path","canvas","getContext","rect","shadowBlurSize","shadowBlur","shadowOffsetX","shadowOffsetY","lineWidth","hasStroke","leftMargin","max","rightMargin","topMargin","bottomMargin","scale","pathTransform","position","rotation","x","y","updateTransform","ImageShape","imgShape","image","_default","module","exports"],"sources":["/Users/lord/Documents/Programmer/vue/VueProjects/blog-vue/blog-admin/node_modules/zrender/lib/Painter.js"],"sourcesContent":["var _config = require(\"./config\");\n\nvar devicePixelRatio = _config.devicePixelRatio;\n\nvar util = require(\"./core/util\");\n\nvar logError = require(\"./core/log\");\n\nvar BoundingRect = require(\"./core/BoundingRect\");\n\nvar timsort = require(\"./core/timsort\");\n\nvar Layer = require(\"./Layer\");\n\nvar requestAnimationFrame = require(\"./animation/requestAnimationFrame\");\n\nvar Image = require(\"./graphic/Image\");\n\nvar env = require(\"./core/env\");\n\nvar HOVER_LAYER_ZLEVEL = 1e5;\nvar CANVAS_ZLEVEL = 314159;\nvar EL_AFTER_INCREMENTAL_INC = 0.01;\nvar INCREMENTAL_INC = 0.001;\n\nfunction parseInt10(val) {\n  return parseInt(val, 10);\n}\n\nfunction isLayerValid(layer) {\n  if (!layer) {\n    return false;\n  }\n\n  if (layer.__builtin__) {\n    return true;\n  }\n\n  if (typeof layer.resize !== 'function' || typeof layer.refresh !== 'function') {\n    return false;\n  }\n\n  return true;\n}\n\nvar tmpRect = new BoundingRect(0, 0, 0, 0);\nvar viewRect = new BoundingRect(0, 0, 0, 0);\n\nfunction isDisplayableCulled(el, width, height) {\n  tmpRect.copy(el.getBoundingRect());\n\n  if (el.transform) {\n    tmpRect.applyTransform(el.transform);\n  }\n\n  viewRect.width = width;\n  viewRect.height = height;\n  return !tmpRect.intersect(viewRect);\n}\n\nfunction isClipPathChanged(clipPaths, prevClipPaths) {\n  // displayable.__clipPaths can only be `null`/`undefined` or an non-empty array.\n  if (clipPaths === prevClipPaths) {\n    return false;\n  }\n\n  if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {\n    return true;\n  }\n\n  for (var i = 0; i < clipPaths.length; i++) {\n    if (clipPaths[i] !== prevClipPaths[i]) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction doClip(clipPaths, ctx) {\n  for (var i = 0; i < clipPaths.length; i++) {\n    var clipPath = clipPaths[i];\n    clipPath.setTransform(ctx);\n    ctx.beginPath();\n    clipPath.buildPath(ctx, clipPath.shape);\n    ctx.clip(); // Transform back\n\n    clipPath.restoreTransform(ctx);\n  }\n}\n\nfunction createRoot(width, height) {\n  var domRoot = document.createElement('div'); // domRoot.onselectstart = returnFalse; // Avoid page selected\n\n  domRoot.style.cssText = ['position:relative', // IOS13 safari probably has a compositing bug (z order of the canvas and the consequent\n  // dom does not act as expected) when some of the parent dom has\n  // `-webkit-overflow-scrolling: touch;` and the webpage is longer than one screen and\n  // the canvas is not at the top part of the page.\n  // Check `https://bugs.webkit.org/show_bug.cgi?id=203681` for more details. We remove\n  // this `overflow:hidden` to avoid the bug.\n  // 'overflow:hidden',\n  'width:' + width + 'px', 'height:' + height + 'px', 'padding:0', 'margin:0', 'border-width:0'].join(';') + ';';\n  return domRoot;\n}\n/**\n * @alias module:zrender/Painter\n * @constructor\n * @param {HTMLElement} root 绘图容器\n * @param {module:zrender/Storage} storage\n * @param {Object} opts\n */\n\n\nvar Painter = function (root, storage, opts) {\n  this.type = 'canvas'; // In node environment using node-canvas\n\n  var singleCanvas = !root.nodeName // In node ?\n  || root.nodeName.toUpperCase() === 'CANVAS';\n  this._opts = opts = util.extend({}, opts || {});\n  /**\n   * @type {number}\n   */\n\n  this.dpr = opts.devicePixelRatio || devicePixelRatio;\n  /**\n   * @type {boolean}\n   * @private\n   */\n\n  this._singleCanvas = singleCanvas;\n  /**\n   * 绘图容器\n   * @type {HTMLElement}\n   */\n\n  this.root = root;\n  var rootStyle = root.style;\n\n  if (rootStyle) {\n    rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n    rootStyle['-webkit-user-select'] = rootStyle['user-select'] = rootStyle['-webkit-touch-callout'] = 'none';\n    root.innerHTML = '';\n  }\n  /**\n   * @type {module:zrender/Storage}\n   */\n\n\n  this.storage = storage;\n  /**\n   * @type {Array.<number>}\n   * @private\n   */\n\n  var zlevelList = this._zlevelList = [];\n  /**\n   * @type {Object.<string, module:zrender/Layer>}\n   * @private\n   */\n\n  var layers = this._layers = {};\n  /**\n   * @type {Object.<string, Object>}\n   * @private\n   */\n\n  this._layerConfig = {};\n  /**\n   * zrender will do compositing when root is a canvas and have multiple zlevels.\n   */\n\n  this._needsManuallyCompositing = false;\n\n  if (!singleCanvas) {\n    this._width = this._getSize(0);\n    this._height = this._getSize(1);\n    var domRoot = this._domRoot = createRoot(this._width, this._height);\n    root.appendChild(domRoot);\n  } else {\n    var width = root.width;\n    var height = root.height;\n\n    if (opts.width != null) {\n      width = opts.width;\n    }\n\n    if (opts.height != null) {\n      height = opts.height;\n    }\n\n    this.dpr = opts.devicePixelRatio || 1; // Use canvas width and height directly\n\n    root.width = width * this.dpr;\n    root.height = height * this.dpr;\n    this._width = width;\n    this._height = height; // Create layer if only one given canvas\n    // Device can be specified to create a high dpi image.\n\n    var mainLayer = new Layer(root, this, this.dpr);\n    mainLayer.__builtin__ = true;\n    mainLayer.initContext(); // FIXME Use canvas width and height\n    // mainLayer.resize(width, height);\n\n    layers[CANVAS_ZLEVEL] = mainLayer;\n    mainLayer.zlevel = CANVAS_ZLEVEL; // Not use common zlevel.\n\n    zlevelList.push(CANVAS_ZLEVEL);\n    this._domRoot = root;\n  }\n  /**\n   * @type {module:zrender/Layer}\n   * @private\n   */\n\n\n  this._hoverlayer = null;\n  this._hoverElements = [];\n};\n\nPainter.prototype = {\n  constructor: Painter,\n  getType: function () {\n    return 'canvas';\n  },\n\n  /**\n   * If painter use a single canvas\n   * @return {boolean}\n   */\n  isSingleCanvas: function () {\n    return this._singleCanvas;\n  },\n\n  /**\n   * @return {HTMLDivElement}\n   */\n  getViewportRoot: function () {\n    return this._domRoot;\n  },\n  getViewportRootOffset: function () {\n    var viewportRoot = this.getViewportRoot();\n\n    if (viewportRoot) {\n      return {\n        offsetLeft: viewportRoot.offsetLeft || 0,\n        offsetTop: viewportRoot.offsetTop || 0\n      };\n    }\n  },\n\n  /**\n   * 刷新\n   * @param {boolean} [paintAll=false] 强制绘制所有displayable\n   */\n  refresh: function (paintAll) {\n    var list = this.storage.getDisplayList(true);\n    var zlevelList = this._zlevelList;\n    this._redrawId = Math.random();\n\n    this._paintList(list, paintAll, this._redrawId); // Paint custum layers\n\n\n    for (var i = 0; i < zlevelList.length; i++) {\n      var z = zlevelList[i];\n      var layer = this._layers[z];\n\n      if (!layer.__builtin__ && layer.refresh) {\n        var clearColor = i === 0 ? this._backgroundColor : null;\n        layer.refresh(clearColor);\n      }\n    }\n\n    this.refreshHover();\n    return this;\n  },\n  addHover: function (el, hoverStyle) {\n    if (el.__hoverMir) {\n      return;\n    }\n\n    var elMirror = new el.constructor({\n      style: el.style,\n      shape: el.shape,\n      z: el.z,\n      z2: el.z2,\n      silent: el.silent\n    });\n    elMirror.__from = el;\n    el.__hoverMir = elMirror;\n    hoverStyle && elMirror.setStyle(hoverStyle);\n\n    this._hoverElements.push(elMirror);\n\n    return elMirror;\n  },\n  removeHover: function (el) {\n    var elMirror = el.__hoverMir;\n    var hoverElements = this._hoverElements;\n    var idx = util.indexOf(hoverElements, elMirror);\n\n    if (idx >= 0) {\n      hoverElements.splice(idx, 1);\n    }\n\n    el.__hoverMir = null;\n  },\n  clearHover: function (el) {\n    var hoverElements = this._hoverElements;\n\n    for (var i = 0; i < hoverElements.length; i++) {\n      var from = hoverElements[i].__from;\n\n      if (from) {\n        from.__hoverMir = null;\n      }\n    }\n\n    hoverElements.length = 0;\n  },\n  refreshHover: function () {\n    var hoverElements = this._hoverElements;\n    var len = hoverElements.length;\n    var hoverLayer = this._hoverlayer;\n    hoverLayer && hoverLayer.clear();\n\n    if (!len) {\n      return;\n    }\n\n    timsort(hoverElements, this.storage.displayableSortFunc); // Use a extream large zlevel\n    // FIXME?\n\n    if (!hoverLayer) {\n      hoverLayer = this._hoverlayer = this.getLayer(HOVER_LAYER_ZLEVEL);\n    }\n\n    var scope = {};\n    hoverLayer.ctx.save();\n\n    for (var i = 0; i < len;) {\n      var el = hoverElements[i];\n      var originalEl = el.__from; // Original el is removed\n      // PENDING\n\n      if (!(originalEl && originalEl.__zr)) {\n        hoverElements.splice(i, 1);\n        originalEl.__hoverMir = null;\n        len--;\n        continue;\n      }\n\n      i++; // Use transform\n      // FIXME style and shape ?\n\n      if (!originalEl.invisible) {\n        el.transform = originalEl.transform;\n        el.invTransform = originalEl.invTransform;\n        el.__clipPaths = originalEl.__clipPaths; // el.\n\n        this._doPaintEl(el, hoverLayer, true, scope);\n      }\n    }\n\n    hoverLayer.ctx.restore();\n  },\n  getHoverLayer: function () {\n    return this.getLayer(HOVER_LAYER_ZLEVEL);\n  },\n  _paintList: function (list, paintAll, redrawId) {\n    if (this._redrawId !== redrawId) {\n      return;\n    }\n\n    paintAll = paintAll || false;\n\n    this._updateLayerStatus(list);\n\n    var finished = this._doPaintList(list, paintAll);\n\n    if (this._needsManuallyCompositing) {\n      this._compositeManually();\n    }\n\n    if (!finished) {\n      var self = this;\n      requestAnimationFrame(function () {\n        self._paintList(list, paintAll, redrawId);\n      });\n    }\n  },\n  _compositeManually: function () {\n    var ctx = this.getLayer(CANVAS_ZLEVEL).ctx;\n    var width = this._domRoot.width;\n    var height = this._domRoot.height;\n    ctx.clearRect(0, 0, width, height); // PENDING, If only builtin layer?\n\n    this.eachBuiltinLayer(function (layer) {\n      if (layer.virtual) {\n        ctx.drawImage(layer.dom, 0, 0, width, height);\n      }\n    });\n  },\n  _doPaintList: function (list, paintAll) {\n    var layerList = [];\n\n    for (var zi = 0; zi < this._zlevelList.length; zi++) {\n      var zlevel = this._zlevelList[zi];\n      var layer = this._layers[zlevel];\n\n      if (layer.__builtin__ && layer !== this._hoverlayer && (layer.__dirty || paintAll)) {\n        layerList.push(layer);\n      }\n    }\n\n    var finished = true;\n\n    for (var k = 0; k < layerList.length; k++) {\n      var layer = layerList[k];\n      var ctx = layer.ctx;\n      var scope = {};\n      ctx.save();\n      var start = paintAll ? layer.__startIndex : layer.__drawIndex;\n      var useTimer = !paintAll && layer.incremental && Date.now;\n      var startTime = useTimer && Date.now();\n      var clearColor = layer.zlevel === this._zlevelList[0] ? this._backgroundColor : null; // All elements in this layer are cleared.\n\n      if (layer.__startIndex === layer.__endIndex) {\n        layer.clear(false, clearColor);\n      } else if (start === layer.__startIndex) {\n        var firstEl = list[start];\n\n        if (!firstEl.incremental || !firstEl.notClear || paintAll) {\n          layer.clear(false, clearColor);\n        }\n      }\n\n      if (start === -1) {\n        console.error('For some unknown reason. drawIndex is -1');\n        start = layer.__startIndex;\n      }\n\n      for (var i = start; i < layer.__endIndex; i++) {\n        var el = list[i];\n\n        this._doPaintEl(el, layer, paintAll, scope);\n\n        el.__dirty = el.__dirtyText = false;\n\n        if (useTimer) {\n          // Date.now can be executed in 13,025,305 ops/second.\n          var dTime = Date.now() - startTime; // Give 15 millisecond to draw.\n          // The rest elements will be drawn in the next frame.\n\n          if (dTime > 15) {\n            break;\n          }\n        }\n      }\n\n      layer.__drawIndex = i;\n\n      if (layer.__drawIndex < layer.__endIndex) {\n        finished = false;\n      }\n\n      if (scope.prevElClipPaths) {\n        // Needs restore the state. If last drawn element is in the clipping area.\n        ctx.restore();\n      }\n\n      ctx.restore();\n    }\n\n    if (env.wxa) {\n      // Flush for weixin application\n      util.each(this._layers, function (layer) {\n        if (layer && layer.ctx && layer.ctx.draw) {\n          layer.ctx.draw();\n        }\n      });\n    }\n\n    return finished;\n  },\n  _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n    var ctx = currentLayer.ctx;\n    var m = el.transform;\n\n    if ((currentLayer.__dirty || forcePaint) && // Ignore invisible element\n    !el.invisible // Ignore transparent element\n    && el.style.opacity !== 0 // Ignore scale 0 element, in some environment like node-canvas\n    // Draw a scale 0 element can cause all following draw wrong\n    // And setTransform with scale 0 will cause set back transform failed.\n    && !(m && !m[0] && !m[3]) // Ignore culled element\n    && !(el.culling && isDisplayableCulled(el, this._width, this._height))) {\n      var clipPaths = el.__clipPaths;\n      var prevElClipPaths = scope.prevElClipPaths; // Optimize when clipping on group with several elements\n\n      if (!prevElClipPaths || isClipPathChanged(clipPaths, prevElClipPaths)) {\n        // If has previous clipping state, restore from it\n        if (prevElClipPaths) {\n          ctx.restore();\n          scope.prevElClipPaths = null; // Reset prevEl since context has been restored\n\n          scope.prevEl = null;\n        } // New clipping state\n\n\n        if (clipPaths) {\n          ctx.save();\n          doClip(clipPaths, ctx);\n          scope.prevElClipPaths = clipPaths;\n        }\n      }\n\n      el.beforeBrush && el.beforeBrush(ctx);\n      el.brush(ctx, scope.prevEl || null);\n      scope.prevEl = el;\n      el.afterBrush && el.afterBrush(ctx);\n    }\n  },\n\n  /**\n   * 获取 zlevel 所在层，如果不存在则会创建一个新的层\n   * @param {number} zlevel\n   * @param {boolean} virtual Virtual layer will not be inserted into dom.\n   * @return {module:zrender/Layer}\n   */\n  getLayer: function (zlevel, virtual) {\n    if (this._singleCanvas && !this._needsManuallyCompositing) {\n      zlevel = CANVAS_ZLEVEL;\n    }\n\n    var layer = this._layers[zlevel];\n\n    if (!layer) {\n      // Create a new layer\n      layer = new Layer('zr_' + zlevel, this, this.dpr);\n      layer.zlevel = zlevel;\n      layer.__builtin__ = true;\n\n      if (this._layerConfig[zlevel]) {\n        util.merge(layer, this._layerConfig[zlevel], true);\n      } // TODO Remove EL_AFTER_INCREMENTAL_INC magic number\n      else if (this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC]) {\n          util.merge(layer, this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC], true);\n        }\n\n      if (virtual) {\n        layer.virtual = virtual;\n      }\n\n      this.insertLayer(zlevel, layer); // Context is created after dom inserted to document\n      // Or excanvas will get 0px clientWidth and clientHeight\n\n      layer.initContext();\n    }\n\n    return layer;\n  },\n  insertLayer: function (zlevel, layer) {\n    var layersMap = this._layers;\n    var zlevelList = this._zlevelList;\n    var len = zlevelList.length;\n    var prevLayer = null;\n    var i = -1;\n    var domRoot = this._domRoot;\n\n    if (layersMap[zlevel]) {\n      logError('ZLevel ' + zlevel + ' has been used already');\n      return;\n    } // Check if is a valid layer\n\n\n    if (!isLayerValid(layer)) {\n      logError('Layer of zlevel ' + zlevel + ' is not valid');\n      return;\n    }\n\n    if (len > 0 && zlevel > zlevelList[0]) {\n      for (i = 0; i < len - 1; i++) {\n        if (zlevelList[i] < zlevel && zlevelList[i + 1] > zlevel) {\n          break;\n        }\n      }\n\n      prevLayer = layersMap[zlevelList[i]];\n    }\n\n    zlevelList.splice(i + 1, 0, zlevel);\n    layersMap[zlevel] = layer; // Vitual layer will not directly show on the screen.\n    // (It can be a WebGL layer and assigned to a ZImage element)\n    // But it still under management of zrender.\n\n    if (!layer.virtual) {\n      if (prevLayer) {\n        var prevDom = prevLayer.dom;\n\n        if (prevDom.nextSibling) {\n          domRoot.insertBefore(layer.dom, prevDom.nextSibling);\n        } else {\n          domRoot.appendChild(layer.dom);\n        }\n      } else {\n        if (domRoot.firstChild) {\n          domRoot.insertBefore(layer.dom, domRoot.firstChild);\n        } else {\n          domRoot.appendChild(layer.dom);\n        }\n      }\n    }\n  },\n  // Iterate each layer\n  eachLayer: function (cb, context) {\n    var zlevelList = this._zlevelList;\n    var z;\n    var i;\n\n    for (i = 0; i < zlevelList.length; i++) {\n      z = zlevelList[i];\n      cb.call(context, this._layers[z], z);\n    }\n  },\n  // Iterate each buildin layer\n  eachBuiltinLayer: function (cb, context) {\n    var zlevelList = this._zlevelList;\n    var layer;\n    var z;\n    var i;\n\n    for (i = 0; i < zlevelList.length; i++) {\n      z = zlevelList[i];\n      layer = this._layers[z];\n\n      if (layer.__builtin__) {\n        cb.call(context, layer, z);\n      }\n    }\n  },\n  // Iterate each other layer except buildin layer\n  eachOtherLayer: function (cb, context) {\n    var zlevelList = this._zlevelList;\n    var layer;\n    var z;\n    var i;\n\n    for (i = 0; i < zlevelList.length; i++) {\n      z = zlevelList[i];\n      layer = this._layers[z];\n\n      if (!layer.__builtin__) {\n        cb.call(context, layer, z);\n      }\n    }\n  },\n\n  /**\n   * 获取所有已创建的层\n   * @param {Array.<module:zrender/Layer>} [prevLayer]\n   */\n  getLayers: function () {\n    return this._layers;\n  },\n  _updateLayerStatus: function (list) {\n    this.eachBuiltinLayer(function (layer, z) {\n      layer.__dirty = layer.__used = false;\n    });\n\n    function updatePrevLayer(idx) {\n      if (prevLayer) {\n        if (prevLayer.__endIndex !== idx) {\n          prevLayer.__dirty = true;\n        }\n\n        prevLayer.__endIndex = idx;\n      }\n    }\n\n    if (this._singleCanvas) {\n      for (var i = 1; i < list.length; i++) {\n        var el = list[i];\n\n        if (el.zlevel !== list[i - 1].zlevel || el.incremental) {\n          this._needsManuallyCompositing = true;\n          break;\n        }\n      }\n    }\n\n    var prevLayer = null;\n    var incrementalLayerCount = 0;\n    var prevZlevel;\n\n    for (var i = 0; i < list.length; i++) {\n      var el = list[i];\n      var zlevel = el.zlevel;\n      var layer;\n\n      if (prevZlevel !== zlevel) {\n        prevZlevel = zlevel;\n        incrementalLayerCount = 0;\n      } // TODO Not use magic number on zlevel.\n      // Each layer with increment element can be separated to 3 layers.\n      //          (Other Element drawn after incremental element)\n      // -----------------zlevel + EL_AFTER_INCREMENTAL_INC--------------------\n      //                      (Incremental element)\n      // ----------------------zlevel + INCREMENTAL_INC------------------------\n      //              (Element drawn before incremental element)\n      // --------------------------------zlevel--------------------------------\n\n\n      if (el.incremental) {\n        layer = this.getLayer(zlevel + INCREMENTAL_INC, this._needsManuallyCompositing);\n        layer.incremental = true;\n        incrementalLayerCount = 1;\n      } else {\n        layer = this.getLayer(zlevel + (incrementalLayerCount > 0 ? EL_AFTER_INCREMENTAL_INC : 0), this._needsManuallyCompositing);\n      }\n\n      if (!layer.__builtin__) {\n        logError('ZLevel ' + zlevel + ' has been used by unkown layer ' + layer.id);\n      }\n\n      if (layer !== prevLayer) {\n        layer.__used = true;\n\n        if (layer.__startIndex !== i) {\n          layer.__dirty = true;\n        }\n\n        layer.__startIndex = i;\n\n        if (!layer.incremental) {\n          layer.__drawIndex = i;\n        } else {\n          // Mark layer draw index needs to update.\n          layer.__drawIndex = -1;\n        }\n\n        updatePrevLayer(i);\n        prevLayer = layer;\n      }\n\n      if (el.__dirty) {\n        layer.__dirty = true;\n\n        if (layer.incremental && layer.__drawIndex < 0) {\n          // Start draw from the first dirty element.\n          layer.__drawIndex = i;\n        }\n      }\n    }\n\n    updatePrevLayer(i);\n    this.eachBuiltinLayer(function (layer, z) {\n      // Used in last frame but not in this frame. Needs clear\n      if (!layer.__used && layer.getElementCount() > 0) {\n        layer.__dirty = true;\n        layer.__startIndex = layer.__endIndex = layer.__drawIndex = 0;\n      } // For incremental layer. In case start index changed and no elements are dirty.\n\n\n      if (layer.__dirty && layer.__drawIndex < 0) {\n        layer.__drawIndex = layer.__startIndex;\n      }\n    });\n  },\n\n  /**\n   * 清除hover层外所有内容\n   */\n  clear: function () {\n    this.eachBuiltinLayer(this._clearLayer);\n    return this;\n  },\n  _clearLayer: function (layer) {\n    layer.clear();\n  },\n  setBackgroundColor: function (backgroundColor) {\n    this._backgroundColor = backgroundColor;\n  },\n\n  /**\n   * 修改指定zlevel的绘制参数\n   *\n   * @param {string} zlevel\n   * @param {Object} config 配置对象\n   * @param {string} [config.clearColor=0] 每次清空画布的颜色\n   * @param {string} [config.motionBlur=false] 是否开启动态模糊\n   * @param {number} [config.lastFrameAlpha=0.7]\n   *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n   */\n  configLayer: function (zlevel, config) {\n    if (config) {\n      var layerConfig = this._layerConfig;\n\n      if (!layerConfig[zlevel]) {\n        layerConfig[zlevel] = config;\n      } else {\n        util.merge(layerConfig[zlevel], config, true);\n      }\n\n      for (var i = 0; i < this._zlevelList.length; i++) {\n        var _zlevel = this._zlevelList[i]; // TODO Remove EL_AFTER_INCREMENTAL_INC magic number\n\n        if (_zlevel === zlevel || _zlevel === zlevel + EL_AFTER_INCREMENTAL_INC) {\n          var layer = this._layers[_zlevel];\n          util.merge(layer, layerConfig[zlevel], true);\n        }\n      }\n    }\n  },\n\n  /**\n   * 删除指定层\n   * @param {number} zlevel 层所在的zlevel\n   */\n  delLayer: function (zlevel) {\n    var layers = this._layers;\n    var zlevelList = this._zlevelList;\n    var layer = layers[zlevel];\n\n    if (!layer) {\n      return;\n    }\n\n    layer.dom.parentNode.removeChild(layer.dom);\n    delete layers[zlevel];\n    zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n  },\n\n  /**\n   * 区域大小变化后重绘\n   */\n  resize: function (width, height) {\n    if (!this._domRoot.style) {\n      // Maybe in node or worker\n      if (width == null || height == null) {\n        return;\n      }\n\n      this._width = width;\n      this._height = height;\n      this.getLayer(CANVAS_ZLEVEL).resize(width, height);\n    } else {\n      var domRoot = this._domRoot; // FIXME Why ?\n\n      domRoot.style.display = 'none'; // Save input w/h\n\n      var opts = this._opts;\n      width != null && (opts.width = width);\n      height != null && (opts.height = height);\n      width = this._getSize(0);\n      height = this._getSize(1);\n      domRoot.style.display = ''; // 优化没有实际改变的resize\n\n      if (this._width !== width || height !== this._height) {\n        domRoot.style.width = width + 'px';\n        domRoot.style.height = height + 'px';\n\n        for (var id in this._layers) {\n          if (this._layers.hasOwnProperty(id)) {\n            this._layers[id].resize(width, height);\n          }\n        }\n\n        util.each(this._progressiveLayers, function (layer) {\n          layer.resize(width, height);\n        });\n        this.refresh(true);\n      }\n\n      this._width = width;\n      this._height = height;\n    }\n\n    return this;\n  },\n\n  /**\n   * 清除单独的一个层\n   * @param {number} zlevel\n   */\n  clearLayer: function (zlevel) {\n    var layer = this._layers[zlevel];\n\n    if (layer) {\n      layer.clear();\n    }\n  },\n\n  /**\n   * 释放\n   */\n  dispose: function () {\n    this.root.innerHTML = '';\n    this.root = this.storage = this._domRoot = this._layers = null;\n  },\n\n  /**\n   * Get canvas which has all thing rendered\n   * @param {Object} opts\n   * @param {string} [opts.backgroundColor]\n   * @param {number} [opts.pixelRatio]\n   */\n  getRenderedCanvas: function (opts) {\n    opts = opts || {};\n\n    if (this._singleCanvas && !this._compositeManually) {\n      return this._layers[CANVAS_ZLEVEL].dom;\n    }\n\n    var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n    imageLayer.initContext();\n    imageLayer.clear(false, opts.backgroundColor || this._backgroundColor);\n\n    if (opts.pixelRatio <= this.dpr) {\n      this.refresh();\n      var width = imageLayer.dom.width;\n      var height = imageLayer.dom.height;\n      var ctx = imageLayer.ctx;\n      this.eachLayer(function (layer) {\n        if (layer.__builtin__) {\n          ctx.drawImage(layer.dom, 0, 0, width, height);\n        } else if (layer.renderToCanvas) {\n          imageLayer.ctx.save();\n          layer.renderToCanvas(imageLayer.ctx);\n          imageLayer.ctx.restore();\n        }\n      });\n    } else {\n      // PENDING, echarts-gl and incremental rendering.\n      var scope = {};\n      var displayList = this.storage.getDisplayList(true);\n\n      for (var i = 0; i < displayList.length; i++) {\n        var el = displayList[i];\n\n        this._doPaintEl(el, imageLayer, true, scope);\n      }\n    }\n\n    return imageLayer.dom;\n  },\n\n  /**\n   * 获取绘图区域宽度\n   */\n  getWidth: function () {\n    return this._width;\n  },\n\n  /**\n   * 获取绘图区域高度\n   */\n  getHeight: function () {\n    return this._height;\n  },\n  _getSize: function (whIdx) {\n    var opts = this._opts;\n    var wh = ['width', 'height'][whIdx];\n    var cwh = ['clientWidth', 'clientHeight'][whIdx];\n    var plt = ['paddingLeft', 'paddingTop'][whIdx];\n    var prb = ['paddingRight', 'paddingBottom'][whIdx];\n\n    if (opts[wh] != null && opts[wh] !== 'auto') {\n      return parseFloat(opts[wh]);\n    }\n\n    var root = this.root; // IE8 does not support getComputedStyle, but it use VML.\n\n    var stl = document.defaultView.getComputedStyle(root);\n    return (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;\n  },\n  pathToImage: function (path, dpr) {\n    dpr = dpr || this.dpr;\n    var canvas = document.createElement('canvas');\n    var ctx = canvas.getContext('2d');\n    var rect = path.getBoundingRect();\n    var style = path.style;\n    var shadowBlurSize = style.shadowBlur * dpr;\n    var shadowOffsetX = style.shadowOffsetX * dpr;\n    var shadowOffsetY = style.shadowOffsetY * dpr;\n    var lineWidth = style.hasStroke() ? style.lineWidth : 0;\n    var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);\n    var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);\n    var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);\n    var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);\n    var width = rect.width + leftMargin + rightMargin;\n    var height = rect.height + topMargin + bottomMargin;\n    canvas.width = width * dpr;\n    canvas.height = height * dpr;\n    ctx.scale(dpr, dpr);\n    ctx.clearRect(0, 0, width, height);\n    ctx.dpr = dpr;\n    var pathTransform = {\n      position: path.position,\n      rotation: path.rotation,\n      scale: path.scale\n    };\n    path.position = [leftMargin - rect.x, topMargin - rect.y];\n    path.rotation = 0;\n    path.scale = [1, 1];\n    path.updateTransform();\n\n    if (path) {\n      path.brush(ctx);\n    }\n\n    var ImageShape = Image;\n    var imgShape = new ImageShape({\n      style: {\n        x: 0,\n        y: 0,\n        image: canvas\n      }\n    });\n\n    if (pathTransform.position != null) {\n      imgShape.position = path.position = pathTransform.position;\n    }\n\n    if (pathTransform.rotation != null) {\n      imgShape.rotation = path.rotation = pathTransform.rotation;\n    }\n\n    if (pathTransform.scale != null) {\n      imgShape.scale = path.scale = pathTransform.scale;\n    }\n\n    return imgShape;\n  }\n};\nvar _default = Painter;\nmodule.exports = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}