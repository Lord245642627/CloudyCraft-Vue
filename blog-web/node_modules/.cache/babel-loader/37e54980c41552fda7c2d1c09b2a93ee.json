{"ast":null,"code":"import { throttle } from \"./uitls\";\nconst ctx = \"vue3@InfiniteScroll\";\n\nconst getScrollTop = function (element) {\n  if (element === window) {\n    return Math.max(window.pageYOffset || 0, document.documentElement.scrollTop);\n  }\n\n  return element.scrollTop;\n};\n\nconst getComputedStyle = document.defaultView.getComputedStyle;\n\nconst getScrollEventTarget = function (element) {\n  let currentNode = element;\n\n  while (currentNode && currentNode.tagName !== \"HTML\" && currentNode.tagName !== \"BODY\" && currentNode.nodeType === 1) {\n    const overflowY = getComputedStyle(currentNode).overflowY;\n\n    if (overflowY === \"scroll\" || overflowY === \"auto\") {\n      return currentNode;\n    }\n\n    currentNode = currentNode.parentNode;\n  }\n\n  return window;\n};\n\nconst getVisibleHeight = function (element) {\n  if (element === window) {\n    return document.documentElement.clientHeight;\n  }\n\n  return element.clientHeight;\n};\n\nconst getElementTop = function (element) {\n  if (element === window) {\n    return getScrollTop(window);\n  }\n\n  return element.getBoundingClientRect().top + getScrollTop(window);\n};\n\nconst isAttached = function (element) {\n  let currentNode = element.parentNode;\n\n  while (currentNode) {\n    if (currentNode.tagName === \"HTML\") {\n      return true;\n    }\n\n    if (currentNode.nodeType === 11) {\n      return false;\n    }\n\n    currentNode = currentNode.parentNode;\n  }\n\n  return false;\n};\n\nconst doBind = function doBind(context) {\n  if (context.binded) return;\n  context.binded = true;\n  const self = context;\n  const element = self.el;\n  const throttleDelayExpr = element.getAttribute(\"infinite-scroll-throttle-delay\");\n  let throttleDelay = 200;\n\n  if (throttleDelayExpr !== null && throttleDelayExpr !== undefined) {\n    throttleDelay = Number(throttleDelayExpr);\n\n    if (isNaN(throttleDelay) || throttleDelay < 0) {\n      throttleDelay = 200;\n    }\n  }\n\n  self.throttleDelay = throttleDelay;\n  self.scrollEventTarget = getScrollEventTarget(element);\n  self.scrollListener = throttle(doCheck, self.throttleDelay, self);\n  self.scrollEventTarget.addEventListener(\"scroll\", self.scrollListener); // disabled的值\n\n  const disabledExpr = element.getAttribute(\"infinite-scroll-disabled\");\n  let disabled = false; // 要监听的值\n\n  const watchDisabledExpr = element.getAttribute(\"infinite-scroll-watch-disabled\");\n\n  if (disabledExpr !== null && disabledExpr !== undefined) {\n    // 监听disabled值，如果为true则紧张滚动事件触发\n    context.vm.$watch(watchDisabledExpr, function (value) {\n      self.disabled = value;\n\n      if (!value && self.immediateCheck) {\n        doCheck(self);\n      }\n    });\n    disabled = disabledExpr === 'true';\n  }\n\n  self.disabled = disabled;\n  const distanceExpr = element.getAttribute(\"infinite-scroll-distance\");\n  let distance = 0;\n\n  if (distanceExpr !== null && distanceExpr !== undefined) {\n    distance = Number(distanceExpr);\n\n    if (isNaN(distance)) {\n      distance = 0;\n    }\n  }\n\n  self.distance = distance; // 检查是否立即执行\n\n  const immediateCheckExpr = element.getAttribute(\"infinite-scroll-immediate-check\");\n  let immediateCheck = true;\n\n  if (immediateCheckExpr !== null && immediateCheckExpr !== undefined) {\n    immediateCheck = Boolean(immediateCheckExpr);\n  }\n\n  self.immediateCheck = immediateCheck;\n\n  if (immediateCheck) {\n    doCheck(self);\n  }\n};\n\nconst doCheck = function doCheck(context, force) {\n  const scrollEventTarget = context.scrollEventTarget;\n  const element = context.el;\n  const distance = context.distance;\n  if (force !== true && context.disabled) return;\n  const viewportScrollTop = getScrollTop(scrollEventTarget);\n  const viewportBottom = viewportScrollTop + getVisibleHeight(scrollEventTarget);\n  let shouldTrigger = false;\n\n  if (scrollEventTarget === element) {\n    shouldTrigger = scrollEventTarget.scrollHeight - viewportBottom <= distance;\n  } else {\n    const elementBottom = getElementTop(element) - getElementTop(scrollEventTarget) + element.offsetHeight + viewportScrollTop;\n    shouldTrigger = viewportBottom + distance >= elementBottom;\n  } // context.expression 为绑定的v-infinite-scroll\n\n\n  if (shouldTrigger && context.expression) {\n    context.expression();\n  }\n};\n\nconst InfiniteScroll = {\n  created: function bind(el, binding, vnode) {\n    el[ctx] = {\n      el: el,\n      vm: binding.instance,\n      expression: binding.value\n    };\n    el[ctx].vm.$nextTick(function () {\n      if (isAttached(el)) {\n        doBind(el[ctx]);\n      }\n\n      el[ctx].bindTryCount = 0;\n\n      const tryBind = function tryBind() {\n        if (el[ctx].bindTryCount > 10) return;\n        el[ctx].bindTryCount++;\n\n        if (isAttached(el)) {\n          doBind(el[ctx]);\n        } else {\n          setTimeout(tryBind, 50);\n        }\n      };\n\n      tryBind();\n    }); // });\n  },\n  unmounted: function unbind(el) {\n    if (el && el[ctx] && el[ctx].scrollEventTarget) el[ctx].scrollEventTarget.removeEventListener(\"scroll\", el[ctx].scrollListener);\n  }\n};\n\nconst install = function install(Vue) {\n  Vue.directive(\"InfiniteScroll\", InfiniteScroll);\n};\n\nInfiniteScroll.install = install;\nexport default InfiniteScroll;","map":null,"metadata":{},"sourceType":"module"}