{"ast":null,"code":"import { inject, computed, getCurrentInstance, watch, toRaw, unref } from 'vue';\nimport { get } from 'lodash-unified';\nimport '../../../utils/index.mjs';\nimport { selectKey, selectGroupKey } from './token.mjs';\nimport { escapeStringRegexp } from '../../../utils/strings.mjs';\n\nfunction useOption(props, states) {\n  const select = inject(selectKey);\n  const selectGroup = inject(selectGroupKey, {\n    disabled: false\n  });\n  const isObject = computed(() => {\n    return Object.prototype.toString.call(props.value).toLowerCase() === \"[object object]\";\n  });\n  const itemSelected = computed(() => {\n    if (!select.props.multiple) {\n      return isEqual(props.value, select.props.modelValue);\n    } else {\n      return contains(select.props.modelValue, props.value);\n    }\n  });\n  const limitReached = computed(() => {\n    if (select.props.multiple) {\n      const modelValue = select.props.modelValue || [];\n      return !itemSelected.value && modelValue.length >= select.props.multipleLimit && select.props.multipleLimit > 0;\n    } else {\n      return false;\n    }\n  });\n  const currentLabel = computed(() => {\n    return props.label || (isObject.value ? \"\" : props.value);\n  });\n  const currentValue = computed(() => {\n    return props.value || props.label || \"\";\n  });\n  const isDisabled = computed(() => {\n    return props.disabled || states.groupDisabled || limitReached.value;\n  });\n  const instance = getCurrentInstance();\n\n  const contains = (arr = [], target) => {\n    if (!isObject.value) {\n      return arr && arr.includes(target);\n    } else {\n      const valueKey = select.props.valueKey;\n      return arr && arr.some(item => {\n        return get(item, valueKey) === get(target, valueKey);\n      });\n    }\n  };\n\n  const isEqual = (a, b) => {\n    if (!isObject.value) {\n      return a === b;\n    } else {\n      const {\n        valueKey\n      } = select.props;\n      return get(a, valueKey) === get(b, valueKey);\n    }\n  };\n\n  const hoverItem = () => {\n    if (!props.disabled && !selectGroup.disabled) {\n      select.hoverIndex = select.optionsArray.indexOf(instance.proxy);\n    }\n  };\n\n  watch(() => currentLabel.value, () => {\n    if (!props.created && !select.props.remote) select.setSelected();\n  });\n  watch(() => props.value, (val, oldVal) => {\n    const {\n      remote,\n      valueKey\n    } = select.props;\n\n    if (!props.created && !remote) {\n      if (valueKey && typeof val === \"object\" && typeof oldVal === \"object\" && val[valueKey] === oldVal[valueKey]) {\n        return;\n      }\n\n      select.setSelected();\n    }\n  });\n  watch(() => selectGroup.disabled, () => {\n    states.groupDisabled = selectGroup.disabled;\n  }, {\n    immediate: true\n  });\n  const {\n    queryChange\n  } = toRaw(select);\n  watch(queryChange, changes => {\n    const {\n      query\n    } = unref(changes);\n    const regexp = new RegExp(escapeStringRegexp(query), \"i\");\n    states.visible = regexp.test(currentLabel.value) || props.created;\n\n    if (!states.visible) {\n      select.filteredOptionsCount--;\n    }\n  });\n  return {\n    select,\n    currentLabel,\n    currentValue,\n    itemSelected,\n    isDisabled,\n    hoverItem\n  };\n}\n\nexport { useOption };","map":null,"metadata":{},"sourceType":"module"}