{"ast":null,"code":"(function webpackUniversalModuleDefinition(root, factory) {\n  if (typeof exports === 'object' && typeof module === 'object') module.exports = factory(require(\"cose-base\"));else if (typeof define === 'function' && define.amd) define([\"cose-base\"], factory);else if (typeof exports === 'object') exports[\"cytoscapeCoseBilkent\"] = factory(require(\"cose-base\"));else root[\"cytoscapeCoseBilkent\"] = factory(root[\"coseBase\"]);\n})(this, function (__WEBPACK_EXTERNAL_MODULE_0__) {\n  return (\n    /******/\n    function (modules) {\n      // webpackBootstrap\n\n      /******/\n      // The module cache\n\n      /******/\n      var installedModules = {};\n      /******/\n\n      /******/\n      // The require function\n\n      /******/\n\n      function __webpack_require__(moduleId) {\n        /******/\n\n        /******/\n        // Check if module is in cache\n\n        /******/\n        if (installedModules[moduleId]) {\n          /******/\n          return installedModules[moduleId].exports;\n          /******/\n        }\n        /******/\n        // Create a new module (and put it into the cache)\n\n        /******/\n\n\n        var module = installedModules[moduleId] = {\n          /******/\n          i: moduleId,\n\n          /******/\n          l: false,\n\n          /******/\n          exports: {}\n          /******/\n\n        };\n        /******/\n\n        /******/\n        // Execute the module function\n\n        /******/\n\n        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n        /******/\n\n        /******/\n        // Flag the module as loaded\n\n        /******/\n\n        module.l = true;\n        /******/\n\n        /******/\n        // Return the exports of the module\n\n        /******/\n\n        return module.exports;\n        /******/\n      }\n      /******/\n\n      /******/\n\n      /******/\n      // expose the modules object (__webpack_modules__)\n\n      /******/\n\n\n      __webpack_require__.m = modules;\n      /******/\n\n      /******/\n      // expose the module cache\n\n      /******/\n\n      __webpack_require__.c = installedModules;\n      /******/\n\n      /******/\n      // identity function for calling harmony imports with the correct context\n\n      /******/\n\n      __webpack_require__.i = function (value) {\n        return value;\n      };\n      /******/\n\n      /******/\n      // define getter function for harmony exports\n\n      /******/\n\n\n      __webpack_require__.d = function (exports, name, getter) {\n        /******/\n        if (!__webpack_require__.o(exports, name)) {\n          /******/\n          Object.defineProperty(exports, name, {\n            /******/\n            configurable: false,\n\n            /******/\n            enumerable: true,\n\n            /******/\n            get: getter\n            /******/\n\n          });\n          /******/\n        }\n        /******/\n\n      };\n      /******/\n\n      /******/\n      // getDefaultExport function for compatibility with non-harmony modules\n\n      /******/\n\n\n      __webpack_require__.n = function (module) {\n        /******/\n        var getter = module && module.__esModule ?\n        /******/\n        function getDefault() {\n          return module['default'];\n        } :\n        /******/\n        function getModuleExports() {\n          return module;\n        };\n        /******/\n\n        __webpack_require__.d(getter, 'a', getter);\n        /******/\n\n\n        return getter;\n        /******/\n      };\n      /******/\n\n      /******/\n      // Object.prototype.hasOwnProperty.call\n\n      /******/\n\n\n      __webpack_require__.o = function (object, property) {\n        return Object.prototype.hasOwnProperty.call(object, property);\n      };\n      /******/\n\n      /******/\n      // __webpack_public_path__\n\n      /******/\n\n\n      __webpack_require__.p = \"\";\n      /******/\n\n      /******/\n      // Load entry module and return exports\n\n      /******/\n\n      return __webpack_require__(__webpack_require__.s = 1);\n      /******/\n    }\n    /************************************************************************/\n\n    /******/\n    ([\n    /* 0 */\n\n    /***/\n    function (module, exports) {\n      module.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n      /***/\n    },\n    /* 1 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var LayoutConstants = __webpack_require__(0).layoutBase.LayoutConstants;\n\n      var FDLayoutConstants = __webpack_require__(0).layoutBase.FDLayoutConstants;\n\n      var CoSEConstants = __webpack_require__(0).CoSEConstants;\n\n      var CoSELayout = __webpack_require__(0).CoSELayout;\n\n      var CoSENode = __webpack_require__(0).CoSENode;\n\n      var PointD = __webpack_require__(0).layoutBase.PointD;\n\n      var DimensionD = __webpack_require__(0).layoutBase.DimensionD;\n\n      var defaults = {\n        // Called on `layoutready`\n        ready: function ready() {},\n        // Called on `layoutstop`\n        stop: function stop() {},\n        // 'draft', 'default' or 'proof\" \n        // - 'draft' fast cooling rate \n        // - 'default' moderate cooling rate \n        // - \"proof\" slow cooling rate\n        quality: 'default',\n        // include labels in node dimensions\n        nodeDimensionsIncludeLabels: false,\n        // number of ticks per frame; higher is faster but more jerky\n        refresh: 30,\n        // Whether to fit the network view after when done\n        fit: true,\n        // Padding on fit\n        padding: 10,\n        // Whether to enable incremental mode\n        randomize: true,\n        // Node repulsion (non overlapping) multiplier\n        nodeRepulsion: 4500,\n        // Ideal edge (non nested) length\n        idealEdgeLength: 50,\n        // Divisor to compute edge forces\n        edgeElasticity: 0.45,\n        // Nesting factor (multiplier) to compute ideal edge length for nested edges\n        nestingFactor: 0.1,\n        // Gravity force (constant)\n        gravity: 0.25,\n        // Maximum number of iterations to perform\n        numIter: 2500,\n        // For enabling tiling\n        tile: true,\n        // Type of layout animation. The option set is {'during', 'end', false}\n        animate: 'end',\n        // Duration for animate:end\n        animationDuration: 500,\n        // Represents the amount of the vertical space to put between the zero degree members during the tiling operation(can also be a function)\n        tilingPaddingVertical: 10,\n        // Represents the amount of the horizontal space to put between the zero degree members during the tiling operation(can also be a function)\n        tilingPaddingHorizontal: 10,\n        // Gravity range (constant) for compounds\n        gravityRangeCompound: 1.5,\n        // Gravity force (constant) for compounds\n        gravityCompound: 1.0,\n        // Gravity range (constant)\n        gravityRange: 3.8,\n        // Initial cooling factor for incremental layout\n        initialEnergyOnIncremental: 0.5\n      };\n\n      function extend(defaults, options) {\n        var obj = {};\n\n        for (var i in defaults) {\n          obj[i] = defaults[i];\n        }\n\n        for (var i in options) {\n          obj[i] = options[i];\n        }\n\n        return obj;\n      }\n\n      ;\n\n      function _CoSELayout(_options) {\n        this.options = extend(defaults, _options);\n        getUserOptions(this.options);\n      }\n\n      var getUserOptions = function getUserOptions(options) {\n        if (options.nodeRepulsion != null) CoSEConstants.DEFAULT_REPULSION_STRENGTH = FDLayoutConstants.DEFAULT_REPULSION_STRENGTH = options.nodeRepulsion;\n        if (options.idealEdgeLength != null) CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = options.idealEdgeLength;\n        if (options.edgeElasticity != null) CoSEConstants.DEFAULT_SPRING_STRENGTH = FDLayoutConstants.DEFAULT_SPRING_STRENGTH = options.edgeElasticity;\n        if (options.nestingFactor != null) CoSEConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = options.nestingFactor;\n        if (options.gravity != null) CoSEConstants.DEFAULT_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH = options.gravity;\n        if (options.numIter != null) CoSEConstants.MAX_ITERATIONS = FDLayoutConstants.MAX_ITERATIONS = options.numIter;\n        if (options.gravityRange != null) CoSEConstants.DEFAULT_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR = options.gravityRange;\n        if (options.gravityCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = options.gravityCompound;\n        if (options.gravityRangeCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = options.gravityRangeCompound;\n        if (options.initialEnergyOnIncremental != null) CoSEConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = options.initialEnergyOnIncremental;\n        if (options.quality == 'draft') LayoutConstants.QUALITY = 0;else if (options.quality == 'proof') LayoutConstants.QUALITY = 2;else LayoutConstants.QUALITY = 1;\n        CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS = FDLayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = options.nodeDimensionsIncludeLabels;\n        CoSEConstants.DEFAULT_INCREMENTAL = FDLayoutConstants.DEFAULT_INCREMENTAL = LayoutConstants.DEFAULT_INCREMENTAL = !options.randomize;\n        CoSEConstants.ANIMATE = FDLayoutConstants.ANIMATE = LayoutConstants.ANIMATE = options.animate;\n        CoSEConstants.TILE = options.tile;\n        CoSEConstants.TILING_PADDING_VERTICAL = typeof options.tilingPaddingVertical === 'function' ? options.tilingPaddingVertical.call() : options.tilingPaddingVertical;\n        CoSEConstants.TILING_PADDING_HORIZONTAL = typeof options.tilingPaddingHorizontal === 'function' ? options.tilingPaddingHorizontal.call() : options.tilingPaddingHorizontal;\n      };\n\n      _CoSELayout.prototype.run = function () {\n        var ready;\n        var frameId;\n        var options = this.options;\n        var idToLNode = this.idToLNode = {};\n        var layout = this.layout = new CoSELayout();\n        var self = this;\n        self.stopped = false;\n        this.cy = this.options.cy;\n        this.cy.trigger({\n          type: 'layoutstart',\n          layout: this\n        });\n        var gm = layout.newGraphManager();\n        this.gm = gm;\n        var nodes = this.options.eles.nodes();\n        var edges = this.options.eles.edges();\n        this.root = gm.addRoot();\n        this.processChildrenList(this.root, this.getTopMostNodes(nodes), layout);\n\n        for (var i = 0; i < edges.length; i++) {\n          var edge = edges[i];\n          var sourceNode = this.idToLNode[edge.data(\"source\")];\n          var targetNode = this.idToLNode[edge.data(\"target\")];\n\n          if (sourceNode !== targetNode && sourceNode.getEdgesBetween(targetNode).length == 0) {\n            var e1 = gm.add(layout.newEdge(), sourceNode, targetNode);\n            e1.id = edge.id();\n          }\n        }\n\n        var getPositions = function getPositions(ele, i) {\n          if (typeof ele === \"number\") {\n            ele = i;\n          }\n\n          var theId = ele.data('id');\n          var lNode = self.idToLNode[theId];\n          return {\n            x: lNode.getRect().getCenterX(),\n            y: lNode.getRect().getCenterY()\n          };\n        };\n        /*\n         * Reposition nodes in iterations animatedly\n         */\n\n\n        var iterateAnimated = function iterateAnimated() {\n          // Thigs to perform after nodes are repositioned on screen\n          var afterReposition = function afterReposition() {\n            if (options.fit) {\n              options.cy.fit(options.eles, options.padding);\n            }\n\n            if (!ready) {\n              ready = true;\n              self.cy.one('layoutready', options.ready);\n              self.cy.trigger({\n                type: 'layoutready',\n                layout: self\n              });\n            }\n          };\n\n          var ticksPerFrame = self.options.refresh;\n          var isDone;\n\n          for (var i = 0; i < ticksPerFrame && !isDone; i++) {\n            isDone = self.stopped || self.layout.tick();\n          } // If layout is done\n\n\n          if (isDone) {\n            // If the layout is not a sublayout and it is successful perform post layout.\n            if (layout.checkLayoutSuccess() && !layout.isSubLayout) {\n              layout.doPostLayout();\n            } // If layout has a tilingPostLayout function property call it.\n\n\n            if (layout.tilingPostLayout) {\n              layout.tilingPostLayout();\n            }\n\n            layout.isLayoutFinished = true;\n            self.options.eles.nodes().positions(getPositions);\n            afterReposition(); // trigger layoutstop when the layout stops (e.g. finishes)\n\n            self.cy.one('layoutstop', self.options.stop);\n            self.cy.trigger({\n              type: 'layoutstop',\n              layout: self\n            });\n\n            if (frameId) {\n              cancelAnimationFrame(frameId);\n            }\n\n            ready = false;\n            return;\n          }\n\n          var animationData = self.layout.getPositionsData(); // Get positions of layout nodes note that all nodes may not be layout nodes because of tiling\n          // Position nodes, for the nodes whose id does not included in data (because they are removed from their parents and included in dummy compounds)\n          // use position of their ancestors or dummy ancestors\n\n          options.eles.nodes().positions(function (ele, i) {\n            if (typeof ele === \"number\") {\n              ele = i;\n            } // If ele is a compound node, then its position will be defined by its children\n\n\n            if (!ele.isParent()) {\n              var theId = ele.id();\n              var pNode = animationData[theId];\n              var temp = ele; // If pNode is undefined search until finding position data of its first ancestor (It may be dummy as well)\n\n              while (pNode == null) {\n                pNode = animationData[temp.data('parent')] || animationData['DummyCompound_' + temp.data('parent')];\n                animationData[theId] = pNode;\n                temp = temp.parent()[0];\n\n                if (temp == undefined) {\n                  break;\n                }\n              }\n\n              if (pNode != null) {\n                return {\n                  x: pNode.x,\n                  y: pNode.y\n                };\n              } else {\n                return {\n                  x: ele.position('x'),\n                  y: ele.position('y')\n                };\n              }\n            }\n          });\n          afterReposition();\n          frameId = requestAnimationFrame(iterateAnimated);\n        };\n        /*\n        * Listen 'layoutstarted' event and start animated iteration if animate option is 'during'\n        */\n\n\n        layout.addListener('layoutstarted', function () {\n          if (self.options.animate === 'during') {\n            frameId = requestAnimationFrame(iterateAnimated);\n          }\n        });\n        layout.runLayout(); // Run cose layout\n\n        /*\n         * If animate option is not 'during' ('end' or false) perform these here (If it is 'during' similar things are already performed)\n         */\n\n        if (this.options.animate !== \"during\") {\n          self.options.eles.nodes().not(\":parent\").layoutPositions(self, self.options, getPositions); // Use layout positions to reposition the nodes it considers the options parameter\n\n          ready = false;\n        }\n\n        return this; // chaining\n      }; //Get the top most ones of a list of nodes\n\n\n      _CoSELayout.prototype.getTopMostNodes = function (nodes) {\n        var nodesMap = {};\n\n        for (var i = 0; i < nodes.length; i++) {\n          nodesMap[nodes[i].id()] = true;\n        }\n\n        var roots = nodes.filter(function (ele, i) {\n          if (typeof ele === \"number\") {\n            ele = i;\n          }\n\n          var parent = ele.parent()[0];\n\n          while (parent != null) {\n            if (nodesMap[parent.id()]) {\n              return false;\n            }\n\n            parent = parent.parent()[0];\n          }\n\n          return true;\n        });\n        return roots;\n      };\n\n      _CoSELayout.prototype.processChildrenList = function (parent, children, layout) {\n        var size = children.length;\n\n        for (var i = 0; i < size; i++) {\n          var theChild = children[i];\n          var children_of_children = theChild.children();\n          var theNode;\n          var dimensions = theChild.layoutDimensions({\n            nodeDimensionsIncludeLabels: this.options.nodeDimensionsIncludeLabels\n          });\n\n          if (theChild.outerWidth() != null && theChild.outerHeight() != null) {\n            theNode = parent.add(new CoSENode(layout.graphManager, new PointD(theChild.position('x') - dimensions.w / 2, theChild.position('y') - dimensions.h / 2), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));\n          } else {\n            theNode = parent.add(new CoSENode(this.graphManager));\n          } // Attach id to the layout node\n\n\n          theNode.id = theChild.data(\"id\"); // Attach the paddings of cy node to layout node\n\n          theNode.paddingLeft = parseInt(theChild.css('padding'));\n          theNode.paddingTop = parseInt(theChild.css('padding'));\n          theNode.paddingRight = parseInt(theChild.css('padding'));\n          theNode.paddingBottom = parseInt(theChild.css('padding')); //Attach the label properties to compound if labels will be included in node dimensions  \n\n          if (this.options.nodeDimensionsIncludeLabels) {\n            if (theChild.isParent()) {\n              var labelWidth = theChild.boundingBox({\n                includeLabels: true,\n                includeNodes: false\n              }).w;\n              var labelHeight = theChild.boundingBox({\n                includeLabels: true,\n                includeNodes: false\n              }).h;\n              var labelPos = theChild.css(\"text-halign\");\n              theNode.labelWidth = labelWidth;\n              theNode.labelHeight = labelHeight;\n              theNode.labelPos = labelPos;\n            }\n          } // Map the layout node\n\n\n          this.idToLNode[theChild.data(\"id\")] = theNode;\n\n          if (isNaN(theNode.rect.x)) {\n            theNode.rect.x = 0;\n          }\n\n          if (isNaN(theNode.rect.y)) {\n            theNode.rect.y = 0;\n          }\n\n          if (children_of_children != null && children_of_children.length > 0) {\n            var theNewGraph;\n            theNewGraph = layout.getGraphManager().add(layout.newGraph(), theNode);\n            this.processChildrenList(theNewGraph, children_of_children, layout);\n          }\n        }\n      };\n      /**\n       * @brief : called on continuous layouts to stop them before they finish\n       */\n\n\n      _CoSELayout.prototype.stop = function () {\n        this.stopped = true;\n        return this; // chaining\n      };\n\n      var register = function register(cytoscape) {\n        //  var Layout = getLayout( cytoscape );\n        cytoscape('layout', 'cose-bilkent', _CoSELayout);\n      }; // auto reg for globals\n\n\n      if (typeof cytoscape !== 'undefined') {\n        register(cytoscape);\n      }\n\n      module.exports = register;\n      /***/\n    }\n    /******/\n    ])\n  );\n});","map":null,"metadata":{},"sourceType":"script"}