{"ast":null,"code":"function t(t) {\n  return t.split(\"-\")[0];\n}\n\nfunction e(t) {\n  return t.split(\"-\")[1];\n}\n\nfunction n(e) {\n  return [\"top\", \"bottom\"].includes(t(e)) ? \"x\" : \"y\";\n}\n\nfunction r(t) {\n  return \"y\" === t ? \"height\" : \"width\";\n}\n\nfunction i(i, o, a) {\n  let {\n    reference: l,\n    floating: s\n  } = i;\n  const c = l.x + l.width / 2 - s.width / 2,\n        f = l.y + l.height / 2 - s.height / 2,\n        u = n(o),\n        m = r(u),\n        g = l[m] / 2 - s[m] / 2,\n        d = \"x\" === u;\n  let p;\n\n  switch (t(o)) {\n    case \"top\":\n      p = {\n        x: c,\n        y: l.y - s.height\n      };\n      break;\n\n    case \"bottom\":\n      p = {\n        x: c,\n        y: l.y + l.height\n      };\n      break;\n\n    case \"right\":\n      p = {\n        x: l.x + l.width,\n        y: f\n      };\n      break;\n\n    case \"left\":\n      p = {\n        x: l.x - s.width,\n        y: f\n      };\n      break;\n\n    default:\n      p = {\n        x: l.x,\n        y: l.y\n      };\n  }\n\n  switch (e(o)) {\n    case \"start\":\n      p[u] -= g * (a && d ? -1 : 1);\n      break;\n\n    case \"end\":\n      p[u] += g * (a && d ? -1 : 1);\n  }\n\n  return p;\n}\n\nconst o = async (t, e, n) => {\n  const {\n    placement: r = \"bottom\",\n    strategy: o = \"absolute\",\n    middleware: a = [],\n    platform: l\n  } = n,\n        s = await (null == l.isRTL ? void 0 : l.isRTL(e));\n  let c = await l.getElementRects({\n    reference: t,\n    floating: e,\n    strategy: o\n  }),\n      {\n    x: f,\n    y: u\n  } = i(c, r, s),\n      m = r,\n      g = {},\n      d = 0;\n\n  for (let n = 0; n < a.length; n++) {\n    const {\n      name: p,\n      fn: h\n    } = a[n],\n          {\n      x: y,\n      y: x,\n      data: w,\n      reset: v\n    } = await h({\n      x: f,\n      y: u,\n      initialPlacement: r,\n      placement: m,\n      strategy: o,\n      middlewareData: g,\n      rects: c,\n      platform: l,\n      elements: {\n        reference: t,\n        floating: e\n      }\n    });\n    f = null != y ? y : f, u = null != x ? x : u, g = { ...g,\n      [p]: { ...g[p],\n        ...w\n      }\n    }, v && d <= 50 && (d++, \"object\" == typeof v && (v.placement && (m = v.placement), v.rects && (c = !0 === v.rects ? await l.getElementRects({\n      reference: t,\n      floating: e,\n      strategy: o\n    }) : v.rects), ({\n      x: f,\n      y: u\n    } = i(c, m, s))), n = -1);\n  }\n\n  return {\n    x: f,\n    y: u,\n    placement: m,\n    strategy: o,\n    middlewareData: g\n  };\n};\n\nfunction a(t) {\n  return \"number\" != typeof t ? function (t) {\n    return {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0,\n      ...t\n    };\n  }(t) : {\n    top: t,\n    right: t,\n    bottom: t,\n    left: t\n  };\n}\n\nfunction l(t) {\n  return { ...t,\n    top: t.y,\n    left: t.x,\n    right: t.x + t.width,\n    bottom: t.y + t.height\n  };\n}\n\nasync function s(t, e) {\n  var n;\n  void 0 === e && (e = {});\n  const {\n    x: r,\n    y: i,\n    platform: o,\n    rects: s,\n    elements: c,\n    strategy: f\n  } = t,\n        {\n    boundary: u = \"clippingAncestors\",\n    rootBoundary: m = \"viewport\",\n    elementContext: g = \"floating\",\n    altBoundary: d = !1,\n    padding: p = 0\n  } = e,\n        h = a(p),\n        y = c[d ? \"floating\" === g ? \"reference\" : \"floating\" : g],\n        x = l(await o.getClippingRect({\n    element: null == (n = await (null == o.isElement ? void 0 : o.isElement(y))) || n ? y : y.contextElement || (await (null == o.getDocumentElement ? void 0 : o.getDocumentElement(c.floating))),\n    boundary: u,\n    rootBoundary: m,\n    strategy: f\n  })),\n        w = l(o.convertOffsetParentRelativeRectToViewportRelativeRect ? await o.convertOffsetParentRelativeRectToViewportRelativeRect({\n    rect: \"floating\" === g ? { ...s.floating,\n      x: r,\n      y: i\n    } : s.reference,\n    offsetParent: await (null == o.getOffsetParent ? void 0 : o.getOffsetParent(c.floating)),\n    strategy: f\n  }) : s[g]);\n  return {\n    top: x.top - w.top + h.top,\n    bottom: w.bottom - x.bottom + h.bottom,\n    left: x.left - w.left + h.left,\n    right: w.right - x.right + h.right\n  };\n}\n\nconst c = Math.min,\n      f = Math.max;\n\nfunction u(t, e, n) {\n  return f(t, c(e, n));\n}\n\nconst m = t => ({\n  name: \"arrow\",\n  options: t,\n\n  async fn(i) {\n    const {\n      element: o,\n      padding: l = 0\n    } = null != t ? t : {},\n          {\n      x: s,\n      y: c,\n      placement: f,\n      rects: m,\n      platform: g\n    } = i;\n    if (null == o) return {};\n    const d = a(l),\n          p = {\n      x: s,\n      y: c\n    },\n          h = n(f),\n          y = e(f),\n          x = r(h),\n          w = await g.getDimensions(o),\n          v = \"y\" === h ? \"top\" : \"left\",\n          b = \"y\" === h ? \"bottom\" : \"right\",\n          R = m.reference[x] + m.reference[h] - p[h] - m.floating[x],\n          A = p[h] - m.reference[h],\n          P = await (null == g.getOffsetParent ? void 0 : g.getOffsetParent(o));\n    let T = P ? \"y\" === h ? P.clientHeight || 0 : P.clientWidth || 0 : 0;\n    0 === T && (T = m.floating[x]);\n    const O = R / 2 - A / 2,\n          D = d[v],\n          L = T - w[x] - d[b],\n          k = T / 2 - w[x] / 2 + O,\n          E = u(D, k, L),\n          C = (\"start\" === y ? d[v] : d[b]) > 0 && k !== E && m.reference[x] <= m.floating[x];\n    return {\n      [h]: p[h] - (C ? k < D ? D - k : L - k : 0),\n      data: {\n        [h]: E,\n        centerOffset: k - E\n      }\n    };\n  }\n\n}),\n      g = {\n  left: \"right\",\n  right: \"left\",\n  bottom: \"top\",\n  top: \"bottom\"\n};\n\nfunction d(t) {\n  return t.replace(/left|right|bottom|top/g, t => g[t]);\n}\n\nfunction p(t, i, o) {\n  void 0 === o && (o = !1);\n  const a = e(t),\n        l = n(t),\n        s = r(l);\n  let c = \"x\" === l ? a === (o ? \"end\" : \"start\") ? \"right\" : \"left\" : \"start\" === a ? \"bottom\" : \"top\";\n  return i.reference[s] > i.floating[s] && (c = d(c)), {\n    main: c,\n    cross: d(c)\n  };\n}\n\nconst h = {\n  start: \"end\",\n  end: \"start\"\n};\n\nfunction y(t) {\n  return t.replace(/start|end/g, t => h[t]);\n}\n\nconst x = [\"top\", \"right\", \"bottom\", \"left\"],\n      w = x.reduce((t, e) => t.concat(e, e + \"-start\", e + \"-end\"), []);\n\nconst v = function (n) {\n  return void 0 === n && (n = {}), {\n    name: \"autoPlacement\",\n    options: n,\n\n    async fn(r) {\n      var i, o, a, l, c;\n\n      const {\n        x: f,\n        y: u,\n        rects: m,\n        middlewareData: g,\n        placement: d,\n        platform: h,\n        elements: x\n      } = r,\n            {\n        alignment: v = null,\n        allowedPlacements: b = w,\n        autoAlignment: R = !0,\n        ...A\n      } = n,\n            P = function (n, r, i) {\n        return (n ? [...i.filter(t => e(t) === n), ...i.filter(t => e(t) !== n)] : i.filter(e => t(e) === e)).filter(t => !n || e(t) === n || !!r && y(t) !== t);\n      }(v, R, b),\n            T = await s(r, A),\n            O = null != (i = null == (o = g.autoPlacement) ? void 0 : o.index) ? i : 0,\n            D = P[O];\n\n      if (null == D) return {};\n      const {\n        main: L,\n        cross: k\n      } = p(D, m, await (null == h.isRTL ? void 0 : h.isRTL(x.floating)));\n      if (d !== D) return {\n        x: f,\n        y: u,\n        reset: {\n          placement: P[0]\n        }\n      };\n      const E = [T[t(D)], T[L], T[k]],\n            C = [...(null != (a = null == (l = g.autoPlacement) ? void 0 : l.overflows) ? a : []), {\n        placement: D,\n        overflows: E\n      }],\n            H = P[O + 1];\n      if (H) return {\n        data: {\n          index: O + 1,\n          overflows: C\n        },\n        reset: {\n          placement: H\n        }\n      };\n      const B = C.slice().sort((t, e) => t.overflows[0] - e.overflows[0]),\n            V = null == (c = B.find(t => {\n        let {\n          overflows: e\n        } = t;\n        return e.every(t => t <= 0);\n      })) ? void 0 : c.placement,\n            F = null != V ? V : B[0].placement;\n      return F !== d ? {\n        data: {\n          index: O + 1,\n          overflows: C\n        },\n        reset: {\n          placement: F\n        }\n      } : {};\n    }\n\n  };\n};\n\nconst b = function (e) {\n  return void 0 === e && (e = {}), {\n    name: \"flip\",\n    options: e,\n\n    async fn(n) {\n      var r;\n      const {\n        placement: i,\n        middlewareData: o,\n        rects: a,\n        initialPlacement: l,\n        platform: c,\n        elements: f\n      } = n,\n            {\n        mainAxis: u = !0,\n        crossAxis: m = !0,\n        fallbackPlacements: g,\n        fallbackStrategy: h = \"bestFit\",\n        flipAlignment: x = !0,\n        ...w\n      } = e,\n            v = t(i),\n            b = g || (v === l || !x ? [d(l)] : function (t) {\n        const e = d(t);\n        return [y(t), e, y(e)];\n      }(l)),\n            R = [l, ...b],\n            A = await s(n, w),\n            P = [];\n      let T = (null == (r = o.flip) ? void 0 : r.overflows) || [];\n\n      if (u && P.push(A[v]), m) {\n        const {\n          main: t,\n          cross: e\n        } = p(i, a, await (null == c.isRTL ? void 0 : c.isRTL(f.floating)));\n        P.push(A[t], A[e]);\n      }\n\n      if (T = [...T, {\n        placement: i,\n        overflows: P\n      }], !P.every(t => t <= 0)) {\n        var O, D;\n        const t = (null != (O = null == (D = o.flip) ? void 0 : D.index) ? O : 0) + 1,\n              e = R[t];\n        if (e) return {\n          data: {\n            index: t,\n            overflows: T\n          },\n          reset: {\n            placement: e\n          }\n        };\n        let n = \"bottom\";\n\n        switch (h) {\n          case \"bestFit\":\n            {\n              var L;\n              const t = null == (L = T.map(t => [t, t.overflows.filter(t => t > 0).reduce((t, e) => t + e, 0)]).sort((t, e) => t[1] - e[1])[0]) ? void 0 : L[0].placement;\n              t && (n = t);\n              break;\n            }\n\n          case \"initialPlacement\":\n            n = l;\n        }\n\n        if (i !== n) return {\n          reset: {\n            placement: n\n          }\n        };\n      }\n\n      return {};\n    }\n\n  };\n};\n\nfunction R(t, e) {\n  return {\n    top: t.top - e.height,\n    right: t.right - e.width,\n    bottom: t.bottom - e.height,\n    left: t.left - e.width\n  };\n}\n\nfunction A(t) {\n  return x.some(e => t[e] >= 0);\n}\n\nconst P = function (t) {\n  let {\n    strategy: e = \"referenceHidden\",\n    ...n\n  } = void 0 === t ? {} : t;\n  return {\n    name: \"hide\",\n\n    async fn(t) {\n      const {\n        rects: r\n      } = t;\n\n      switch (e) {\n        case \"referenceHidden\":\n          {\n            const e = R(await s(t, { ...n,\n              elementContext: \"reference\"\n            }), r.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: e,\n                referenceHidden: A(e)\n              }\n            };\n          }\n\n        case \"escaped\":\n          {\n            const e = R(await s(t, { ...n,\n              altBoundary: !0\n            }), r.floating);\n            return {\n              data: {\n                escapedOffsets: e,\n                escaped: A(e)\n              }\n            };\n          }\n\n        default:\n          return {};\n      }\n    }\n\n  };\n};\n\nconst T = function (r) {\n  return void 0 === r && (r = 0), {\n    name: \"offset\",\n    options: r,\n\n    async fn(i) {\n      const {\n        x: o,\n        y: a\n      } = i,\n            l = await async function (r, i) {\n        const {\n          placement: o,\n          platform: a,\n          elements: l\n        } = r,\n              s = await (null == a.isRTL ? void 0 : a.isRTL(l.floating)),\n              c = t(o),\n              f = e(o),\n              u = \"x\" === n(o),\n              m = [\"left\", \"top\"].includes(c) ? -1 : 1,\n              g = s && u ? -1 : 1,\n              d = \"function\" == typeof i ? i(r) : i;\n        let {\n          mainAxis: p,\n          crossAxis: h,\n          alignmentAxis: y\n        } = \"number\" == typeof d ? {\n          mainAxis: d,\n          crossAxis: 0,\n          alignmentAxis: null\n        } : {\n          mainAxis: 0,\n          crossAxis: 0,\n          alignmentAxis: null,\n          ...d\n        };\n        return f && \"number\" == typeof y && (h = \"end\" === f ? -1 * y : y), u ? {\n          x: h * g,\n          y: p * m\n        } : {\n          x: p * m,\n          y: h * g\n        };\n      }(i, r);\n      return {\n        x: o + l.x,\n        y: a + l.y,\n        data: l\n      };\n    }\n\n  };\n};\n\nfunction O(t) {\n  return \"x\" === t ? \"y\" : \"x\";\n}\n\nconst D = function (e) {\n  return void 0 === e && (e = {}), {\n    name: \"shift\",\n    options: e,\n\n    async fn(r) {\n      const {\n        x: i,\n        y: o,\n        placement: a\n      } = r,\n            {\n        mainAxis: l = !0,\n        crossAxis: c = !1,\n        limiter: f = {\n          fn: t => {\n            let {\n              x: e,\n              y: n\n            } = t;\n            return {\n              x: e,\n              y: n\n            };\n          }\n        },\n        ...m\n      } = e,\n            g = {\n        x: i,\n        y: o\n      },\n            d = await s(r, m),\n            p = n(t(a)),\n            h = O(p);\n      let y = g[p],\n          x = g[h];\n\n      if (l) {\n        const t = \"y\" === p ? \"bottom\" : \"right\";\n        y = u(y + d[\"y\" === p ? \"top\" : \"left\"], y, y - d[t]);\n      }\n\n      if (c) {\n        const t = \"y\" === h ? \"bottom\" : \"right\";\n        x = u(x + d[\"y\" === h ? \"top\" : \"left\"], x, x - d[t]);\n      }\n\n      const w = f.fn({ ...r,\n        [p]: y,\n        [h]: x\n      });\n      return { ...w,\n        data: {\n          x: w.x - i,\n          y: w.y - o\n        }\n      };\n    }\n\n  };\n},\n      L = function (e) {\n  return void 0 === e && (e = {}), {\n    options: e,\n\n    fn(r) {\n      const {\n        x: i,\n        y: o,\n        placement: a,\n        rects: l,\n        middlewareData: s\n      } = r,\n            {\n        offset: c = 0,\n        mainAxis: f = !0,\n        crossAxis: u = !0\n      } = e,\n            m = {\n        x: i,\n        y: o\n      },\n            g = n(a),\n            d = O(g);\n      let p = m[g],\n          h = m[d];\n      const y = \"function\" == typeof c ? c({ ...l,\n        placement: a\n      }) : c,\n            x = \"number\" == typeof y ? {\n        mainAxis: y,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...y\n      };\n\n      if (f) {\n        const t = \"y\" === g ? \"height\" : \"width\",\n              e = l.reference[g] - l.floating[t] + x.mainAxis,\n              n = l.reference[g] + l.reference[t] - x.mainAxis;\n        p < e ? p = e : p > n && (p = n);\n      }\n\n      if (u) {\n        var w, v, b, R;\n        const e = \"y\" === g ? \"width\" : \"height\",\n              n = [\"top\", \"left\"].includes(t(a)),\n              r = l.reference[d] - l.floating[e] + (n && null != (w = null == (v = s.offset) ? void 0 : v[d]) ? w : 0) + (n ? 0 : x.crossAxis),\n              i = l.reference[d] + l.reference[e] + (n ? 0 : null != (b = null == (R = s.offset) ? void 0 : R[d]) ? b : 0) - (n ? x.crossAxis : 0);\n        h < r ? h = r : h > i && (h = i);\n      }\n\n      return {\n        [g]: p,\n        [d]: h\n      };\n    }\n\n  };\n},\n      k = function (n) {\n  return void 0 === n && (n = {}), {\n    name: \"size\",\n    options: n,\n\n    async fn(r) {\n      const {\n        placement: i,\n        rects: o,\n        platform: a,\n        elements: l\n      } = r,\n            {\n        apply: c,\n        ...u\n      } = n,\n            m = await s(r, u),\n            g = t(i),\n            d = e(i);\n      let p, h;\n      \"top\" === g || \"bottom\" === g ? (p = g, h = d === ((await (null == a.isRTL ? void 0 : a.isRTL(l.floating))) ? \"start\" : \"end\") ? \"left\" : \"right\") : (h = g, p = \"end\" === d ? \"top\" : \"bottom\");\n      const y = f(m.left, 0),\n            x = f(m.right, 0),\n            w = f(m.top, 0),\n            v = f(m.bottom, 0),\n            b = {\n        availableHeight: o.floating.height - ([\"left\", \"right\"].includes(i) ? 2 * (0 !== w || 0 !== v ? w + v : f(m.top, m.bottom)) : m[p]),\n        availableWidth: o.floating.width - ([\"top\", \"bottom\"].includes(i) ? 2 * (0 !== y || 0 !== x ? y + x : f(m.left, m.right)) : m[h])\n      },\n            R = await a.getDimensions(l.floating);\n      null == c || c({ ...r,\n        ...b\n      });\n      const A = await a.getDimensions(l.floating);\n      return R.width !== A.width || R.height !== A.height ? {\n        reset: {\n          rects: !0\n        }\n      } : {};\n    }\n\n  };\n},\n      E = function (e) {\n  return void 0 === e && (e = {}), {\n    name: \"inline\",\n    options: e,\n\n    async fn(r) {\n      var i;\n      const {\n        placement: o,\n        elements: s,\n        rects: u,\n        platform: m,\n        strategy: g\n      } = r,\n            {\n        padding: d = 2,\n        x: p,\n        y: h\n      } = e,\n            y = l(m.convertOffsetParentRelativeRectToViewportRelativeRect ? await m.convertOffsetParentRelativeRectToViewportRelativeRect({\n        rect: u.reference,\n        offsetParent: await (null == m.getOffsetParent ? void 0 : m.getOffsetParent(s.floating)),\n        strategy: g\n      }) : u.reference),\n            x = null != (i = await (null == m.getClientRects ? void 0 : m.getClientRects(s.reference))) ? i : [],\n            w = a(d);\n      const v = await m.getElementRects({\n        reference: {\n          getBoundingClientRect: function () {\n            var e;\n            if (2 === x.length && x[0].left > x[1].right && null != p && null != h) return null != (e = x.find(t => p > t.left - w.left && p < t.right + w.right && h > t.top - w.top && h < t.bottom + w.bottom)) ? e : y;\n\n            if (x.length >= 2) {\n              if (\"x\" === n(o)) {\n                const e = x[0],\n                      n = x[x.length - 1],\n                      r = \"top\" === t(o),\n                      i = e.top,\n                      a = n.bottom,\n                      l = r ? e.left : n.left,\n                      s = r ? e.right : n.right;\n                return {\n                  top: i,\n                  bottom: a,\n                  left: l,\n                  right: s,\n                  width: s - l,\n                  height: a - i,\n                  x: l,\n                  y: i\n                };\n              }\n\n              const e = \"left\" === t(o),\n                    r = f(...x.map(t => t.right)),\n                    i = c(...x.map(t => t.left)),\n                    a = x.filter(t => e ? t.left === i : t.right === r),\n                    l = a[0].top,\n                    s = a[a.length - 1].bottom;\n              return {\n                top: l,\n                bottom: s,\n                left: i,\n                right: r,\n                width: r - i,\n                height: s - l,\n                x: i,\n                y: l\n              };\n            }\n\n            return y;\n          }\n        },\n        floating: s.floating,\n        strategy: g\n      });\n      return u.reference.x !== v.reference.x || u.reference.y !== v.reference.y || u.reference.width !== v.reference.width || u.reference.height !== v.reference.height ? {\n        reset: {\n          rects: v\n        }\n      } : {};\n    }\n\n  };\n};\n\nexport { m as arrow, v as autoPlacement, o as computePosition, s as detectOverflow, b as flip, P as hide, E as inline, L as limitShift, T as offset, l as rectToClientRect, D as shift, k as size };","map":null,"metadata":{},"sourceType":"module"}