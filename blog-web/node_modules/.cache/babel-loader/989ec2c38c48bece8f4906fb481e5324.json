{"ast":null,"code":"/*!\n  * @intlify/core-base v9.1.10\n  * (c) 2022 kazuya kawaguchi\n  * Released under the MIT License.\n  */\nimport { format, isString, isArray, isPlainObject, assign, isFunction, isBoolean, isRegExp, warn, isObject, escapeHtml, inBrowser, mark, measure, generateCodeFrame, generateFormatCacheKey, isNumber, isEmptyObject, isDate, getGlobalThis } from '@intlify/shared';\nimport { resolveValue } from '@intlify/message-resolver';\nexport * from '@intlify/message-resolver';\nimport { createMessageContext } from '@intlify/runtime';\nexport * from '@intlify/runtime';\nimport { defaultOnError, baseCompile, createCompileError } from '@intlify/message-compiler';\nexport { createCompileError } from '@intlify/message-compiler';\nimport { IntlifyDevToolsHooks } from '@intlify/devtools-if';\nlet devtools = null;\n\nfunction setDevToolsHook(hook) {\n  devtools = hook;\n}\n\nfunction getDevToolsHook() {\n  return devtools;\n}\n\nfunction initI18nDevTools(i18n, version, meta) {\n  // TODO: queue if devtools is undefined\n  devtools && devtools.emit(IntlifyDevToolsHooks.I18nInit, {\n    timestamp: Date.now(),\n    i18n,\n    version,\n    meta\n  });\n}\n\nconst translateDevTools = /* #__PURE__*/createDevToolsHook(IntlifyDevToolsHooks.FunctionTranslate);\n\nfunction createDevToolsHook(hook) {\n  return payloads => devtools && devtools.emit(hook, payloads);\n}\n/** @internal */\n\n\nconst warnMessages = {\n  [0\n  /* NOT_FOUND_KEY */\n  ]: `Not found '{key}' key in '{locale}' locale messages.`,\n  [1\n  /* FALLBACK_TO_TRANSLATE */\n  ]: `Fall back to translate '{key}' key with '{target}' locale.`,\n  [2\n  /* CANNOT_FORMAT_NUMBER */\n  ]: `Cannot format a number value due to not supported Intl.NumberFormat.`,\n  [3\n  /* FALLBACK_TO_NUMBER_FORMAT */\n  ]: `Fall back to number format '{key}' key with '{target}' locale.`,\n  [4\n  /* CANNOT_FORMAT_DATE */\n  ]: `Cannot format a date value due to not supported Intl.DateTimeFormat.`,\n  [5\n  /* FALLBACK_TO_DATE_FORMAT */\n  ]: `Fall back to datetime format '{key}' key with '{target}' locale.`\n};\n\nfunction getWarnMessage(code, ...args) {\n  return format(warnMessages[code], ...args);\n}\n/**\r\n * Intlify core-base version\r\n * @internal\r\n */\n\n\nconst VERSION = '9.1.10';\nconst NOT_REOSLVED = -1;\nconst MISSING_RESOLVE_VALUE = '';\n\nfunction getDefaultLinkedModifiers() {\n  return {\n    upper: val => isString(val) ? val.toUpperCase() : val,\n    lower: val => isString(val) ? val.toLowerCase() : val,\n    // prettier-ignore\n    capitalize: val => isString(val) ? `${val.charAt(0).toLocaleUpperCase()}${val.substr(1)}` : val\n  };\n}\n\nlet _compiler;\n\nfunction registerMessageCompiler(compiler) {\n  _compiler = compiler;\n} // Additional Meta for Intlify DevTools\n\n\nlet _additionalMeta = null;\n\nconst setAdditionalMeta = /* #__PURE__*/meta => {\n  _additionalMeta = meta;\n};\n\nconst getAdditionalMeta = /* #__PURE__*/() => _additionalMeta; // ID for CoreContext\n\n\nlet _cid = 0;\n\nfunction createCoreContext(options = {}) {\n  // setup options\n  const version = isString(options.version) ? options.version : VERSION;\n  const locale = isString(options.locale) ? options.locale : 'en-US';\n  const fallbackLocale = isArray(options.fallbackLocale) || isPlainObject(options.fallbackLocale) || isString(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : locale;\n  const messages = isPlainObject(options.messages) ? options.messages : {\n    [locale]: {}\n  };\n  const datetimeFormats = isPlainObject(options.datetimeFormats) ? options.datetimeFormats : {\n    [locale]: {}\n  };\n  const numberFormats = isPlainObject(options.numberFormats) ? options.numberFormats : {\n    [locale]: {}\n  };\n  const modifiers = assign({}, options.modifiers || {}, getDefaultLinkedModifiers());\n  const pluralRules = options.pluralRules || {};\n  const missing = isFunction(options.missing) ? options.missing : null;\n  const missingWarn = isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true;\n  const fallbackWarn = isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;\n  const fallbackFormat = !!options.fallbackFormat;\n  const unresolving = !!options.unresolving;\n  const postTranslation = isFunction(options.postTranslation) ? options.postTranslation : null;\n  const processor = isPlainObject(options.processor) ? options.processor : null;\n  const warnHtmlMessage = isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;\n  const escapeParameter = !!options.escapeParameter;\n  const messageCompiler = isFunction(options.messageCompiler) ? options.messageCompiler : _compiler;\n  const onWarn = isFunction(options.onWarn) ? options.onWarn : warn; // setup internal options\n\n  const internalOptions = options;\n\n  const __datetimeFormatters = isObject(internalOptions.__datetimeFormatters) ? internalOptions.__datetimeFormatters : new Map();\n\n  const __numberFormatters = isObject(internalOptions.__numberFormatters) ? internalOptions.__numberFormatters : new Map();\n\n  const __meta = isObject(internalOptions.__meta) ? internalOptions.__meta : {};\n\n  _cid++;\n  const context = {\n    version,\n    cid: _cid,\n    locale,\n    fallbackLocale,\n    messages,\n    datetimeFormats,\n    numberFormats,\n    modifiers,\n    pluralRules,\n    missing,\n    missingWarn,\n    fallbackWarn,\n    fallbackFormat,\n    unresolving,\n    postTranslation,\n    processor,\n    warnHtmlMessage,\n    escapeParameter,\n    messageCompiler,\n    onWarn,\n    __datetimeFormatters,\n    __numberFormatters,\n    __meta\n  }; // for vue-devtools timeline event\n\n  if (process.env.NODE_ENV !== 'production') {\n    context.__v_emitter = internalOptions.__v_emitter != null ? internalOptions.__v_emitter : undefined;\n  } // NOTE: experimental !!\n\n\n  if (process.env.NODE_ENV !== 'production' || __INTLIFY_PROD_DEVTOOLS__) {\n    initI18nDevTools(context, version, __meta);\n  }\n\n  return context;\n}\n/** @internal */\n\n\nfunction isTranslateFallbackWarn(fallback, key) {\n  return fallback instanceof RegExp ? fallback.test(key) : fallback;\n}\n/** @internal */\n\n\nfunction isTranslateMissingWarn(missing, key) {\n  return missing instanceof RegExp ? missing.test(key) : missing;\n}\n/** @internal */\n\n\nfunction handleMissing(context, key, locale, missingWarn, type) {\n  const {\n    missing,\n    onWarn\n  } = context; // for vue-devtools timeline event\n\n  if (process.env.NODE_ENV !== 'production') {\n    const emitter = context.__v_emitter;\n\n    if (emitter) {\n      emitter.emit(\"missing\"\n      /* MISSING */\n      , {\n        locale,\n        key,\n        type,\n        groupId: `${type}:${key}`\n      });\n    }\n  }\n\n  if (missing !== null) {\n    const ret = missing(context, locale, key, type);\n    return isString(ret) ? ret : key;\n  } else {\n    if (process.env.NODE_ENV !== 'production' && isTranslateMissingWarn(missingWarn, key)) {\n      onWarn(getWarnMessage(0\n      /* NOT_FOUND_KEY */\n      , {\n        key,\n        locale\n      }));\n    }\n\n    return key;\n  }\n}\n/** @internal */\n\n\nfunction getLocaleChain(ctx, fallback, start) {\n  const context = ctx;\n\n  if (!context.__localeChainCache) {\n    context.__localeChainCache = new Map();\n  }\n\n  let chain = context.__localeChainCache.get(start);\n\n  if (!chain) {\n    chain = []; // first block defined by start\n\n    let block = [start]; // while any intervening block found\n\n    while (isArray(block)) {\n      block = appendBlockToChain(chain, block, fallback);\n    } // prettier-ignore\n    // last block defined by default\n\n\n    const defaults = isArray(fallback) ? fallback : isPlainObject(fallback) ? fallback['default'] ? fallback['default'] : null : fallback; // convert defaults to array\n\n    block = isString(defaults) ? [defaults] : defaults;\n\n    if (isArray(block)) {\n      appendBlockToChain(chain, block, false);\n    }\n\n    context.__localeChainCache.set(start, chain);\n  }\n\n  return chain;\n}\n\nfunction appendBlockToChain(chain, block, blocks) {\n  let follow = true;\n\n  for (let i = 0; i < block.length && isBoolean(follow); i++) {\n    const locale = block[i];\n\n    if (isString(locale)) {\n      follow = appendLocaleToChain(chain, block[i], blocks);\n    }\n  }\n\n  return follow;\n}\n\nfunction appendLocaleToChain(chain, locale, blocks) {\n  let follow;\n  const tokens = locale.split('-');\n\n  do {\n    const target = tokens.join('-');\n    follow = appendItemToChain(chain, target, blocks);\n    tokens.splice(-1, 1);\n  } while (tokens.length && follow === true);\n\n  return follow;\n}\n\nfunction appendItemToChain(chain, target, blocks) {\n  let follow = false;\n\n  if (!chain.includes(target)) {\n    follow = true;\n\n    if (target) {\n      follow = target[target.length - 1] !== '!';\n      const locale = target.replace(/!/g, '');\n      chain.push(locale);\n\n      if ((isArray(blocks) || isPlainObject(blocks)) && blocks[locale] // eslint-disable-line @typescript-eslint/no-explicit-any\n      ) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        follow = blocks[locale];\n      }\n    }\n  }\n\n  return follow;\n}\n/** @internal */\n\n\nfunction updateFallbackLocale(ctx, locale, fallback) {\n  const context = ctx;\n  context.__localeChainCache = new Map();\n  getLocaleChain(ctx, fallback, locale);\n}\n\nconst RE_HTML_TAG = /<\\/?[\\w\\s=\"/.':;#-\\/]+>/;\nconst WARN_MESSAGE = `Detected HTML in '{source}' message. Recommend not using HTML messages to avoid XSS.`;\n\nfunction checkHtmlMessage(source, options) {\n  const warnHtmlMessage = isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;\n\n  if (warnHtmlMessage && RE_HTML_TAG.test(source)) {\n    warn(format(WARN_MESSAGE, {\n      source\n    }));\n  }\n}\n\nconst defaultOnCacheKey = source => source;\n\nlet compileCache = Object.create(null);\n\nfunction clearCompileCache() {\n  compileCache = Object.create(null);\n}\n\nfunction compileToFunction(source, options = {}) {\n  {\n    // check HTML message\n    process.env.NODE_ENV !== 'production' && checkHtmlMessage(source, options); // check caches\n\n    const onCacheKey = options.onCacheKey || defaultOnCacheKey;\n    const key = onCacheKey(source);\n    const cached = compileCache[key];\n\n    if (cached) {\n      return cached;\n    } // compile error detecting\n\n\n    let occurred = false;\n    const onError = options.onError || defaultOnError;\n\n    options.onError = err => {\n      occurred = true;\n      onError(err);\n    }; // compile\n\n\n    const {\n      code\n    } = baseCompile(source, options); // evaluate function\n\n    const msg = new Function(`return ${code}`)(); // if occurred compile error, don't cache\n\n    return !occurred ? compileCache[key] = msg : msg;\n  }\n}\n\nfunction createCoreError(code) {\n  return createCompileError(code, null, process.env.NODE_ENV !== 'production' ? {\n    messages: errorMessages\n  } : undefined);\n}\n/** @internal */\n\n\nconst errorMessages = {\n  [14\n  /* INVALID_ARGUMENT */\n  ]: 'Invalid arguments',\n  [15\n  /* INVALID_DATE_ARGUMENT */\n  ]: 'The date provided is an invalid Date object.' + 'Make sure your Date represents a valid date.',\n  [16\n  /* INVALID_ISO_DATE_ARGUMENT */\n  ]: 'The argument provided is not a valid ISO date string'\n};\n\nconst NOOP_MESSAGE_FUNCTION = () => '';\n\nconst isMessageFunction = val => isFunction(val); // implementation of `translate` function\n\n\nfunction translate(context, ...args) {\n  const {\n    fallbackFormat,\n    postTranslation,\n    unresolving,\n    fallbackLocale,\n    messages\n  } = context;\n  const [key, options] = parseTranslateArgs(...args);\n  const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;\n  const fallbackWarn = isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;\n  const escapeParameter = isBoolean(options.escapeParameter) ? options.escapeParameter : context.escapeParameter;\n  const resolvedMessage = !!options.resolvedMessage; // prettier-ignore\n\n  const defaultMsgOrKey = isString(options.default) || isBoolean(options.default) // default by function option\n  ? !isBoolean(options.default) ? options.default : key : fallbackFormat // default by `fallbackFormat` option\n  ? key : '';\n  const enableDefaultMsg = fallbackFormat || defaultMsgOrKey !== '';\n  const locale = isString(options.locale) ? options.locale : context.locale; // escape params\n\n  escapeParameter && escapeParams(options); // resolve message format\n  // eslint-disable-next-line prefer-const\n\n  let [format, targetLocale, message] = !resolvedMessage ? resolveMessageFormat(context, key, locale, fallbackLocale, fallbackWarn, missingWarn) : [key, locale, messages[locale] || {}]; // if you use default message, set it as message format!\n\n  let cacheBaseKey = key;\n\n  if (!resolvedMessage && !(isString(format) || isMessageFunction(format))) {\n    if (enableDefaultMsg) {\n      format = defaultMsgOrKey;\n      cacheBaseKey = format;\n    }\n  } // checking message format and target locale\n\n\n  if (!resolvedMessage && (!(isString(format) || isMessageFunction(format)) || !isString(targetLocale))) {\n    return unresolving ? NOT_REOSLVED : key;\n  }\n\n  if (process.env.NODE_ENV !== 'production' && isString(format) && context.messageCompiler == null) {\n    warn(`The message format compilation is not supported in this build. ` + `Because message compiler isn't included. ` + `You need to pre-compilation all message format. ` + `So translate function return '${key}'.`);\n    return key;\n  } // setup compile error detecting\n\n\n  let occurred = false;\n\n  const errorDetector = () => {\n    occurred = true;\n  }; // compile message format\n\n\n  const msg = !isMessageFunction(format) ? compileMessageFormat(context, key, targetLocale, format, cacheBaseKey, errorDetector) : format; // if occurred compile error, return the message format\n\n  if (occurred) {\n    return format;\n  } // evaluate message with context\n\n\n  const ctxOptions = getMessageContextOptions(context, targetLocale, message, options);\n  const msgContext = createMessageContext(ctxOptions);\n  const messaged = evaluateMessage(context, msg, msgContext); // if use post translation option, proceed it with handler\n\n  const ret = postTranslation ? postTranslation(messaged) : messaged; // NOTE: experimental !!\n\n  if (process.env.NODE_ENV !== 'production' || __INTLIFY_PROD_DEVTOOLS__) {\n    // prettier-ignore\n    const payloads = {\n      timestamp: Date.now(),\n      key: isString(key) ? key : isMessageFunction(format) ? format.key : '',\n      locale: targetLocale || (isMessageFunction(format) ? format.locale : ''),\n      format: isString(format) ? format : isMessageFunction(format) ? format.source : '',\n      message: ret\n    };\n    payloads.meta = assign({}, context.__meta, getAdditionalMeta() || {});\n    translateDevTools(payloads);\n  }\n\n  return ret;\n}\n\nfunction escapeParams(options) {\n  if (isArray(options.list)) {\n    options.list = options.list.map(item => isString(item) ? escapeHtml(item) : item);\n  } else if (isObject(options.named)) {\n    Object.keys(options.named).forEach(key => {\n      if (isString(options.named[key])) {\n        options.named[key] = escapeHtml(options.named[key]);\n      }\n    });\n  }\n}\n\nfunction resolveMessageFormat(context, key, locale, fallbackLocale, fallbackWarn, missingWarn) {\n  const {\n    messages,\n    onWarn\n  } = context;\n  const locales = getLocaleChain(context, fallbackLocale, locale);\n  let message = {};\n  let targetLocale;\n  let format = null;\n  let from = locale;\n  let to = null;\n  const type = 'translate';\n\n  for (let i = 0; i < locales.length; i++) {\n    targetLocale = to = locales[i];\n\n    if (process.env.NODE_ENV !== 'production' && locale !== targetLocale && isTranslateFallbackWarn(fallbackWarn, key)) {\n      onWarn(getWarnMessage(1\n      /* FALLBACK_TO_TRANSLATE */\n      , {\n        key,\n        target: targetLocale\n      }));\n    } // for vue-devtools timeline event\n\n\n    if (process.env.NODE_ENV !== 'production' && locale !== targetLocale) {\n      const emitter = context.__v_emitter;\n\n      if (emitter) {\n        emitter.emit(\"fallback\"\n        /* FALBACK */\n        , {\n          type,\n          key,\n          from,\n          to,\n          groupId: `${type}:${key}`\n        });\n      }\n    }\n\n    message = messages[targetLocale] || {}; // for vue-devtools timeline event\n\n    let start = null;\n    let startTag;\n    let endTag;\n\n    if (process.env.NODE_ENV !== 'production' && inBrowser) {\n      start = window.performance.now();\n      startTag = 'intlify-message-resolve-start';\n      endTag = 'intlify-message-resolve-end';\n      mark && mark(startTag);\n    }\n\n    if ((format = resolveValue(message, key)) === null) {\n      // if null, resolve with object key path\n      format = message[key]; // eslint-disable-line @typescript-eslint/no-explicit-any\n    } // for vue-devtools timeline event\n\n\n    if (process.env.NODE_ENV !== 'production' && inBrowser) {\n      const end = window.performance.now();\n      const emitter = context.__v_emitter;\n\n      if (emitter && start && format) {\n        emitter.emit(\"message-resolve\"\n        /* MESSAGE_RESOLVE */\n        , {\n          type: \"message-resolve\"\n          /* MESSAGE_RESOLVE */\n          ,\n          key,\n          message: format,\n          time: end - start,\n          groupId: `${type}:${key}`\n        });\n      }\n\n      if (startTag && endTag && mark && measure) {\n        mark(endTag);\n        measure('intlify message resolve', startTag, endTag);\n      }\n    }\n\n    if (isString(format) || isFunction(format)) break;\n    const missingRet = handleMissing(context, key, targetLocale, missingWarn, type);\n\n    if (missingRet !== key) {\n      format = missingRet;\n    }\n\n    from = to;\n  }\n\n  return [format, targetLocale, message];\n}\n\nfunction compileMessageFormat(context, key, targetLocale, format, cacheBaseKey, errorDetector) {\n  const {\n    messageCompiler,\n    warnHtmlMessage\n  } = context;\n\n  if (isMessageFunction(format)) {\n    const msg = format;\n    msg.locale = msg.locale || targetLocale;\n    msg.key = msg.key || key;\n    return msg;\n  } // for vue-devtools timeline event\n\n\n  let start = null;\n  let startTag;\n  let endTag;\n\n  if (process.env.NODE_ENV !== 'production' && inBrowser) {\n    start = window.performance.now();\n    startTag = 'intlify-message-compilation-start';\n    endTag = 'intlify-message-compilation-end';\n    mark && mark(startTag);\n  }\n\n  const msg = messageCompiler(format, getCompileOptions(context, targetLocale, cacheBaseKey, format, warnHtmlMessage, errorDetector)); // for vue-devtools timeline event\n\n  if (process.env.NODE_ENV !== 'production' && inBrowser) {\n    const end = window.performance.now();\n    const emitter = context.__v_emitter;\n\n    if (emitter && start) {\n      emitter.emit(\"message-compilation\"\n      /* MESSAGE_COMPILATION */\n      , {\n        type: \"message-compilation\"\n        /* MESSAGE_COMPILATION */\n        ,\n        message: format,\n        time: end - start,\n        groupId: `${'translate'}:${key}`\n      });\n    }\n\n    if (startTag && endTag && mark && measure) {\n      mark(endTag);\n      measure('intlify message compilation', startTag, endTag);\n    }\n  }\n\n  msg.locale = targetLocale;\n  msg.key = key;\n  msg.source = format;\n  return msg;\n}\n\nfunction evaluateMessage(context, msg, msgCtx) {\n  // for vue-devtools timeline event\n  let start = null;\n  let startTag;\n  let endTag;\n\n  if (process.env.NODE_ENV !== 'production' && inBrowser) {\n    start = window.performance.now();\n    startTag = 'intlify-message-evaluation-start';\n    endTag = 'intlify-message-evaluation-end';\n    mark && mark(startTag);\n  }\n\n  const messaged = msg(msgCtx); // for vue-devtools timeline event\n\n  if (process.env.NODE_ENV !== 'production' && inBrowser) {\n    const end = window.performance.now();\n    const emitter = context.__v_emitter;\n\n    if (emitter && start) {\n      emitter.emit(\"message-evaluation\"\n      /* MESSAGE_EVALUATION */\n      , {\n        type: \"message-evaluation\"\n        /* MESSAGE_EVALUATION */\n        ,\n        value: messaged,\n        time: end - start,\n        groupId: `${'translate'}:${msg.key}`\n      });\n    }\n\n    if (startTag && endTag && mark && measure) {\n      mark(endTag);\n      measure('intlify message evaluation', startTag, endTag);\n    }\n  }\n\n  return messaged;\n}\n/** @internal */\n\n\nfunction parseTranslateArgs(...args) {\n  const [arg1, arg2, arg3] = args;\n  const options = {};\n\n  if (!isString(arg1) && !isNumber(arg1) && !isMessageFunction(arg1)) {\n    throw createCoreError(14\n    /* INVALID_ARGUMENT */\n    );\n  } // prettier-ignore\n\n\n  const key = isNumber(arg1) ? String(arg1) : isMessageFunction(arg1) ? arg1 : arg1;\n\n  if (isNumber(arg2)) {\n    options.plural = arg2;\n  } else if (isString(arg2)) {\n    options.default = arg2;\n  } else if (isPlainObject(arg2) && !isEmptyObject(arg2)) {\n    options.named = arg2;\n  } else if (isArray(arg2)) {\n    options.list = arg2;\n  }\n\n  if (isNumber(arg3)) {\n    options.plural = arg3;\n  } else if (isString(arg3)) {\n    options.default = arg3;\n  } else if (isPlainObject(arg3)) {\n    assign(options, arg3);\n  }\n\n  return [key, options];\n}\n\nfunction getCompileOptions(context, locale, key, source, warnHtmlMessage, errorDetector) {\n  return {\n    warnHtmlMessage,\n    onError: err => {\n      errorDetector && errorDetector(err);\n\n      if (process.env.NODE_ENV !== 'production') {\n        const message = `Message compilation error: ${err.message}`;\n        const codeFrame = err.location && generateCodeFrame(source, err.location.start.offset, err.location.end.offset);\n        const emitter = context.__v_emitter;\n\n        if (emitter) {\n          emitter.emit(\"compile-error\"\n          /* COMPILE_ERROR */\n          , {\n            message: source,\n            error: err.message,\n            start: err.location && err.location.start.offset,\n            end: err.location && err.location.end.offset,\n            groupId: `${'translate'}:${key}`\n          });\n        }\n\n        console.error(codeFrame ? `${message}\\n${codeFrame}` : message);\n      } else {\n        throw err;\n      }\n    },\n    onCacheKey: source => generateFormatCacheKey(locale, key, source)\n  };\n}\n\nfunction getMessageContextOptions(context, locale, message, options) {\n  const {\n    modifiers,\n    pluralRules\n  } = context;\n\n  const resolveMessage = key => {\n    const val = resolveValue(message, key);\n\n    if (isString(val)) {\n      let occurred = false;\n\n      const errorDetector = () => {\n        occurred = true;\n      };\n\n      const msg = compileMessageFormat(context, key, locale, val, key, errorDetector);\n      return !occurred ? msg : NOOP_MESSAGE_FUNCTION;\n    } else if (isMessageFunction(val)) {\n      return val;\n    } else {\n      // TODO: should be implemented warning message\n      return NOOP_MESSAGE_FUNCTION;\n    }\n  };\n\n  const ctxOptions = {\n    locale,\n    modifiers,\n    pluralRules,\n    messages: resolveMessage\n  };\n\n  if (context.processor) {\n    ctxOptions.processor = context.processor;\n  }\n\n  if (options.list) {\n    ctxOptions.list = options.list;\n  }\n\n  if (options.named) {\n    ctxOptions.named = options.named;\n  }\n\n  if (isNumber(options.plural)) {\n    ctxOptions.pluralIndex = options.plural;\n  }\n\n  return ctxOptions;\n}\n\nconst intlDefined = typeof Intl !== 'undefined';\nconst Availabilities = {\n  dateTimeFormat: intlDefined && typeof Intl.DateTimeFormat !== 'undefined',\n  numberFormat: intlDefined && typeof Intl.NumberFormat !== 'undefined'\n}; // implementation of `datetime` function\n\nfunction datetime(context, ...args) {\n  const {\n    datetimeFormats,\n    unresolving,\n    fallbackLocale,\n    onWarn\n  } = context;\n  const {\n    __datetimeFormatters\n  } = context;\n\n  if (process.env.NODE_ENV !== 'production' && !Availabilities.dateTimeFormat) {\n    onWarn(getWarnMessage(4\n    /* CANNOT_FORMAT_DATE */\n    ));\n    return MISSING_RESOLVE_VALUE;\n  }\n\n  const [key, value, options, overrides] = parseDateTimeArgs(...args);\n  const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;\n  const fallbackWarn = isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;\n  const part = !!options.part;\n  const locale = isString(options.locale) ? options.locale : context.locale;\n  const locales = getLocaleChain(context, fallbackLocale, locale);\n\n  if (!isString(key) || key === '') {\n    return new Intl.DateTimeFormat(locale).format(value);\n  } // resolve format\n\n\n  let datetimeFormat = {};\n  let targetLocale;\n  let format = null;\n  let from = locale;\n  let to = null;\n  const type = 'datetime format';\n\n  for (let i = 0; i < locales.length; i++) {\n    targetLocale = to = locales[i];\n\n    if (process.env.NODE_ENV !== 'production' && locale !== targetLocale && isTranslateFallbackWarn(fallbackWarn, key)) {\n      onWarn(getWarnMessage(5\n      /* FALLBACK_TO_DATE_FORMAT */\n      , {\n        key,\n        target: targetLocale\n      }));\n    } // for vue-devtools timeline event\n\n\n    if (process.env.NODE_ENV !== 'production' && locale !== targetLocale) {\n      const emitter = context.__v_emitter;\n\n      if (emitter) {\n        emitter.emit(\"fallback\"\n        /* FALBACK */\n        , {\n          type,\n          key,\n          from,\n          to,\n          groupId: `${type}:${key}`\n        });\n      }\n    }\n\n    datetimeFormat = datetimeFormats[targetLocale] || {};\n    format = datetimeFormat[key];\n    if (isPlainObject(format)) break;\n    handleMissing(context, key, targetLocale, missingWarn, type);\n    from = to;\n  } // checking format and target locale\n\n\n  if (!isPlainObject(format) || !isString(targetLocale)) {\n    return unresolving ? NOT_REOSLVED : key;\n  }\n\n  let id = `${targetLocale}__${key}`;\n\n  if (!isEmptyObject(overrides)) {\n    id = `${id}__${JSON.stringify(overrides)}`;\n  }\n\n  let formatter = __datetimeFormatters.get(id);\n\n  if (!formatter) {\n    formatter = new Intl.DateTimeFormat(targetLocale, assign({}, format, overrides));\n\n    __datetimeFormatters.set(id, formatter);\n  }\n\n  return !part ? formatter.format(value) : formatter.formatToParts(value);\n}\n/** @internal */\n\n\nfunction parseDateTimeArgs(...args) {\n  const [arg1, arg2, arg3, arg4] = args;\n  let options = {};\n  let overrides = {};\n  let value;\n\n  if (isString(arg1)) {\n    // Only allow ISO strings - other date formats are often supported,\n    // but may cause different results in different browsers.\n    if (!/\\d{4}-\\d{2}-\\d{2}(T.*)?/.test(arg1)) {\n      throw createCoreError(16\n      /* INVALID_ISO_DATE_ARGUMENT */\n      );\n    }\n\n    value = new Date(arg1);\n\n    try {\n      // This will fail if the date is not valid\n      value.toISOString();\n    } catch (e) {\n      throw createCoreError(16\n      /* INVALID_ISO_DATE_ARGUMENT */\n      );\n    }\n  } else if (isDate(arg1)) {\n    if (isNaN(arg1.getTime())) {\n      throw createCoreError(15\n      /* INVALID_DATE_ARGUMENT */\n      );\n    }\n\n    value = arg1;\n  } else if (isNumber(arg1)) {\n    value = arg1;\n  } else {\n    throw createCoreError(14\n    /* INVALID_ARGUMENT */\n    );\n  }\n\n  if (isString(arg2)) {\n    options.key = arg2;\n  } else if (isPlainObject(arg2)) {\n    options = arg2;\n  }\n\n  if (isString(arg3)) {\n    options.locale = arg3;\n  } else if (isPlainObject(arg3)) {\n    overrides = arg3;\n  }\n\n  if (isPlainObject(arg4)) {\n    overrides = arg4;\n  }\n\n  return [options.key || '', value, options, overrides];\n}\n/** @internal */\n\n\nfunction clearDateTimeFormat(ctx, locale, format) {\n  const context = ctx;\n\n  for (const key in format) {\n    const id = `${locale}__${key}`;\n\n    if (!context.__datetimeFormatters.has(id)) {\n      continue;\n    }\n\n    context.__datetimeFormatters.delete(id);\n  }\n} // implementation of `number` function\n\n\nfunction number(context, ...args) {\n  const {\n    numberFormats,\n    unresolving,\n    fallbackLocale,\n    onWarn\n  } = context;\n  const {\n    __numberFormatters\n  } = context;\n\n  if (process.env.NODE_ENV !== 'production' && !Availabilities.numberFormat) {\n    onWarn(getWarnMessage(2\n    /* CANNOT_FORMAT_NUMBER */\n    ));\n    return MISSING_RESOLVE_VALUE;\n  }\n\n  const [key, value, options, overrides] = parseNumberArgs(...args);\n  const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;\n  const fallbackWarn = isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;\n  const part = !!options.part;\n  const locale = isString(options.locale) ? options.locale : context.locale;\n  const locales = getLocaleChain(context, fallbackLocale, locale);\n\n  if (!isString(key) || key === '') {\n    return new Intl.NumberFormat(locale).format(value);\n  } // resolve format\n\n\n  let numberFormat = {};\n  let targetLocale;\n  let format = null;\n  let from = locale;\n  let to = null;\n  const type = 'number format';\n\n  for (let i = 0; i < locales.length; i++) {\n    targetLocale = to = locales[i];\n\n    if (process.env.NODE_ENV !== 'production' && locale !== targetLocale && isTranslateFallbackWarn(fallbackWarn, key)) {\n      onWarn(getWarnMessage(3\n      /* FALLBACK_TO_NUMBER_FORMAT */\n      , {\n        key,\n        target: targetLocale\n      }));\n    } // for vue-devtools timeline event\n\n\n    if (process.env.NODE_ENV !== 'production' && locale !== targetLocale) {\n      const emitter = context.__v_emitter;\n\n      if (emitter) {\n        emitter.emit(\"fallback\"\n        /* FALBACK */\n        , {\n          type,\n          key,\n          from,\n          to,\n          groupId: `${type}:${key}`\n        });\n      }\n    }\n\n    numberFormat = numberFormats[targetLocale] || {};\n    format = numberFormat[key];\n    if (isPlainObject(format)) break;\n    handleMissing(context, key, targetLocale, missingWarn, type);\n    from = to;\n  } // checking format and target locale\n\n\n  if (!isPlainObject(format) || !isString(targetLocale)) {\n    return unresolving ? NOT_REOSLVED : key;\n  }\n\n  let id = `${targetLocale}__${key}`;\n\n  if (!isEmptyObject(overrides)) {\n    id = `${id}__${JSON.stringify(overrides)}`;\n  }\n\n  let formatter = __numberFormatters.get(id);\n\n  if (!formatter) {\n    formatter = new Intl.NumberFormat(targetLocale, assign({}, format, overrides));\n\n    __numberFormatters.set(id, formatter);\n  }\n\n  return !part ? formatter.format(value) : formatter.formatToParts(value);\n}\n/** @internal */\n\n\nfunction parseNumberArgs(...args) {\n  const [arg1, arg2, arg3, arg4] = args;\n  let options = {};\n  let overrides = {};\n\n  if (!isNumber(arg1)) {\n    throw createCoreError(14\n    /* INVALID_ARGUMENT */\n    );\n  }\n\n  const value = arg1;\n\n  if (isString(arg2)) {\n    options.key = arg2;\n  } else if (isPlainObject(arg2)) {\n    options = arg2;\n  }\n\n  if (isString(arg3)) {\n    options.locale = arg3;\n  } else if (isPlainObject(arg3)) {\n    overrides = arg3;\n  }\n\n  if (isPlainObject(arg4)) {\n    overrides = arg4;\n  }\n\n  return [options.key || '', value, options, overrides];\n}\n/** @internal */\n\n\nfunction clearNumberFormat(ctx, locale, format) {\n  const context = ctx;\n\n  for (const key in format) {\n    const id = `${locale}__${key}`;\n\n    if (!context.__numberFormatters.has(id)) {\n      continue;\n    }\n\n    context.__numberFormatters.delete(id);\n  }\n}\n\n{\n  if (typeof __INTLIFY_PROD_DEVTOOLS__ !== 'boolean') {\n    getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = false;\n  }\n}\nexport { MISSING_RESOLVE_VALUE, NOT_REOSLVED, VERSION, clearCompileCache, clearDateTimeFormat, clearNumberFormat, compileToFunction, createCoreContext, createCoreError, datetime, getAdditionalMeta, getDevToolsHook, getLocaleChain, getWarnMessage, handleMissing, initI18nDevTools, isMessageFunction, isTranslateFallbackWarn, isTranslateMissingWarn, number, parseDateTimeArgs, parseNumberArgs, parseTranslateArgs, registerMessageCompiler, setAdditionalMeta, setDevToolsHook, translate, translateDevTools, updateFallbackLocale };","map":null,"metadata":{},"sourceType":"module"}