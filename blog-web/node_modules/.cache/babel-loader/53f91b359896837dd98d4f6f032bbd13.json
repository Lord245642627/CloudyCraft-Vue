{"ast":null,"code":"/*!\n * vue3-lazy v1.0.0-alpha.1\n * (c) 2020-2020 ustbhuangyi\n * Released under the MIT License.\n */\nvar State;\n\n(function (State) {\n  State[State[\"loading\"] = 0] = \"loading\";\n  State[State[\"loaded\"] = 1] = \"loaded\";\n  State[State[\"error\"] = 2] = \"error\";\n})(State || (State = {}));\n\nvar inBrowser = typeof window !== 'undefined';\nvar hasIntersectionObserver = checkIntersectionObserver();\n\nfunction checkIntersectionObserver() {\n  if (inBrowser && 'IntersectionObserver' in window && 'IntersectionObserverEntry' in window && 'intersectionRatio' in IntersectionObserverEntry.prototype) {\n    // Minimal polyfill for Edge 15's lack of `isIntersecting`\n    // See: https://github.com/w3c/IntersectionObserver/issues/211\n    if (!('isIntersecting' in IntersectionObserverEntry.prototype)) {\n      Object.defineProperty(IntersectionObserverEntry.prototype, 'isIntersecting', {\n        get: function () {\n          return this.intersectionRatio > 0;\n        }\n      });\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nvar style = function (el, prop) {\n  return getComputedStyle(el).getPropertyValue(prop);\n};\n\nvar overflow = function (el) {\n  return style(el, 'overflow') + style(el, 'overflow-y') + style(el, 'overflow-x');\n};\n\nfunction scrollParent(el) {\n  var parent = el;\n\n  while (parent) {\n    if (parent === document.body || parent === document.documentElement) {\n      break;\n    }\n\n    if (!parent.parentNode) {\n      break;\n    }\n\n    if (/(scroll|auto)/.test(overflow(parent))) {\n      return parent;\n    }\n\n    parent = parent.parentNode;\n  }\n\n  return window;\n}\n\nfunction loadImage(src) {\n  return new Promise(function (resolve, reject) {\n    var image = new Image();\n\n    image.onload = function () {\n      resolve();\n      dispose();\n    };\n\n    image.onerror = function (e) {\n      reject(e);\n      dispose();\n    };\n\n    image.src = src;\n\n    function dispose() {\n      image.onload = image.onerror = null;\n    }\n  });\n}\n\nfunction warn(msg) {\n  console.warn(\"[Vue3-lazy warn]: \" + msg);\n}\n\nvar ImageManager =\n/** @class */\nfunction () {\n  function ImageManager(options) {\n    this.el = options.el;\n    this.parent = options.parent;\n    this.src = options.src;\n    this.error = options.error;\n    this.loading = options.loading;\n    this.cache = options.cache;\n    this.state = State.loading;\n    this.render(this.loading);\n  }\n\n  ImageManager.prototype.load = function (next) {\n    if (this.state > State.loading) {\n      return;\n    }\n\n    if (this.cache.has(this.src)) {\n      this.state = State.loaded;\n      this.render(this.src);\n      return;\n    }\n\n    this.renderSrc(next);\n  };\n\n  ImageManager.prototype.isInView = function () {\n    var rect = this.el.getBoundingClientRect();\n    return rect.top < window.innerHeight && rect.left < window.innerWidth;\n  };\n\n  ImageManager.prototype.update = function (src) {\n    var currentSrc = this.src;\n\n    if (src !== currentSrc) {\n      this.src = src;\n      this.state = State.loading;\n    }\n  };\n\n  ImageManager.prototype.renderSrc = function (next) {\n    var _this = this;\n\n    loadImage(this.src).then(function () {\n      _this.state = State.loaded;\n\n      _this.render(_this.src);\n\n      _this.cache.add(_this.src);\n\n      next && next();\n    }).catch(function (e) {\n      _this.state = State.error;\n\n      _this.render(_this.error);\n\n      warn(\"load failed with src image(\" + _this.src + \") and the error msg is \" + e.message);\n      next && next();\n    });\n  };\n\n  ImageManager.prototype.render = function (src) {\n    this.el.setAttribute('src', src);\n  };\n\n  return ImageManager;\n}();\n\nfunction throttle(fn, delay) {\n  var timeout = 0;\n  var lastRun = 0;\n  return function () {\n    if (timeout) {\n      return;\n    }\n\n    var elapsed = Date.now() - lastRun;\n    var context = this;\n    var args = arguments;\n\n    var runCallback = function () {\n      lastRun = Date.now();\n      timeout = 0;\n      fn.apply(context, args);\n    };\n\n    if (elapsed >= delay) {\n      runCallback();\n    } else {\n      timeout = window.setTimeout(runCallback, delay);\n    }\n  };\n}\n\nvar DEFAULT_URL = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';\nvar events = ['scroll', 'wheel', 'mousewheel', 'resize', 'animationend', 'transitionend', 'touchmove', 'transitioncancel'];\nvar THROTTLE_DELAY = 300;\n\nvar Lazy =\n/** @class */\nfunction () {\n  function Lazy(options) {\n    this.error = options.error || DEFAULT_URL;\n    this.loading = options.loading || DEFAULT_URL;\n    this.cache = new Set();\n    this.managerQueue = [];\n    this.throttleLazyHandler = throttle(this.lazyHandler.bind(this), THROTTLE_DELAY);\n    this.init();\n  }\n\n  Lazy.prototype.add = function (el, binding) {\n    var src = binding.value;\n    var parent = scrollParent(el);\n    var manager = new ImageManager({\n      el: el,\n      parent: parent,\n      src: src,\n      error: this.error,\n      loading: this.loading,\n      cache: this.cache\n    });\n    this.managerQueue.push(manager);\n\n    if (hasIntersectionObserver) {\n      this.observer.observe(el);\n    } else {\n      this.addListenerTarget(parent);\n      this.addListenerTarget(window);\n      this.throttleLazyHandler();\n    }\n  };\n\n  Lazy.prototype.update = function (el, binding) {\n    var src = binding.value;\n    var manager = this.managerQueue.find(function (manager) {\n      return manager.el === el;\n    });\n\n    if (manager) {\n      manager.update(src);\n    }\n  };\n\n  Lazy.prototype.remove = function (el) {\n    var manager = this.managerQueue.find(function (manager) {\n      return manager.el === el;\n    });\n\n    if (manager) {\n      this.removeManager(manager);\n    }\n  };\n\n  Lazy.prototype.init = function () {\n    if (hasIntersectionObserver) {\n      this.initIntersectionObserver();\n    } else {\n      this.targetQueue = [];\n    }\n  };\n\n  Lazy.prototype.initIntersectionObserver = function () {\n    var _this = this;\n\n    this.observer = new IntersectionObserver(function (entries) {\n      entries.forEach(function (entry) {\n        if (entry.isIntersecting) {\n          var manager = _this.managerQueue.find(function (manager) {\n            return manager.el === entry.target;\n          });\n\n          if (manager) {\n            if (manager.state === State.loaded) {\n              _this.removeManager(manager);\n\n              return;\n            }\n\n            manager.load();\n          }\n        }\n      });\n    }, {\n      rootMargin: '0px',\n      threshold: 0\n    });\n  };\n\n  Lazy.prototype.addListenerTarget = function (el) {\n    var target = this.targetQueue.find(function (target) {\n      return target.el === el;\n    });\n\n    if (!target) {\n      target = {\n        el: el,\n        ref: 1\n      };\n      this.targetQueue.push(target);\n      this.addListener(el);\n    } else {\n      target.ref++;\n    }\n  };\n\n  Lazy.prototype.removeListenerTarget = function (el) {\n    var _this = this;\n\n    this.targetQueue.some(function (target, index) {\n      if (el === target.el) {\n        target.ref--;\n\n        if (!target.ref) {\n          _this.removeListener(el);\n\n          _this.targetQueue.splice(index, 1);\n        }\n\n        return true;\n      }\n\n      return false;\n    });\n  };\n\n  Lazy.prototype.addListener = function (el) {\n    var _this = this;\n\n    events.forEach(function (event) {\n      el.addEventListener(event, _this.throttleLazyHandler, {\n        passive: true,\n        capture: false\n      });\n    });\n  };\n\n  Lazy.prototype.removeListener = function (el) {\n    var _this = this;\n\n    events.forEach(function (event) {\n      el.removeEventListener(event, _this.throttleLazyHandler);\n    });\n  };\n\n  Lazy.prototype.lazyHandler = function (e) {\n    for (var i = this.managerQueue.length - 1; i >= 0; i--) {\n      var manager = this.managerQueue[i];\n\n      if (manager.isInView()) {\n        if (manager.state === State.loaded) {\n          this.removeManager(manager);\n          return;\n        }\n\n        manager.load();\n      }\n    }\n  };\n\n  Lazy.prototype.removeManager = function (manager) {\n    var index = this.managerQueue.indexOf(manager);\n\n    if (index > -1) {\n      this.managerQueue.splice(index, 1);\n    }\n\n    if (this.observer) {\n      this.observer.unobserve(manager.el);\n    } else {\n      this.removeListenerTarget(manager.parent);\n      this.removeListenerTarget(window);\n    }\n  };\n\n  return Lazy;\n}();\n\nvar lazyPlugin = {\n  install: function (app, options) {\n    var lazy = new Lazy(options);\n    app.directive('lazy', {\n      mounted: lazy.add.bind(lazy),\n      updated: lazy.update.bind(lazy),\n      unmounted: lazy.update.bind(lazy)\n    });\n  }\n};\nexport default lazyPlugin;","map":null,"metadata":{},"sourceType":"module"}