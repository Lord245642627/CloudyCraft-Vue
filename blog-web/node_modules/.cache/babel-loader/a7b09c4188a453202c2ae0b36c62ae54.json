{"ast":null,"code":"import { ref, computed, unref, watch } from 'vue';\n\nconst useData = (props, {\n  expandedRowKeys,\n  lastRenderedRowIndex,\n  resetAfterIndex\n}) => {\n  const depthMap = ref({});\n  const flattenedData = computed(() => {\n    const depths = {};\n    const {\n      data: data2,\n      rowKey\n    } = props;\n\n    const _expandedRowKeys = unref(expandedRowKeys);\n\n    if (!_expandedRowKeys || !_expandedRowKeys.length) return data2;\n    const array = [];\n    const keysSet = /* @__PURE__ */new Set();\n\n    _expandedRowKeys.forEach(x => keysSet.add(x));\n\n    let copy = data2.slice();\n    copy.forEach(x => depths[x[rowKey]] = 0);\n\n    while (copy.length > 0) {\n      const item = copy.shift();\n      array.push(item);\n\n      if (keysSet.has(item[rowKey]) && Array.isArray(item.children) && item.children.length > 0) {\n        copy = [...item.children, ...copy];\n        item.children.forEach(child => depths[child[rowKey]] = depths[item[rowKey]] + 1);\n      }\n    }\n\n    depthMap.value = depths;\n    return array;\n  });\n  const data = computed(() => {\n    const {\n      data: data2,\n      expandColumnKey\n    } = props;\n    return expandColumnKey ? unref(flattenedData) : data2;\n  });\n  watch(data, (val, prev) => {\n    if (val !== prev) {\n      lastRenderedRowIndex.value = -1;\n      resetAfterIndex(0, true);\n    }\n  });\n  return {\n    data,\n    depthMap\n  };\n};\n\nexport { useData };","map":null,"metadata":{},"sourceType":"module"}