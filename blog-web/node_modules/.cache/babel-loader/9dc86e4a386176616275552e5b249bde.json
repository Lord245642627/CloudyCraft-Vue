{"ast":null,"code":"import { rectToClientRect as t, computePosition as e } from \"@floating-ui/core\";\nexport { arrow, autoPlacement, detectOverflow, flip, hide, inline, limitShift, offset, shift, size } from \"@floating-ui/core\";\n\nfunction n(t) {\n  return t && t.document && t.location && t.alert && t.setInterval;\n}\n\nfunction o(t) {\n  if (null == t) return window;\n\n  if (!n(t)) {\n    const e = t.ownerDocument;\n    return e && e.defaultView || window;\n  }\n\n  return t;\n}\n\nfunction i(t) {\n  return o(t).getComputedStyle(t);\n}\n\nfunction r(t) {\n  return n(t) ? \"\" : t ? (t.nodeName || \"\").toLowerCase() : \"\";\n}\n\nfunction l() {\n  const t = navigator.userAgentData;\n  return null != t && t.brands ? t.brands.map(t => t.brand + \"/\" + t.version).join(\" \") : navigator.userAgent;\n}\n\nfunction c(t) {\n  return t instanceof o(t).HTMLElement;\n}\n\nfunction f(t) {\n  return t instanceof o(t).Element;\n}\n\nfunction s(t) {\n  if (\"undefined\" == typeof ShadowRoot) return !1;\n  return t instanceof o(t).ShadowRoot || t instanceof ShadowRoot;\n}\n\nfunction u(t) {\n  const {\n    overflow: e,\n    overflowX: n,\n    overflowY: o\n  } = i(t);\n  return /auto|scroll|overlay|hidden/.test(e + o + n);\n}\n\nfunction d(t) {\n  return [\"table\", \"td\", \"th\"].includes(r(t));\n}\n\nfunction h(t) {\n  const e = /firefox/i.test(l()),\n        n = i(t);\n  return \"none\" !== n.transform || \"none\" !== n.perspective || \"paint\" === n.contain || [\"transform\", \"perspective\"].includes(n.willChange) || e && \"filter\" === n.willChange || e && !!n.filter && \"none\" !== n.filter;\n}\n\nfunction a() {\n  return !/^((?!chrome|android).)*safari/i.test(l());\n}\n\nconst g = Math.min,\n      p = Math.max,\n      m = Math.round;\n\nfunction w(t, e, n) {\n  var i, r, l, s;\n  void 0 === e && (e = !1), void 0 === n && (n = !1);\n  const u = t.getBoundingClientRect();\n  let d = 1,\n      h = 1;\n  e && c(t) && (d = t.offsetWidth > 0 && m(u.width) / t.offsetWidth || 1, h = t.offsetHeight > 0 && m(u.height) / t.offsetHeight || 1);\n  const g = f(t) ? o(t) : window,\n        p = !a() && n,\n        w = (u.left + (p && null != (i = null == (r = g.visualViewport) ? void 0 : r.offsetLeft) ? i : 0)) / d,\n        v = (u.top + (p && null != (l = null == (s = g.visualViewport) ? void 0 : s.offsetTop) ? l : 0)) / h,\n        y = u.width / d,\n        x = u.height / h;\n  return {\n    width: y,\n    height: x,\n    top: v,\n    right: w + y,\n    bottom: v + x,\n    left: w,\n    x: w,\n    y: v\n  };\n}\n\nfunction v(t) {\n  return (e = t, (e instanceof o(e).Node ? t.ownerDocument : t.document) || window.document).documentElement;\n  var e;\n}\n\nfunction y(t) {\n  return f(t) ? {\n    scrollLeft: t.scrollLeft,\n    scrollTop: t.scrollTop\n  } : {\n    scrollLeft: t.pageXOffset,\n    scrollTop: t.pageYOffset\n  };\n}\n\nfunction x(t) {\n  return w(v(t)).left + y(t).scrollLeft;\n}\n\nfunction b(t, e, n) {\n  const o = c(e),\n        i = v(e),\n        l = w(t, o && function (t) {\n    const e = w(t);\n    return m(e.width) !== t.offsetWidth || m(e.height) !== t.offsetHeight;\n  }(e), \"fixed\" === n);\n  let f = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const s = {\n    x: 0,\n    y: 0\n  };\n  if (o || !o && \"fixed\" !== n) if ((\"body\" !== r(e) || u(i)) && (f = y(e)), c(e)) {\n    const t = w(e, !0);\n    s.x = t.x + e.clientLeft, s.y = t.y + e.clientTop;\n  } else i && (s.x = x(i));\n  return {\n    x: l.left + f.scrollLeft - s.x,\n    y: l.top + f.scrollTop - s.y,\n    width: l.width,\n    height: l.height\n  };\n}\n\nfunction L(t) {\n  return \"html\" === r(t) ? t : t.assignedSlot || t.parentNode || (s(t) ? t.host : null) || v(t);\n}\n\nfunction R(t) {\n  return c(t) && \"fixed\" !== getComputedStyle(t).position ? t.offsetParent : null;\n}\n\nfunction T(t) {\n  const e = o(t);\n  let n = R(t);\n\n  for (; n && d(n) && \"static\" === getComputedStyle(n).position;) n = R(n);\n\n  return n && (\"html\" === r(n) || \"body\" === r(n) && \"static\" === getComputedStyle(n).position && !h(n)) ? e : n || function (t) {\n    let e = L(t);\n\n    for (s(e) && (e = e.host); c(e) && ![\"html\", \"body\"].includes(r(e));) {\n      if (h(e)) return e;\n      e = e.parentNode;\n    }\n\n    return null;\n  }(t) || e;\n}\n\nfunction W(t) {\n  if (c(t)) return {\n    width: t.offsetWidth,\n    height: t.offsetHeight\n  };\n  const e = w(t);\n  return {\n    width: e.width,\n    height: e.height\n  };\n}\n\nfunction E(t) {\n  const e = L(t);\n  return [\"html\", \"body\", \"#document\"].includes(r(e)) ? t.ownerDocument.body : c(e) && u(e) ? e : E(e);\n}\n\nfunction H(t, e) {\n  var n;\n  void 0 === e && (e = []);\n  const i = E(t),\n        r = i === (null == (n = t.ownerDocument) ? void 0 : n.body),\n        l = o(i),\n        c = r ? [l].concat(l.visualViewport || [], u(i) ? i : []) : i,\n        f = e.concat(c);\n  return r ? f : f.concat(H(c));\n}\n\nfunction C(e, n, r) {\n  return \"viewport\" === n ? t(function (t, e) {\n    const n = o(t),\n          i = v(t),\n          r = n.visualViewport;\n    let l = i.clientWidth,\n        c = i.clientHeight,\n        f = 0,\n        s = 0;\n\n    if (r) {\n      l = r.width, c = r.height;\n      const t = a();\n      (t || !t && \"fixed\" === e) && (f = r.offsetLeft, s = r.offsetTop);\n    }\n\n    return {\n      width: l,\n      height: c,\n      x: f,\n      y: s\n    };\n  }(e, r)) : f(n) ? function (t, e) {\n    const n = w(t, !1, \"fixed\" === e),\n          o = n.top + t.clientTop,\n          i = n.left + t.clientLeft;\n    return {\n      top: o,\n      left: i,\n      x: i,\n      y: o,\n      right: i + t.clientWidth,\n      bottom: o + t.clientHeight,\n      width: t.clientWidth,\n      height: t.clientHeight\n    };\n  }(n, r) : t(function (t) {\n    var e;\n    const n = v(t),\n          o = y(t),\n          r = null == (e = t.ownerDocument) ? void 0 : e.body,\n          l = p(n.scrollWidth, n.clientWidth, r ? r.scrollWidth : 0, r ? r.clientWidth : 0),\n          c = p(n.scrollHeight, n.clientHeight, r ? r.scrollHeight : 0, r ? r.clientHeight : 0);\n    let f = -o.scrollLeft + x(t);\n    const s = -o.scrollTop;\n    return \"rtl\" === i(r || n).direction && (f += p(n.clientWidth, r ? r.clientWidth : 0) - l), {\n      width: l,\n      height: c,\n      x: f,\n      y: s\n    };\n  }(v(e)));\n}\n\nfunction S(t) {\n  const e = H(t),\n        n = [\"absolute\", \"fixed\"].includes(i(t).position) && c(t) ? T(t) : t;\n  return f(n) ? e.filter(t => f(t) && function (t, e) {\n    const n = null == e.getRootNode ? void 0 : e.getRootNode();\n    if (t.contains(e)) return !0;\n\n    if (n && s(n)) {\n      let n = e;\n\n      do {\n        if (n && t === n) return !0;\n        n = n.parentNode || n.host;\n      } while (n);\n    }\n\n    return !1;\n  }(t, n) && \"body\" !== r(t)) : [];\n}\n\nconst D = {\n  getClippingRect: function (t) {\n    let {\n      element: e,\n      boundary: n,\n      rootBoundary: o,\n      strategy: i\n    } = t;\n    const r = [...(\"clippingAncestors\" === n ? S(e) : [].concat(n)), o],\n          l = r[0],\n          c = r.reduce((t, n) => {\n      const o = C(e, n, i);\n      return t.top = p(o.top, t.top), t.right = g(o.right, t.right), t.bottom = g(o.bottom, t.bottom), t.left = p(o.left, t.left), t;\n    }, C(e, l, i));\n    return {\n      width: c.right - c.left,\n      height: c.bottom - c.top,\n      x: c.left,\n      y: c.top\n    };\n  },\n  convertOffsetParentRelativeRectToViewportRelativeRect: function (t) {\n    let {\n      rect: e,\n      offsetParent: n,\n      strategy: o\n    } = t;\n    const i = c(n),\n          l = v(n);\n    if (n === l) return e;\n    let f = {\n      scrollLeft: 0,\n      scrollTop: 0\n    };\n    const s = {\n      x: 0,\n      y: 0\n    };\n\n    if ((i || !i && \"fixed\" !== o) && ((\"body\" !== r(n) || u(l)) && (f = y(n)), c(n))) {\n      const t = w(n, !0);\n      s.x = t.x + n.clientLeft, s.y = t.y + n.clientTop;\n    }\n\n    return { ...e,\n      x: e.x - f.scrollLeft + s.x,\n      y: e.y - f.scrollTop + s.y\n    };\n  },\n  isElement: f,\n  getDimensions: W,\n  getOffsetParent: T,\n  getDocumentElement: v,\n  getElementRects: t => {\n    let {\n      reference: e,\n      floating: n,\n      strategy: o\n    } = t;\n    return {\n      reference: b(e, T(n), o),\n      floating: { ...W(n),\n        x: 0,\n        y: 0\n      }\n    };\n  },\n  getClientRects: t => Array.from(t.getClientRects()),\n  isRTL: t => \"rtl\" === i(t).direction\n};\n\nfunction N(t, e, n, o) {\n  void 0 === o && (o = {});\n  const {\n    ancestorScroll: i = !0,\n    ancestorResize: r = !0,\n    elementResize: l = !0,\n    animationFrame: c = !1\n  } = o,\n        s = i && !c,\n        u = r && !c,\n        d = s || u ? [...(f(t) ? H(t) : []), ...H(e)] : [];\n  d.forEach(t => {\n    s && t.addEventListener(\"scroll\", n, {\n      passive: !0\n    }), u && t.addEventListener(\"resize\", n);\n  });\n  let h,\n      a = null;\n\n  if (l) {\n    let o = !0;\n    a = new ResizeObserver(() => {\n      o || n(), o = !1;\n    }), f(t) && !c && a.observe(t), a.observe(e);\n  }\n\n  let g = c ? w(t) : null;\n  return c && function e() {\n    const o = w(t);\n    !g || o.x === g.x && o.y === g.y && o.width === g.width && o.height === g.height || n();\n    g = o, h = requestAnimationFrame(e);\n  }(), n(), () => {\n    var t;\n    d.forEach(t => {\n      s && t.removeEventListener(\"scroll\", n), u && t.removeEventListener(\"resize\", n);\n    }), null == (t = a) || t.disconnect(), a = null, c && cancelAnimationFrame(h);\n  };\n}\n\nconst z = (t, n, o) => e(t, n, {\n  platform: D,\n  ...o\n});\n\nexport { N as autoUpdate, z as computePosition, H as getOverflowAncestors };","map":null,"metadata":{},"sourceType":"module"}