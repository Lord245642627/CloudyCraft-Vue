{"ast":null,"code":"import * as _ from 'lodash-es';\nexport { PriorityQueue };\n/**\n * A min-priority queue data structure. This algorithm is derived from Cormen,\n * et al., \"Introduction to Algorithms\". The basic idea of a min-priority\n * queue is that you can efficiently (in O(1) time) get the smallest key in\n * the queue. Adding and removing elements takes O(log n) time. A key can\n * have its priority decreased in O(log n) time.\n */\n\nclass PriorityQueue {\n  constructor() {\n    this._arr = [];\n    this._keyIndices = {};\n  }\n  /**\n   * Returns the number of elements in the queue. Takes `O(1)` time.\n   */\n\n\n  size() {\n    return this._arr.length;\n  }\n  /**\n   * Returns the keys that are in the queue. Takes `O(n)` time.\n   */\n\n\n  keys() {\n    return this._arr.map(function (x) {\n      return x.key;\n    });\n  }\n  /**\n   * Returns `true` if **key** is in the queue and `false` if not.\n   */\n\n\n  has(key) {\n    return _.has(this._keyIndices, key);\n  }\n  /**\n   * Returns the priority for **key**. If **key** is not present in the queue\n   * then this function returns `undefined`. Takes `O(1)` time.\n   *\n   * @param {Object} key\n   */\n\n\n  priority(key) {\n    var index = this._keyIndices[key];\n\n    if (index !== undefined) {\n      return this._arr[index].priority;\n    }\n  }\n  /**\n   * Returns the key for the minimum element in this queue. If the queue is\n   * empty this function throws an Error. Takes `O(1)` time.\n   */\n\n\n  min() {\n    if (this.size() === 0) {\n      throw new Error('Queue underflow');\n    }\n\n    return this._arr[0].key;\n  }\n  /**\n   * Inserts a new key into the priority queue. If the key already exists in\n   * the queue this function returns `false`; otherwise it will return `true`.\n   * Takes `O(n)` time.\n   *\n   * @param {Object} key the key to add\n   * @param {Number} priority the initial priority for the key\n   */\n\n\n  add(key, priority) {\n    var keyIndices = this._keyIndices;\n    key = String(key);\n\n    if (!_.has(keyIndices, key)) {\n      var arr = this._arr;\n      var index = arr.length;\n      keyIndices[key] = index;\n      arr.push({\n        key: key,\n        priority: priority\n      });\n\n      this._decrease(index);\n\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Removes and returns the smallest key in the queue. Takes `O(log n)` time.\n   */\n\n\n  removeMin() {\n    this._swap(0, this._arr.length - 1);\n\n    var min = this._arr.pop();\n\n    delete this._keyIndices[min.key];\n\n    this._heapify(0);\n\n    return min.key;\n  }\n  /**\n   * Decreases the priority for **key** to **priority**. If the new priority is\n   * greater than the previous priority, this function will throw an Error.\n   *\n   * @param {Object} key the key for which to raise priority\n   * @param {Number} priority the new priority for the key\n   */\n\n\n  decrease(key, priority) {\n    var index = this._keyIndices[key];\n\n    if (priority > this._arr[index].priority) {\n      throw new Error('New priority is greater than current priority. ' + 'Key: ' + key + ' Old: ' + this._arr[index].priority + ' New: ' + priority);\n    }\n\n    this._arr[index].priority = priority;\n\n    this._decrease(index);\n  }\n\n  _heapify(i) {\n    var arr = this._arr;\n    var l = 2 * i;\n    var r = l + 1;\n    var largest = i;\n\n    if (l < arr.length) {\n      largest = arr[l].priority < arr[largest].priority ? l : largest;\n\n      if (r < arr.length) {\n        largest = arr[r].priority < arr[largest].priority ? r : largest;\n      }\n\n      if (largest !== i) {\n        this._swap(i, largest);\n\n        this._heapify(largest);\n      }\n    }\n  }\n\n  _decrease(index) {\n    var arr = this._arr;\n    var priority = arr[index].priority;\n    var parent;\n\n    while (index !== 0) {\n      parent = index >> 1;\n\n      if (arr[parent].priority < priority) {\n        break;\n      }\n\n      this._swap(index, parent);\n\n      index = parent;\n    }\n  }\n\n  _swap(i, j) {\n    var arr = this._arr;\n    var keyIndices = this._keyIndices;\n    var origArrI = arr[i];\n    var origArrJ = arr[j];\n    arr[i] = origArrJ;\n    arr[j] = origArrI;\n    keyIndices[origArrJ.key] = i;\n    keyIndices[origArrI.key] = j;\n  }\n\n}","map":{"version":3,"names":["_","PriorityQueue","constructor","_arr","_keyIndices","size","length","keys","map","x","key","has","priority","index","undefined","min","Error","add","keyIndices","String","arr","push","_decrease","removeMin","_swap","pop","_heapify","decrease","i","l","r","largest","parent","j","origArrI","origArrJ"],"sources":["/Users/lord/Documents/Programmer/vue/VueProjects/blog-vue/blog-web/node_modules/dagre-d3-es/src/graphlib/data/priority-queue.js"],"sourcesContent":["import * as _ from 'lodash-es';\n\nexport { PriorityQueue };\n\n/**\n * A min-priority queue data structure. This algorithm is derived from Cormen,\n * et al., \"Introduction to Algorithms\". The basic idea of a min-priority\n * queue is that you can efficiently (in O(1) time) get the smallest key in\n * the queue. Adding and removing elements takes O(log n) time. A key can\n * have its priority decreased in O(log n) time.\n */\nclass PriorityQueue {\n  constructor() {\n    this._arr = [];\n    this._keyIndices = {};\n  }\n  /**\n   * Returns the number of elements in the queue. Takes `O(1)` time.\n   */\n  size() {\n    return this._arr.length;\n  }\n  /**\n   * Returns the keys that are in the queue. Takes `O(n)` time.\n   */\n  keys() {\n    return this._arr.map(function (x) {\n      return x.key;\n    });\n  }\n  /**\n   * Returns `true` if **key** is in the queue and `false` if not.\n   */\n  has(key) {\n    return _.has(this._keyIndices, key);\n  }\n  /**\n   * Returns the priority for **key**. If **key** is not present in the queue\n   * then this function returns `undefined`. Takes `O(1)` time.\n   *\n   * @param {Object} key\n   */\n  priority(key) {\n    var index = this._keyIndices[key];\n    if (index !== undefined) {\n      return this._arr[index].priority;\n    }\n  }\n  /**\n   * Returns the key for the minimum element in this queue. If the queue is\n   * empty this function throws an Error. Takes `O(1)` time.\n   */\n  min() {\n    if (this.size() === 0) {\n      throw new Error('Queue underflow');\n    }\n    return this._arr[0].key;\n  }\n  /**\n   * Inserts a new key into the priority queue. If the key already exists in\n   * the queue this function returns `false`; otherwise it will return `true`.\n   * Takes `O(n)` time.\n   *\n   * @param {Object} key the key to add\n   * @param {Number} priority the initial priority for the key\n   */\n  add(key, priority) {\n    var keyIndices = this._keyIndices;\n    key = String(key);\n    if (!_.has(keyIndices, key)) {\n      var arr = this._arr;\n      var index = arr.length;\n      keyIndices[key] = index;\n      arr.push({ key: key, priority: priority });\n      this._decrease(index);\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Removes and returns the smallest key in the queue. Takes `O(log n)` time.\n   */\n  removeMin() {\n    this._swap(0, this._arr.length - 1);\n    var min = this._arr.pop();\n    delete this._keyIndices[min.key];\n    this._heapify(0);\n    return min.key;\n  }\n  /**\n   * Decreases the priority for **key** to **priority**. If the new priority is\n   * greater than the previous priority, this function will throw an Error.\n   *\n   * @param {Object} key the key for which to raise priority\n   * @param {Number} priority the new priority for the key\n   */\n  decrease(key, priority) {\n    var index = this._keyIndices[key];\n    if (priority > this._arr[index].priority) {\n      throw new Error(\n        'New priority is greater than current priority. ' +\n          'Key: ' +\n          key +\n          ' Old: ' +\n          this._arr[index].priority +\n          ' New: ' +\n          priority\n      );\n    }\n    this._arr[index].priority = priority;\n    this._decrease(index);\n  }\n  _heapify(i) {\n    var arr = this._arr;\n    var l = 2 * i;\n    var r = l + 1;\n    var largest = i;\n    if (l < arr.length) {\n      largest = arr[l].priority < arr[largest].priority ? l : largest;\n      if (r < arr.length) {\n        largest = arr[r].priority < arr[largest].priority ? r : largest;\n      }\n      if (largest !== i) {\n        this._swap(i, largest);\n        this._heapify(largest);\n      }\n    }\n  }\n  _decrease(index) {\n    var arr = this._arr;\n    var priority = arr[index].priority;\n    var parent;\n    while (index !== 0) {\n      parent = index >> 1;\n      if (arr[parent].priority < priority) {\n        break;\n      }\n      this._swap(index, parent);\n      index = parent;\n    }\n  }\n  _swap(i, j) {\n    var arr = this._arr;\n    var keyIndices = this._keyIndices;\n    var origArrI = arr[i];\n    var origArrJ = arr[j];\n    arr[i] = origArrJ;\n    arr[j] = origArrI;\n    keyIndices[origArrJ.key] = i;\n    keyIndices[origArrI.key] = j;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}