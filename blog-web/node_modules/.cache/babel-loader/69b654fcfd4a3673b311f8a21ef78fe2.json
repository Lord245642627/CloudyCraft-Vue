{"ast":null,"code":"'use strict';\n\nvar normalizeReference = require('../common/utils').normalizeReference;\n\nvar isSpace = require('../common/utils').isSpace;\n\nmodule.exports = function reference(state, startLine, _endLine, silent) {\n  var ch,\n      destEndPos,\n      destEndLineNo,\n      endLine,\n      href,\n      i,\n      l,\n      label,\n      labelEnd,\n      oldParentType,\n      res,\n      start,\n      str,\n      terminate,\n      terminatorRules,\n      title,\n      lines = 0,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine],\n      nextLine = startLine + 1; // if it's indented more than 3 spaces, it should be a code block\n\n  if (state.sCount[startLine] - state.blkIndent >= 4) {\n    return false;\n  }\n\n  if (state.src.charCodeAt(pos) !== 0x5B\n  /* [ */\n  ) {\n    return false;\n  } // Simple check to quickly interrupt scan on [link](url) at the start of line.\n  // Can be useful on practice: https://github.com/markdown-it/markdown-it/issues/54\n\n\n  while (++pos < max) {\n    if (state.src.charCodeAt(pos) === 0x5D\n    /* ] */\n    && state.src.charCodeAt(pos - 1) !== 0x5C\n    /* \\ */\n    ) {\n      if (pos + 1 === max) {\n        return false;\n      }\n\n      if (state.src.charCodeAt(pos + 1) !== 0x3A\n      /* : */\n      ) {\n        return false;\n      }\n\n      break;\n    }\n  }\n\n  endLine = state.lineMax; // jump line-by-line until empty one or EOF\n\n  terminatorRules = state.md.block.ruler.getRules('reference');\n  oldParentType = state.parentType;\n  state.parentType = 'reference';\n\n  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n    // this would be a code block normally, but after paragraph\n    // it's considered a lazy continuation regardless of what's there\n    if (state.sCount[nextLine] - state.blkIndent > 3) {\n      continue;\n    } // quirk for blockquotes, this line should already be checked by that rule\n\n\n    if (state.sCount[nextLine] < 0) {\n      continue;\n    } // Some tags can terminate paragraph without empty line.\n\n\n    terminate = false;\n\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n\n    if (terminate) {\n      break;\n    }\n  }\n\n  str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n  max = str.length;\n\n  for (pos = 1; pos < max; pos++) {\n    ch = str.charCodeAt(pos);\n\n    if (ch === 0x5B\n    /* [ */\n    ) {\n      return false;\n    } else if (ch === 0x5D\n    /* ] */\n    ) {\n      labelEnd = pos;\n      break;\n    } else if (ch === 0x0A\n    /* \\n */\n    ) {\n      lines++;\n    } else if (ch === 0x5C\n    /* \\ */\n    ) {\n      pos++;\n\n      if (pos < max && str.charCodeAt(pos) === 0x0A) {\n        lines++;\n      }\n    }\n  }\n\n  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A\n  /* : */\n  ) {\n    return false;\n  } // [label]:   destination   'title'\n  //         ^^^ skip optional whitespace here\n\n\n  for (pos = labelEnd + 2; pos < max; pos++) {\n    ch = str.charCodeAt(pos);\n\n    if (ch === 0x0A) {\n      lines++;\n    } else if (isSpace(ch)) {\n      /*eslint no-empty:0*/\n    } else {\n      break;\n    }\n  } // [label]:   destination   'title'\n  //            ^^^^^^^^^^^ parse this\n\n\n  res = state.md.helpers.parseLinkDestination(str, pos, max);\n\n  if (!res.ok) {\n    return false;\n  }\n\n  href = state.md.normalizeLink(res.str);\n\n  if (!state.md.validateLink(href)) {\n    return false;\n  }\n\n  pos = res.pos;\n  lines += res.lines; // save cursor state, we could require to rollback later\n\n  destEndPos = pos;\n  destEndLineNo = lines; // [label]:   destination   'title'\n  //                       ^^^ skipping those spaces\n\n  start = pos;\n\n  for (; pos < max; pos++) {\n    ch = str.charCodeAt(pos);\n\n    if (ch === 0x0A) {\n      lines++;\n    } else if (isSpace(ch)) {\n      /*eslint no-empty:0*/\n    } else {\n      break;\n    }\n  } // [label]:   destination   'title'\n  //                          ^^^^^^^ parse this\n\n\n  res = state.md.helpers.parseLinkTitle(str, pos, max);\n\n  if (pos < max && start !== pos && res.ok) {\n    title = res.str;\n    pos = res.pos;\n    lines += res.lines;\n  } else {\n    title = '';\n    pos = destEndPos;\n    lines = destEndLineNo;\n  } // skip trailing spaces until the rest of the line\n\n\n  while (pos < max) {\n    ch = str.charCodeAt(pos);\n\n    if (!isSpace(ch)) {\n      break;\n    }\n\n    pos++;\n  }\n\n  if (pos < max && str.charCodeAt(pos) !== 0x0A) {\n    if (title) {\n      // garbage at the end of the line after title,\n      // but it could still be a valid reference if we roll back\n      title = '';\n      pos = destEndPos;\n      lines = destEndLineNo;\n\n      while (pos < max) {\n        ch = str.charCodeAt(pos);\n\n        if (!isSpace(ch)) {\n          break;\n        }\n\n        pos++;\n      }\n    }\n  }\n\n  if (pos < max && str.charCodeAt(pos) !== 0x0A) {\n    // garbage at the end of the line\n    return false;\n  }\n\n  label = normalizeReference(str.slice(1, labelEnd));\n\n  if (!label) {\n    // CommonMark 0.20 disallows empty labels\n    return false;\n  } // Reference can not terminate anything. This check is for safety only.\n\n  /*istanbul ignore if*/\n\n\n  if (silent) {\n    return true;\n  }\n\n  if (typeof state.env.references === 'undefined') {\n    state.env.references = {};\n  }\n\n  if (typeof state.env.references[label] === 'undefined') {\n    state.env.references[label] = {\n      title: title,\n      href: href\n    };\n  }\n\n  state.parentType = oldParentType;\n  state.line = startLine + lines + 1;\n  return true;\n};","map":{"version":3,"names":["normalizeReference","require","isSpace","module","exports","reference","state","startLine","_endLine","silent","ch","destEndPos","destEndLineNo","endLine","href","i","l","label","labelEnd","oldParentType","res","start","str","terminate","terminatorRules","title","lines","pos","bMarks","tShift","max","eMarks","nextLine","sCount","blkIndent","src","charCodeAt","lineMax","md","block","ruler","getRules","parentType","isEmpty","length","getLines","trim","helpers","parseLinkDestination","ok","normalizeLink","validateLink","parseLinkTitle","slice","env","references","line"],"sources":["/Users/lord/Documents/Programmer/vue/VueProjects/cloudycraft-vue/blog-web/node_modules/markdown-it/lib/rules_block/reference.js"],"sourcesContent":["'use strict';\n\n\nvar normalizeReference   = require('../common/utils').normalizeReference;\nvar isSpace              = require('../common/utils').isSpace;\n\n\nmodule.exports = function reference(state, startLine, _endLine, silent) {\n  var ch,\n      destEndPos,\n      destEndLineNo,\n      endLine,\n      href,\n      i,\n      l,\n      label,\n      labelEnd,\n      oldParentType,\n      res,\n      start,\n      str,\n      terminate,\n      terminatorRules,\n      title,\n      lines = 0,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine],\n      nextLine = startLine + 1;\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }\n\n  if (state.src.charCodeAt(pos) !== 0x5B/* [ */) { return false; }\n\n  // Simple check to quickly interrupt scan on [link](url) at the start of line.\n  // Can be useful on practice: https://github.com/markdown-it/markdown-it/issues/54\n  while (++pos < max) {\n    if (state.src.charCodeAt(pos) === 0x5D /* ] */ &&\n        state.src.charCodeAt(pos - 1) !== 0x5C/* \\ */) {\n      if (pos + 1 === max) { return false; }\n      if (state.src.charCodeAt(pos + 1) !== 0x3A/* : */) { return false; }\n      break;\n    }\n  }\n\n  endLine = state.lineMax;\n\n  // jump line-by-line until empty one or EOF\n  terminatorRules = state.md.block.ruler.getRules('reference');\n\n  oldParentType = state.parentType;\n  state.parentType = 'reference';\n\n  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n    // this would be a code block normally, but after paragraph\n    // it's considered a lazy continuation regardless of what's there\n    if (state.sCount[nextLine] - state.blkIndent > 3) { continue; }\n\n    // quirk for blockquotes, this line should already be checked by that rule\n    if (state.sCount[nextLine] < 0) { continue; }\n\n    // Some tags can terminate paragraph without empty line.\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) { break; }\n  }\n\n  str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n  max = str.length;\n\n  for (pos = 1; pos < max; pos++) {\n    ch = str.charCodeAt(pos);\n    if (ch === 0x5B /* [ */) {\n      return false;\n    } else if (ch === 0x5D /* ] */) {\n      labelEnd = pos;\n      break;\n    } else if (ch === 0x0A /* \\n */) {\n      lines++;\n    } else if (ch === 0x5C /* \\ */) {\n      pos++;\n      if (pos < max && str.charCodeAt(pos) === 0x0A) {\n        lines++;\n      }\n    }\n  }\n\n  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A/* : */) { return false; }\n\n  // [label]:   destination   'title'\n  //         ^^^ skip optional whitespace here\n  for (pos = labelEnd + 2; pos < max; pos++) {\n    ch = str.charCodeAt(pos);\n    if (ch === 0x0A) {\n      lines++;\n    } else if (isSpace(ch)) {\n      /*eslint no-empty:0*/\n    } else {\n      break;\n    }\n  }\n\n  // [label]:   destination   'title'\n  //            ^^^^^^^^^^^ parse this\n  res = state.md.helpers.parseLinkDestination(str, pos, max);\n  if (!res.ok) { return false; }\n\n  href = state.md.normalizeLink(res.str);\n  if (!state.md.validateLink(href)) { return false; }\n\n  pos = res.pos;\n  lines += res.lines;\n\n  // save cursor state, we could require to rollback later\n  destEndPos = pos;\n  destEndLineNo = lines;\n\n  // [label]:   destination   'title'\n  //                       ^^^ skipping those spaces\n  start = pos;\n  for (; pos < max; pos++) {\n    ch = str.charCodeAt(pos);\n    if (ch === 0x0A) {\n      lines++;\n    } else if (isSpace(ch)) {\n      /*eslint no-empty:0*/\n    } else {\n      break;\n    }\n  }\n\n  // [label]:   destination   'title'\n  //                          ^^^^^^^ parse this\n  res = state.md.helpers.parseLinkTitle(str, pos, max);\n  if (pos < max && start !== pos && res.ok) {\n    title = res.str;\n    pos = res.pos;\n    lines += res.lines;\n  } else {\n    title = '';\n    pos = destEndPos;\n    lines = destEndLineNo;\n  }\n\n  // skip trailing spaces until the rest of the line\n  while (pos < max) {\n    ch = str.charCodeAt(pos);\n    if (!isSpace(ch)) { break; }\n    pos++;\n  }\n\n  if (pos < max && str.charCodeAt(pos) !== 0x0A) {\n    if (title) {\n      // garbage at the end of the line after title,\n      // but it could still be a valid reference if we roll back\n      title = '';\n      pos = destEndPos;\n      lines = destEndLineNo;\n      while (pos < max) {\n        ch = str.charCodeAt(pos);\n        if (!isSpace(ch)) { break; }\n        pos++;\n      }\n    }\n  }\n\n  if (pos < max && str.charCodeAt(pos) !== 0x0A) {\n    // garbage at the end of the line\n    return false;\n  }\n\n  label = normalizeReference(str.slice(1, labelEnd));\n  if (!label) {\n    // CommonMark 0.20 disallows empty labels\n    return false;\n  }\n\n  // Reference can not terminate anything. This check is for safety only.\n  /*istanbul ignore if*/\n  if (silent) { return true; }\n\n  if (typeof state.env.references === 'undefined') {\n    state.env.references = {};\n  }\n  if (typeof state.env.references[label] === 'undefined') {\n    state.env.references[label] = { title: title, href: href };\n  }\n\n  state.parentType = oldParentType;\n\n  state.line = startLine + lines + 1;\n  return true;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}