{"ast":null,"code":"// Parse link label\n//\n// this function assumes that first character (\"[\") already matches;\n// returns the end of the label\n//\n'use strict';\n\nmodule.exports = function parseLinkLabel(state, start, disableNested) {\n  var level,\n      found,\n      marker,\n      prevPos,\n      labelEnd = -1,\n      max = state.posMax,\n      oldPos = state.pos;\n  state.pos = start + 1;\n  level = 1;\n\n  while (state.pos < max) {\n    marker = state.src.charCodeAt(state.pos);\n\n    if (marker === 0x5D\n    /* ] */\n    ) {\n      level--;\n\n      if (level === 0) {\n        found = true;\n        break;\n      }\n    }\n\n    prevPos = state.pos;\n    state.md.inline.skipToken(state);\n\n    if (marker === 0x5B\n    /* [ */\n    ) {\n      if (prevPos === state.pos - 1) {\n        // increase level if we find text `[`, which is not a part of any token\n        level++;\n      } else if (disableNested) {\n        state.pos = oldPos;\n        return -1;\n      }\n    }\n  }\n\n  if (found) {\n    labelEnd = state.pos;\n  } // restore old state\n\n\n  state.pos = oldPos;\n  return labelEnd;\n};","map":{"version":3,"names":["module","exports","parseLinkLabel","state","start","disableNested","level","found","marker","prevPos","labelEnd","max","posMax","oldPos","pos","src","charCodeAt","md","inline","skipToken"],"sources":["/Users/lord/Documents/Programmer/vue/VueProjects/cloudycraft-vue/blog-web/node_modules/markdown-it/lib/helpers/parse_link_label.js"],"sourcesContent":["// Parse link label\n//\n// this function assumes that first character (\"[\") already matches;\n// returns the end of the label\n//\n'use strict';\n\nmodule.exports = function parseLinkLabel(state, start, disableNested) {\n  var level, found, marker, prevPos,\n      labelEnd = -1,\n      max = state.posMax,\n      oldPos = state.pos;\n\n  state.pos = start + 1;\n  level = 1;\n\n  while (state.pos < max) {\n    marker = state.src.charCodeAt(state.pos);\n    if (marker === 0x5D /* ] */) {\n      level--;\n      if (level === 0) {\n        found = true;\n        break;\n      }\n    }\n\n    prevPos = state.pos;\n    state.md.inline.skipToken(state);\n    if (marker === 0x5B /* [ */) {\n      if (prevPos === state.pos - 1) {\n        // increase level if we find text `[`, which is not a part of any token\n        level++;\n      } else if (disableNested) {\n        state.pos = oldPos;\n        return -1;\n      }\n    }\n  }\n\n  if (found) {\n    labelEnd = state.pos;\n  }\n\n  // restore old state\n  state.pos = oldPos;\n\n  return labelEnd;\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;;AAEAA,MAAM,CAACC,OAAP,GAAiB,SAASC,cAAT,CAAwBC,KAAxB,EAA+BC,KAA/B,EAAsCC,aAAtC,EAAqD;EACpE,IAAIC,KAAJ;EAAA,IAAWC,KAAX;EAAA,IAAkBC,MAAlB;EAAA,IAA0BC,OAA1B;EAAA,IACIC,QAAQ,GAAG,CAAC,CADhB;EAAA,IAEIC,GAAG,GAAGR,KAAK,CAACS,MAFhB;EAAA,IAGIC,MAAM,GAAGV,KAAK,CAACW,GAHnB;EAKAX,KAAK,CAACW,GAAN,GAAYV,KAAK,GAAG,CAApB;EACAE,KAAK,GAAG,CAAR;;EAEA,OAAOH,KAAK,CAACW,GAAN,GAAYH,GAAnB,EAAwB;IACtBH,MAAM,GAAGL,KAAK,CAACY,GAAN,CAAUC,UAAV,CAAqBb,KAAK,CAACW,GAA3B,CAAT;;IACA,IAAIN,MAAM,KAAK;IAAK;IAApB,EAA6B;MAC3BF,KAAK;;MACL,IAAIA,KAAK,KAAK,CAAd,EAAiB;QACfC,KAAK,GAAG,IAAR;QACA;MACD;IACF;;IAEDE,OAAO,GAAGN,KAAK,CAACW,GAAhB;IACAX,KAAK,CAACc,EAAN,CAASC,MAAT,CAAgBC,SAAhB,CAA0BhB,KAA1B;;IACA,IAAIK,MAAM,KAAK;IAAK;IAApB,EAA6B;MAC3B,IAAIC,OAAO,KAAKN,KAAK,CAACW,GAAN,GAAY,CAA5B,EAA+B;QAC7B;QACAR,KAAK;MACN,CAHD,MAGO,IAAID,aAAJ,EAAmB;QACxBF,KAAK,CAACW,GAAN,GAAYD,MAAZ;QACA,OAAO,CAAC,CAAR;MACD;IACF;EACF;;EAED,IAAIN,KAAJ,EAAW;IACTG,QAAQ,GAAGP,KAAK,CAACW,GAAjB;EACD,CAlCmE,CAoCpE;;;EACAX,KAAK,CAACW,GAAN,GAAYD,MAAZ;EAEA,OAAOH,QAAP;AACD,CAxCD"},"metadata":{},"sourceType":"script"}