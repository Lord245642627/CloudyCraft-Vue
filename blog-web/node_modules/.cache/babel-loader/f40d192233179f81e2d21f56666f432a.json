{"ast":null,"code":"import { ref, getCurrentInstance, inject, computed, provide, unref } from 'vue';\nimport '../../tokens/index.mjs';\nimport '../../utils/index.mjs';\nimport { configProviderContextKey } from '../../tokens/config-provider.mjs';\nimport { debugWarn } from '../../utils/error.mjs';\nimport { keysOf } from '../../utils/objects.mjs';\nconst globalConfig = ref();\n\nfunction useGlobalConfig(key, defaultValue = void 0) {\n  const config = getCurrentInstance() ? inject(configProviderContextKey, globalConfig) : globalConfig;\n\n  if (key) {\n    return computed(() => {\n      var _a, _b;\n\n      return (_b = (_a = config.value) == null ? void 0 : _a[key]) != null ? _b : defaultValue;\n    });\n  } else {\n    return config;\n  }\n}\n\nconst provideGlobalConfig = (config, app, global = false) => {\n  var _a;\n\n  const inSetup = !!getCurrentInstance();\n  const oldConfig = inSetup ? useGlobalConfig() : void 0;\n  const provideFn = (_a = app == null ? void 0 : app.provide) != null ? _a : inSetup ? provide : void 0;\n\n  if (!provideFn) {\n    debugWarn(\"provideGlobalConfig\", \"provideGlobalConfig() can only be used inside setup().\");\n    return;\n  }\n\n  const context = computed(() => {\n    const cfg = unref(config);\n    if (!(oldConfig == null ? void 0 : oldConfig.value)) return cfg;\n    return mergeConfig(oldConfig.value, cfg);\n  });\n  provideFn(configProviderContextKey, context);\n\n  if (global || !globalConfig.value) {\n    globalConfig.value = context.value;\n  }\n\n  return context;\n};\n\nconst mergeConfig = (a, b) => {\n  var _a;\n\n  const keys = [... /* @__PURE__ */new Set([...keysOf(a), ...keysOf(b)])];\n  const obj = {};\n\n  for (const key of keys) {\n    obj[key] = (_a = b[key]) != null ? _a : a[key];\n  }\n\n  return obj;\n};\n\nexport { provideGlobalConfig, useGlobalConfig };","map":null,"metadata":{},"sourceType":"module"}