{"ast":null,"code":"// Block quotes\n'use strict';\n\nvar isSpace = require('../common/utils').isSpace;\n\nmodule.exports = function blockquote(state, startLine, endLine, silent) {\n  var adjustTab,\n      ch,\n      i,\n      initial,\n      l,\n      lastLineEmpty,\n      lines,\n      nextLine,\n      offset,\n      oldBMarks,\n      oldBSCount,\n      oldIndent,\n      oldParentType,\n      oldSCount,\n      oldTShift,\n      spaceAfterMarker,\n      terminate,\n      terminatorRules,\n      token,\n      isOutdented,\n      oldLineMax = state.lineMax,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine]; // if it's indented more than 3 spaces, it should be a code block\n\n  if (state.sCount[startLine] - state.blkIndent >= 4) {\n    return false;\n  } // check the block quote marker\n\n\n  if (state.src.charCodeAt(pos++) !== 0x3E\n  /* > */\n  ) {\n    return false;\n  } // we know that it's going to be a valid blockquote,\n  // so no point trying to find the end of it in silent mode\n\n\n  if (silent) {\n    return true;\n  } // set offset past spaces and \">\"\n\n\n  initial = offset = state.sCount[startLine] + 1; // skip one optional space after '>'\n\n  if (state.src.charCodeAt(pos) === 0x20\n  /* space */\n  ) {\n    // ' >   test '\n    //     ^ -- position start of line here:\n    pos++;\n    initial++;\n    offset++;\n    adjustTab = false;\n    spaceAfterMarker = true;\n  } else if (state.src.charCodeAt(pos) === 0x09\n  /* tab */\n  ) {\n    spaceAfterMarker = true;\n\n    if ((state.bsCount[startLine] + offset) % 4 === 3) {\n      // '  >\\t  test '\n      //       ^ -- position start of line here (tab has width===1)\n      pos++;\n      initial++;\n      offset++;\n      adjustTab = false;\n    } else {\n      // ' >\\t  test '\n      //    ^ -- position start of line here + shift bsCount slightly\n      //         to make extra space appear\n      adjustTab = true;\n    }\n  } else {\n    spaceAfterMarker = false;\n  }\n\n  oldBMarks = [state.bMarks[startLine]];\n  state.bMarks[startLine] = pos;\n\n  while (pos < max) {\n    ch = state.src.charCodeAt(pos);\n\n    if (isSpace(ch)) {\n      if (ch === 0x09) {\n        offset += 4 - (offset + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;\n      } else {\n        offset++;\n      }\n    } else {\n      break;\n    }\n\n    pos++;\n  }\n\n  oldBSCount = [state.bsCount[startLine]];\n  state.bsCount[startLine] = state.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);\n  lastLineEmpty = pos >= max;\n  oldSCount = [state.sCount[startLine]];\n  state.sCount[startLine] = offset - initial;\n  oldTShift = [state.tShift[startLine]];\n  state.tShift[startLine] = pos - state.bMarks[startLine];\n  terminatorRules = state.md.block.ruler.getRules('blockquote');\n  oldParentType = state.parentType;\n  state.parentType = 'blockquote'; // Search the end of the block\n  //\n  // Block ends with either:\n  //  1. an empty line outside:\n  //     ```\n  //     > test\n  //\n  //     ```\n  //  2. an empty line inside:\n  //     ```\n  //     >\n  //     test\n  //     ```\n  //  3. another tag:\n  //     ```\n  //     > test\n  //      - - -\n  //     ```\n\n  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {\n    // check if it's outdented, i.e. it's inside list item and indented\n    // less than said list item:\n    //\n    // ```\n    // 1. anything\n    //    > current blockquote\n    // 2. checking this line\n    // ```\n    isOutdented = state.sCount[nextLine] < state.blkIndent;\n    pos = state.bMarks[nextLine] + state.tShift[nextLine];\n    max = state.eMarks[nextLine];\n\n    if (pos >= max) {\n      // Case 1: line is not inside the blockquote, and this line is empty.\n      break;\n    }\n\n    if (state.src.charCodeAt(pos++) === 0x3E\n    /* > */\n    && !isOutdented) {\n      // This line is inside the blockquote.\n      // set offset past spaces and \">\"\n      initial = offset = state.sCount[nextLine] + 1; // skip one optional space after '>'\n\n      if (state.src.charCodeAt(pos) === 0x20\n      /* space */\n      ) {\n        // ' >   test '\n        //     ^ -- position start of line here:\n        pos++;\n        initial++;\n        offset++;\n        adjustTab = false;\n        spaceAfterMarker = true;\n      } else if (state.src.charCodeAt(pos) === 0x09\n      /* tab */\n      ) {\n        spaceAfterMarker = true;\n\n        if ((state.bsCount[nextLine] + offset) % 4 === 3) {\n          // '  >\\t  test '\n          //       ^ -- position start of line here (tab has width===1)\n          pos++;\n          initial++;\n          offset++;\n          adjustTab = false;\n        } else {\n          // ' >\\t  test '\n          //    ^ -- position start of line here + shift bsCount slightly\n          //         to make extra space appear\n          adjustTab = true;\n        }\n      } else {\n        spaceAfterMarker = false;\n      }\n\n      oldBMarks.push(state.bMarks[nextLine]);\n      state.bMarks[nextLine] = pos;\n\n      while (pos < max) {\n        ch = state.src.charCodeAt(pos);\n\n        if (isSpace(ch)) {\n          if (ch === 0x09) {\n            offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;\n          } else {\n            offset++;\n          }\n        } else {\n          break;\n        }\n\n        pos++;\n      }\n\n      lastLineEmpty = pos >= max;\n      oldBSCount.push(state.bsCount[nextLine]);\n      state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);\n      oldSCount.push(state.sCount[nextLine]);\n      state.sCount[nextLine] = offset - initial;\n      oldTShift.push(state.tShift[nextLine]);\n      state.tShift[nextLine] = pos - state.bMarks[nextLine];\n      continue;\n    } // Case 2: line is not inside the blockquote, and the last line was empty.\n\n\n    if (lastLineEmpty) {\n      break;\n    } // Case 3: another tag found.\n\n\n    terminate = false;\n\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n\n    if (terminate) {\n      // Quirk to enforce \"hard termination mode\" for paragraphs;\n      // normally if you call `tokenize(state, startLine, nextLine)`,\n      // paragraphs will look below nextLine for paragraph continuation,\n      // but if blockquote is terminated by another tag, they shouldn't\n      state.lineMax = nextLine;\n\n      if (state.blkIndent !== 0) {\n        // state.blkIndent was non-zero, we now set it to zero,\n        // so we need to re-calculate all offsets to appear as\n        // if indent wasn't changed\n        oldBMarks.push(state.bMarks[nextLine]);\n        oldBSCount.push(state.bsCount[nextLine]);\n        oldTShift.push(state.tShift[nextLine]);\n        oldSCount.push(state.sCount[nextLine]);\n        state.sCount[nextLine] -= state.blkIndent;\n      }\n\n      break;\n    }\n\n    oldBMarks.push(state.bMarks[nextLine]);\n    oldBSCount.push(state.bsCount[nextLine]);\n    oldTShift.push(state.tShift[nextLine]);\n    oldSCount.push(state.sCount[nextLine]); // A negative indentation means that this is a paragraph continuation\n    //\n\n    state.sCount[nextLine] = -1;\n  }\n\n  oldIndent = state.blkIndent;\n  state.blkIndent = 0;\n  token = state.push('blockquote_open', 'blockquote', 1);\n  token.markup = '>';\n  token.map = lines = [startLine, 0];\n  state.md.block.tokenize(state, startLine, nextLine);\n  token = state.push('blockquote_close', 'blockquote', -1);\n  token.markup = '>';\n  state.lineMax = oldLineMax;\n  state.parentType = oldParentType;\n  lines[1] = state.line; // Restore original tShift; this might not be necessary since the parser\n  // has already been here, but just to make sure we can do that.\n\n  for (i = 0; i < oldTShift.length; i++) {\n    state.bMarks[i + startLine] = oldBMarks[i];\n    state.tShift[i + startLine] = oldTShift[i];\n    state.sCount[i + startLine] = oldSCount[i];\n    state.bsCount[i + startLine] = oldBSCount[i];\n  }\n\n  state.blkIndent = oldIndent;\n  return true;\n};","map":{"version":3,"names":["isSpace","require","module","exports","blockquote","state","startLine","endLine","silent","adjustTab","ch","i","initial","l","lastLineEmpty","lines","nextLine","offset","oldBMarks","oldBSCount","oldIndent","oldParentType","oldSCount","oldTShift","spaceAfterMarker","terminate","terminatorRules","token","isOutdented","oldLineMax","lineMax","pos","bMarks","tShift","max","eMarks","sCount","blkIndent","src","charCodeAt","bsCount","md","block","ruler","getRules","parentType","push","length","markup","map","tokenize","line"],"sources":["/Users/lord/Documents/Programmer/vue/VueProjects/blog-vue/blog-web/node_modules/markdown-it/lib/rules_block/blockquote.js"],"sourcesContent":["// Block quotes\n\n'use strict';\n\nvar isSpace = require('../common/utils').isSpace;\n\n\nmodule.exports = function blockquote(state, startLine, endLine, silent) {\n  var adjustTab,\n      ch,\n      i,\n      initial,\n      l,\n      lastLineEmpty,\n      lines,\n      nextLine,\n      offset,\n      oldBMarks,\n      oldBSCount,\n      oldIndent,\n      oldParentType,\n      oldSCount,\n      oldTShift,\n      spaceAfterMarker,\n      terminate,\n      terminatorRules,\n      token,\n      isOutdented,\n      oldLineMax = state.lineMax,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }\n\n  // check the block quote marker\n  if (state.src.charCodeAt(pos++) !== 0x3E/* > */) { return false; }\n\n  // we know that it's going to be a valid blockquote,\n  // so no point trying to find the end of it in silent mode\n  if (silent) { return true; }\n\n  // set offset past spaces and \">\"\n  initial = offset = state.sCount[startLine] + 1;\n\n  // skip one optional space after '>'\n  if (state.src.charCodeAt(pos) === 0x20 /* space */) {\n    // ' >   test '\n    //     ^ -- position start of line here:\n    pos++;\n    initial++;\n    offset++;\n    adjustTab = false;\n    spaceAfterMarker = true;\n  } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {\n    spaceAfterMarker = true;\n\n    if ((state.bsCount[startLine] + offset) % 4 === 3) {\n      // '  >\\t  test '\n      //       ^ -- position start of line here (tab has width===1)\n      pos++;\n      initial++;\n      offset++;\n      adjustTab = false;\n    } else {\n      // ' >\\t  test '\n      //    ^ -- position start of line here + shift bsCount slightly\n      //         to make extra space appear\n      adjustTab = true;\n    }\n  } else {\n    spaceAfterMarker = false;\n  }\n\n  oldBMarks = [ state.bMarks[startLine] ];\n  state.bMarks[startLine] = pos;\n\n  while (pos < max) {\n    ch = state.src.charCodeAt(pos);\n\n    if (isSpace(ch)) {\n      if (ch === 0x09) {\n        offset += 4 - (offset + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;\n      } else {\n        offset++;\n      }\n    } else {\n      break;\n    }\n\n    pos++;\n  }\n\n  oldBSCount = [ state.bsCount[startLine] ];\n  state.bsCount[startLine] = state.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);\n\n  lastLineEmpty = pos >= max;\n\n  oldSCount = [ state.sCount[startLine] ];\n  state.sCount[startLine] = offset - initial;\n\n  oldTShift = [ state.tShift[startLine] ];\n  state.tShift[startLine] = pos - state.bMarks[startLine];\n\n  terminatorRules = state.md.block.ruler.getRules('blockquote');\n\n  oldParentType = state.parentType;\n  state.parentType = 'blockquote';\n\n  // Search the end of the block\n  //\n  // Block ends with either:\n  //  1. an empty line outside:\n  //     ```\n  //     > test\n  //\n  //     ```\n  //  2. an empty line inside:\n  //     ```\n  //     >\n  //     test\n  //     ```\n  //  3. another tag:\n  //     ```\n  //     > test\n  //      - - -\n  //     ```\n  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {\n    // check if it's outdented, i.e. it's inside list item and indented\n    // less than said list item:\n    //\n    // ```\n    // 1. anything\n    //    > current blockquote\n    // 2. checking this line\n    // ```\n    isOutdented = state.sCount[nextLine] < state.blkIndent;\n\n    pos = state.bMarks[nextLine] + state.tShift[nextLine];\n    max = state.eMarks[nextLine];\n\n    if (pos >= max) {\n      // Case 1: line is not inside the blockquote, and this line is empty.\n      break;\n    }\n\n    if (state.src.charCodeAt(pos++) === 0x3E/* > */ && !isOutdented) {\n      // This line is inside the blockquote.\n\n      // set offset past spaces and \">\"\n      initial = offset = state.sCount[nextLine] + 1;\n\n      // skip one optional space after '>'\n      if (state.src.charCodeAt(pos) === 0x20 /* space */) {\n        // ' >   test '\n        //     ^ -- position start of line here:\n        pos++;\n        initial++;\n        offset++;\n        adjustTab = false;\n        spaceAfterMarker = true;\n      } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {\n        spaceAfterMarker = true;\n\n        if ((state.bsCount[nextLine] + offset) % 4 === 3) {\n          // '  >\\t  test '\n          //       ^ -- position start of line here (tab has width===1)\n          pos++;\n          initial++;\n          offset++;\n          adjustTab = false;\n        } else {\n          // ' >\\t  test '\n          //    ^ -- position start of line here + shift bsCount slightly\n          //         to make extra space appear\n          adjustTab = true;\n        }\n      } else {\n        spaceAfterMarker = false;\n      }\n\n      oldBMarks.push(state.bMarks[nextLine]);\n      state.bMarks[nextLine] = pos;\n\n      while (pos < max) {\n        ch = state.src.charCodeAt(pos);\n\n        if (isSpace(ch)) {\n          if (ch === 0x09) {\n            offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;\n          } else {\n            offset++;\n          }\n        } else {\n          break;\n        }\n\n        pos++;\n      }\n\n      lastLineEmpty = pos >= max;\n\n      oldBSCount.push(state.bsCount[nextLine]);\n      state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);\n\n      oldSCount.push(state.sCount[nextLine]);\n      state.sCount[nextLine] = offset - initial;\n\n      oldTShift.push(state.tShift[nextLine]);\n      state.tShift[nextLine] = pos - state.bMarks[nextLine];\n      continue;\n    }\n\n    // Case 2: line is not inside the blockquote, and the last line was empty.\n    if (lastLineEmpty) { break; }\n\n    // Case 3: another tag found.\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n\n    if (terminate) {\n      // Quirk to enforce \"hard termination mode\" for paragraphs;\n      // normally if you call `tokenize(state, startLine, nextLine)`,\n      // paragraphs will look below nextLine for paragraph continuation,\n      // but if blockquote is terminated by another tag, they shouldn't\n      state.lineMax = nextLine;\n\n      if (state.blkIndent !== 0) {\n        // state.blkIndent was non-zero, we now set it to zero,\n        // so we need to re-calculate all offsets to appear as\n        // if indent wasn't changed\n        oldBMarks.push(state.bMarks[nextLine]);\n        oldBSCount.push(state.bsCount[nextLine]);\n        oldTShift.push(state.tShift[nextLine]);\n        oldSCount.push(state.sCount[nextLine]);\n        state.sCount[nextLine] -= state.blkIndent;\n      }\n\n      break;\n    }\n\n    oldBMarks.push(state.bMarks[nextLine]);\n    oldBSCount.push(state.bsCount[nextLine]);\n    oldTShift.push(state.tShift[nextLine]);\n    oldSCount.push(state.sCount[nextLine]);\n\n    // A negative indentation means that this is a paragraph continuation\n    //\n    state.sCount[nextLine] = -1;\n  }\n\n  oldIndent = state.blkIndent;\n  state.blkIndent = 0;\n\n  token        = state.push('blockquote_open', 'blockquote', 1);\n  token.markup = '>';\n  token.map    = lines = [ startLine, 0 ];\n\n  state.md.block.tokenize(state, startLine, nextLine);\n\n  token        = state.push('blockquote_close', 'blockquote', -1);\n  token.markup = '>';\n\n  state.lineMax = oldLineMax;\n  state.parentType = oldParentType;\n  lines[1] = state.line;\n\n  // Restore original tShift; this might not be necessary since the parser\n  // has already been here, but just to make sure we can do that.\n  for (i = 0; i < oldTShift.length; i++) {\n    state.bMarks[i + startLine] = oldBMarks[i];\n    state.tShift[i + startLine] = oldTShift[i];\n    state.sCount[i + startLine] = oldSCount[i];\n    state.bsCount[i + startLine] = oldBSCount[i];\n  }\n  state.blkIndent = oldIndent;\n\n  return true;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}