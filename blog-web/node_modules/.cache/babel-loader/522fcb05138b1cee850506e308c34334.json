{"ast":null,"code":"/**\n * @Author: chenhuachao <chc>\n * @Date:   2017-11-26T15:57:48+08:00\n * @Email:  chenhuachaoxyz@gmail.com\n * @Filename: index.js\n * @Last modified by:   chc\n * @Last modified time: 2017-11-26T16:00:49+08:00\n * @License: MIT\n * @Copyright: 2017\n */\n\n/**\n * This is fork from https://github.com/waylonflinn/markdown-it-katex and support for external_link.\n */\n\n/* Process inline math */\n\n/*\nLike markdown-it-simplemath, this is a stripped down, simplified version of:\nhttps://github.com/runarberg/markdown-it-math\n\nIt differs in that it takes (a subset of) LaTeX as input and relies on KaTeX\nfor rendering output.\n*/\n\n/*jslint node: true */\n'use strict';\n\nvar katex = null; // Test if potential opening or closing delimieter\n// Assumes that there is a \"$\" at state.src[pos]\n\nfunction isValidDelim(state, pos) {\n  var prevChar,\n      nextChar,\n      max = state.posMax,\n      can_open = true,\n      can_close = true;\n  prevChar = pos > 0 ? state.src.charCodeAt(pos - 1) : -1;\n  nextChar = pos + 1 <= max ? state.src.charCodeAt(pos + 1) : -1; // Check non-whitespace conditions for opening and closing, and\n  // check that closing delimeter isn't followed by a number\n\n  if (prevChar === 0x20\n  /* \" \" */\n  || prevChar === 0x09\n  /* \\t */\n  || nextChar >= 0x30\n  /* \"0\" */\n  && nextChar <= 0x39\n  /* \"9\" */\n  ) {\n    can_close = false;\n  }\n\n  if (nextChar === 0x20\n  /* \" \" */\n  || nextChar === 0x09\n  /* \\t */\n  ) {\n    can_open = false;\n  }\n\n  return {\n    can_open: can_open,\n    can_close: can_close\n  };\n}\n\nfunction math_inline(state, silent) {\n  if (!katex && window.katex) katex = window.katex;\n  if (!katex) return false;\n  var start, match, token, res, pos, esc_count;\n\n  if (state.src[state.pos] !== \"$\") {\n    return false;\n  }\n\n  res = isValidDelim(state, state.pos);\n\n  if (!res.can_open) {\n    if (!silent) {\n      state.pending += \"$\";\n    }\n\n    state.pos += 1;\n    return true;\n  } // First check for and bypass all properly escaped delimieters\n  // This loop will assume that the first leading backtick can not\n  // be the first character in state.src, which is known since\n  // we have found an opening delimieter already.\n\n\n  start = state.pos + 1;\n  match = start;\n\n  while ((match = state.src.indexOf(\"$\", match)) !== -1) {\n    // Found potential $, look for escapes, pos will point to\n    // first non escape when complete\n    pos = match - 1;\n\n    while (state.src[pos] === \"\\\\\") {\n      pos -= 1;\n    } // Even number of escapes, potential closing delimiter found\n\n\n    if ((match - pos) % 2 == 1) {\n      break;\n    }\n\n    match += 1;\n  } // No closing delimter found.  Consume $ and continue.\n\n\n  if (match === -1) {\n    if (!silent) {\n      state.pending += \"$\";\n    }\n\n    state.pos = start;\n    return true;\n  } // Check if we have empty content, ie: $$.  Do not parse.\n\n\n  if (match - start === 0) {\n    if (!silent) {\n      state.pending += \"$$\";\n    }\n\n    state.pos = start + 1;\n    return true;\n  } // Check for valid closing delimiter\n\n\n  res = isValidDelim(state, match);\n\n  if (!res.can_close) {\n    if (!silent) {\n      state.pending += \"$\";\n    }\n\n    state.pos = start;\n    return true;\n  }\n\n  if (!silent) {\n    token = state.push('math_inline', 'math', 0);\n    token.markup = \"$\";\n    token.content = state.src.slice(start, match);\n  }\n\n  state.pos = match + 1;\n  return true;\n}\n\nfunction math_block(state, start, end, silent) {\n  if (!katex && window.katex) katex = window.katex;\n  if (!katex) return false;\n  var firstLine,\n      lastLine,\n      next,\n      lastPos,\n      found = false,\n      token,\n      pos = state.bMarks[start] + state.tShift[start],\n      max = state.eMarks[start];\n\n  if (pos + 2 > max) {\n    return false;\n  }\n\n  if (state.src.slice(pos, pos + 2) !== '$$') {\n    return false;\n  }\n\n  pos += 2;\n  firstLine = state.src.slice(pos, max);\n\n  if (silent) {\n    return true;\n  }\n\n  if (firstLine.trim().slice(-2) === '$$') {\n    // Single line expression\n    firstLine = firstLine.trim().slice(0, -2);\n    found = true;\n  }\n\n  for (next = start; !found;) {\n    next++;\n\n    if (next >= end) {\n      break;\n    }\n\n    pos = state.bMarks[next] + state.tShift[next];\n    max = state.eMarks[next];\n\n    if (pos < max && state.tShift[next] < state.blkIndent) {\n      // non-empty line with negative indent should stop the list:\n      break;\n    }\n\n    if (state.src.slice(pos, max).trim().slice(-2) === '$$') {\n      lastPos = state.src.slice(0, max).lastIndexOf('$$');\n      lastLine = state.src.slice(pos, lastPos);\n      found = true;\n    }\n  }\n\n  state.line = next + 1;\n  token = state.push('math_block', 'math', 0);\n  token.block = true;\n  token.content = (firstLine && firstLine.trim() ? firstLine + '\\n' : '') + state.getLines(start + 1, next, state.tShift[start], true) + (lastLine && lastLine.trim() ? lastLine : '');\n  token.map = [start, state.line];\n  token.markup = '$$';\n  return true;\n}\n\nmodule.exports = function math_plugin(md, options) {\n  // Default options\n  options = options || {}; // set KaTeX as the renderer for markdown-it-simplemath\n\n  var katexInline = function (latex) {\n    if (!katex && window.katex) katex = window.katex;\n    options.displayMode = false;\n\n    try {\n      return katex.renderToString(latex, options);\n    } catch (error) {\n      if (options.throwOnError) {\n        console.log(error);\n      }\n\n      return latex;\n    }\n  };\n\n  var inlineRenderer = function (tokens, idx) {\n    return katexInline(tokens[idx].content);\n  };\n\n  var katexBlock = function (latex) {\n    if (!katex && window.katex) katex = window.katex;\n    options.displayMode = true;\n\n    try {\n      return \"<p>\" + katex.renderToString(latex, options) + \"</p>\";\n    } catch (error) {\n      if (options.throwOnError) {\n        console.log(error);\n      }\n\n      return latex;\n    }\n  };\n\n  var blockRenderer = function (tokens, idx) {\n    return katexBlock(tokens[idx].content) + '\\n';\n  };\n\n  md.inline.ruler.after('escape', 'math_inline', math_inline);\n  md.block.ruler.after('blockquote', 'math_block', math_block, {\n    alt: ['paragraph', 'reference', 'blockquote', 'list']\n  });\n  md.renderer.rules.math_inline = inlineRenderer;\n  md.renderer.rules.math_block = blockRenderer;\n};","map":{"version":3,"names":["katex","isValidDelim","state","pos","prevChar","nextChar","max","posMax","can_open","can_close","src","charCodeAt","math_inline","silent","window","start","match","token","res","esc_count","pending","indexOf","push","markup","content","slice","math_block","end","firstLine","lastLine","next","lastPos","found","bMarks","tShift","eMarks","trim","blkIndent","lastIndexOf","line","block","getLines","map","module","exports","math_plugin","md","options","katexInline","latex","displayMode","renderToString","error","throwOnError","console","log","inlineRenderer","tokens","idx","katexBlock","blockRenderer","inline","ruler","after","alt","renderer","rules"],"sources":["/Users/lord/Documents/Programmer/vue/VueProjects/cloudycraft-vue/blog-web/node_modules/markdown-it-katex-external/index.js"],"sourcesContent":["/**\n * @Author: chenhuachao <chc>\n * @Date:   2017-11-26T15:57:48+08:00\n * @Email:  chenhuachaoxyz@gmail.com\n * @Filename: index.js\n * @Last modified by:   chc\n * @Last modified time: 2017-11-26T16:00:49+08:00\n * @License: MIT\n * @Copyright: 2017\n */\n/**\n * This is fork from https://github.com/waylonflinn/markdown-it-katex and support for external_link.\n */\n/* Process inline math */\n/*\nLike markdown-it-simplemath, this is a stripped down, simplified version of:\nhttps://github.com/runarberg/markdown-it-math\n\nIt differs in that it takes (a subset of) LaTeX as input and relies on KaTeX\nfor rendering output.\n*/\n\n/*jslint node: true */\n'use strict';\n\nvar katex = null;\n\n// Test if potential opening or closing delimieter\n// Assumes that there is a \"$\" at state.src[pos]\nfunction isValidDelim(state, pos) {\n    var prevChar, nextChar,\n        max = state.posMax,\n        can_open = true,\n        can_close = true;\n\n    prevChar = pos > 0 ? state.src.charCodeAt(pos - 1) : -1;\n    nextChar = pos + 1 <= max ? state.src.charCodeAt(pos + 1) : -1;\n\n    // Check non-whitespace conditions for opening and closing, and\n    // check that closing delimeter isn't followed by a number\n    if (prevChar === 0x20/* \" \" */ || prevChar === 0x09/* \\t */ ||\n            (nextChar >= 0x30/* \"0\" */ && nextChar <= 0x39/* \"9\" */)) {\n        can_close = false;\n    }\n    if (nextChar === 0x20/* \" \" */ || nextChar === 0x09/* \\t */) {\n        can_open = false;\n    }\n\n    return {\n        can_open: can_open,\n        can_close: can_close\n    };\n}\n\nfunction math_inline(state, silent) {\n    if (!katex && window.katex) katex = window.katex;\n    if (!katex) return false;\n    var start, match, token, res, pos, esc_count;\n\n    if (state.src[state.pos] !== \"$\") { return false; }\n\n    res = isValidDelim(state, state.pos);\n    if (!res.can_open) {\n        if (!silent) { state.pending += \"$\"; }\n        state.pos += 1;\n        return true;\n    }\n\n    // First check for and bypass all properly escaped delimieters\n    // This loop will assume that the first leading backtick can not\n    // be the first character in state.src, which is known since\n    // we have found an opening delimieter already.\n    start = state.pos + 1;\n    match = start;\n    while ( (match = state.src.indexOf(\"$\", match)) !== -1) {\n        // Found potential $, look for escapes, pos will point to\n        // first non escape when complete\n        pos = match - 1;\n        while (state.src[pos] === \"\\\\\") { pos -= 1; }\n\n        // Even number of escapes, potential closing delimiter found\n        if ( ((match - pos) % 2) == 1 ) { break; }\n        match += 1;\n    }\n\n    // No closing delimter found.  Consume $ and continue.\n    if (match === -1) {\n        if (!silent) { state.pending += \"$\"; }\n        state.pos = start;\n        return true;\n    }\n\n    // Check if we have empty content, ie: $$.  Do not parse.\n    if (match - start === 0) {\n        if (!silent) { state.pending += \"$$\"; }\n        state.pos = start + 1;\n        return true;\n    }\n\n    // Check for valid closing delimiter\n    res = isValidDelim(state, match);\n    if (!res.can_close) {\n        if (!silent) { state.pending += \"$\"; }\n        state.pos = start;\n        return true;\n    }\n\n    if (!silent) {\n        token         = state.push('math_inline', 'math', 0);\n        token.markup  = \"$\";\n        token.content = state.src.slice(start, match);\n    }\n\n    state.pos = match + 1;\n    return true;\n}\n\nfunction math_block(state, start, end, silent){\n    if (!katex && window.katex) katex = window.katex;\n    if (!katex) return false;\n    var firstLine, lastLine, next, lastPos, found = false, token,\n        pos = state.bMarks[start] + state.tShift[start],\n        max = state.eMarks[start]\n\n    if(pos + 2 > max){ return false; }\n    if(state.src.slice(pos,pos+2)!=='$$'){ return false; }\n\n    pos += 2;\n    firstLine = state.src.slice(pos,max);\n\n    if(silent){ return true; }\n    if(firstLine.trim().slice(-2)==='$$'){\n        // Single line expression\n        firstLine = firstLine.trim().slice(0, -2);\n        found = true;\n    }\n\n    for(next = start; !found; ){\n\n        next++;\n\n        if(next >= end){ break; }\n\n        pos = state.bMarks[next]+state.tShift[next];\n        max = state.eMarks[next];\n\n        if(pos < max && state.tShift[next] < state.blkIndent){\n            // non-empty line with negative indent should stop the list:\n            break;\n        }\n\n        if(state.src.slice(pos,max).trim().slice(-2)==='$$'){\n            lastPos = state.src.slice(0,max).lastIndexOf('$$');\n            lastLine = state.src.slice(pos,lastPos);\n            found = true;\n        }\n\n    }\n\n    state.line = next + 1;\n\n    token = state.push('math_block', 'math', 0);\n    token.block = true;\n    token.content = (firstLine && firstLine.trim() ? firstLine + '\\n' : '')\n    + state.getLines(start + 1, next, state.tShift[start], true)\n    + (lastLine && lastLine.trim() ? lastLine : '');\n    token.map = [ start, state.line ];\n    token.markup = '$$';\n    return true;\n}\n\nmodule.exports = function math_plugin(md, options) {\n    // Default options\n\n    options = options || {};\n\n    // set KaTeX as the renderer for markdown-it-simplemath\n    var katexInline = function(latex){\n        if(!katex && window.katex) katex = window.katex;\n        options.displayMode = false;\n        try{\n            return katex.renderToString(latex, options);\n        }\n        catch(error){\n            if(options.throwOnError){ console.log(error); }\n            return latex;\n        }\n    };\n\n    var inlineRenderer = function(tokens, idx){\n        return katexInline(tokens[idx].content);\n    };\n\n    var katexBlock = function(latex){\n        if(!katex && window.katex) katex = window.katex;\n        options.displayMode = true;\n        try{\n            return \"<p>\" + katex.renderToString(latex, options) + \"</p>\";\n        }\n        catch(error){\n            if(options.throwOnError){ console.log(error); }\n            return latex;\n        }\n    }\n\n    var blockRenderer = function(tokens, idx){\n        return  katexBlock(tokens[idx].content) + '\\n';\n    }\n\n    md.inline.ruler.after('escape', 'math_inline', math_inline);\n    md.block.ruler.after('blockquote', 'math_block', math_block, {\n        alt: [ 'paragraph', 'reference', 'blockquote', 'list' ]\n    });\n    md.renderer.rules.math_inline = inlineRenderer;\n    md.renderer.rules.math_block = blockRenderer;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}