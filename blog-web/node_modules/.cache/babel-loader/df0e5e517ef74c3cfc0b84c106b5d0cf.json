{"ast":null,"code":"// Parser state class\n'use strict';\n\nvar Token = require('../token');\n\nvar isSpace = require('../common/utils').isSpace;\n\nfunction StateBlock(src, md, env, tokens) {\n  var ch, s, start, pos, len, indent, offset, indent_found;\n  this.src = src; // link to parser instance\n\n  this.md = md;\n  this.env = env; //\n  // Internal state vartiables\n  //\n\n  this.tokens = tokens;\n  this.bMarks = []; // line begin offsets for fast jumps\n\n  this.eMarks = []; // line end offsets for fast jumps\n\n  this.tShift = []; // offsets of the first non-space characters (tabs not expanded)\n\n  this.sCount = []; // indents for each line (tabs expanded)\n  // An amount of virtual spaces (tabs expanded) between beginning\n  // of each line (bMarks) and real beginning of that line.\n  //\n  // It exists only as a hack because blockquotes override bMarks\n  // losing information in the process.\n  //\n  // It's used only when expanding tabs, you can think about it as\n  // an initial tab length, e.g. bsCount=21 applied to string `\\t123`\n  // means first tab should be expanded to 4-21%4 === 3 spaces.\n  //\n\n  this.bsCount = []; // block parser variables\n\n  this.blkIndent = 0; // required block content indent (for example, if we are\n  // inside a list, it would be positioned after list marker)\n\n  this.line = 0; // line index in src\n\n  this.lineMax = 0; // lines count\n\n  this.tight = false; // loose/tight mode for lists\n\n  this.ddIndent = -1; // indent of the current dd block (-1 if there isn't any)\n\n  this.listIndent = -1; // indent of the current list block (-1 if there isn't any)\n  // can be 'blockquote', 'list', 'root', 'paragraph' or 'reference'\n  // used in lists to determine if they interrupt a paragraph\n\n  this.parentType = 'root';\n  this.level = 0; // renderer\n\n  this.result = ''; // Create caches\n  // Generate markers.\n\n  s = this.src;\n  indent_found = false;\n\n  for (start = pos = indent = offset = 0, len = s.length; pos < len; pos++) {\n    ch = s.charCodeAt(pos);\n\n    if (!indent_found) {\n      if (isSpace(ch)) {\n        indent++;\n\n        if (ch === 0x09) {\n          offset += 4 - offset % 4;\n        } else {\n          offset++;\n        }\n\n        continue;\n      } else {\n        indent_found = true;\n      }\n    }\n\n    if (ch === 0x0A || pos === len - 1) {\n      if (ch !== 0x0A) {\n        pos++;\n      }\n\n      this.bMarks.push(start);\n      this.eMarks.push(pos);\n      this.tShift.push(indent);\n      this.sCount.push(offset);\n      this.bsCount.push(0);\n      indent_found = false;\n      indent = 0;\n      offset = 0;\n      start = pos + 1;\n    }\n  } // Push fake entry to simplify cache bounds checks\n\n\n  this.bMarks.push(s.length);\n  this.eMarks.push(s.length);\n  this.tShift.push(0);\n  this.sCount.push(0);\n  this.bsCount.push(0);\n  this.lineMax = this.bMarks.length - 1; // don't count last fake line\n} // Push new token to \"stream\".\n//\n\n\nStateBlock.prototype.push = function (type, tag, nesting) {\n  var token = new Token(type, tag, nesting);\n  token.block = true;\n  if (nesting < 0) this.level--; // closing tag\n\n  token.level = this.level;\n  if (nesting > 0) this.level++; // opening tag\n\n  this.tokens.push(token);\n  return token;\n};\n\nStateBlock.prototype.isEmpty = function isEmpty(line) {\n  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];\n};\n\nStateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {\n  for (var max = this.lineMax; from < max; from++) {\n    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {\n      break;\n    }\n  }\n\n  return from;\n}; // Skip spaces from given position.\n\n\nStateBlock.prototype.skipSpaces = function skipSpaces(pos) {\n  var ch;\n\n  for (var max = this.src.length; pos < max; pos++) {\n    ch = this.src.charCodeAt(pos);\n\n    if (!isSpace(ch)) {\n      break;\n    }\n  }\n\n  return pos;\n}; // Skip spaces from given position in reverse.\n\n\nStateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {\n  if (pos <= min) {\n    return pos;\n  }\n\n  while (pos > min) {\n    if (!isSpace(this.src.charCodeAt(--pos))) {\n      return pos + 1;\n    }\n  }\n\n  return pos;\n}; // Skip char codes from given position\n\n\nStateBlock.prototype.skipChars = function skipChars(pos, code) {\n  for (var max = this.src.length; pos < max; pos++) {\n    if (this.src.charCodeAt(pos) !== code) {\n      break;\n    }\n  }\n\n  return pos;\n}; // Skip char codes reverse from given position - 1\n\n\nStateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {\n  if (pos <= min) {\n    return pos;\n  }\n\n  while (pos > min) {\n    if (code !== this.src.charCodeAt(--pos)) {\n      return pos + 1;\n    }\n  }\n\n  return pos;\n}; // cut lines range from source.\n\n\nStateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {\n  var i,\n      lineIndent,\n      ch,\n      first,\n      last,\n      queue,\n      lineStart,\n      line = begin;\n\n  if (begin >= end) {\n    return '';\n  }\n\n  queue = new Array(end - begin);\n\n  for (i = 0; line < end; line++, i++) {\n    lineIndent = 0;\n    lineStart = first = this.bMarks[line];\n\n    if (line + 1 < end || keepLastLF) {\n      // No need for bounds check because we have fake entry on tail.\n      last = this.eMarks[line] + 1;\n    } else {\n      last = this.eMarks[line];\n    }\n\n    while (first < last && lineIndent < indent) {\n      ch = this.src.charCodeAt(first);\n\n      if (isSpace(ch)) {\n        if (ch === 0x09) {\n          lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;\n        } else {\n          lineIndent++;\n        }\n      } else if (first - lineStart < this.tShift[line]) {\n        // patched tShift masked characters to look like spaces (blockquotes, list markers)\n        lineIndent++;\n      } else {\n        break;\n      }\n\n      first++;\n    }\n\n    if (lineIndent > indent) {\n      // partially expanding tabs in code blocks, e.g '\\t\\tfoobar'\n      // with indent=2 becomes '  \\tfoobar'\n      queue[i] = new Array(lineIndent - indent + 1).join(' ') + this.src.slice(first, last);\n    } else {\n      queue[i] = this.src.slice(first, last);\n    }\n  }\n\n  return queue.join('');\n}; // re-export Token class to use in block rules\n\n\nStateBlock.prototype.Token = Token;\nmodule.exports = StateBlock;","map":{"version":3,"names":["Token","require","isSpace","StateBlock","src","md","env","tokens","ch","s","start","pos","len","indent","offset","indent_found","bMarks","eMarks","tShift","sCount","bsCount","blkIndent","line","lineMax","tight","ddIndent","listIndent","parentType","level","result","length","charCodeAt","push","prototype","type","tag","nesting","token","block","isEmpty","skipEmptyLines","from","max","skipSpaces","skipSpacesBack","min","skipChars","code","skipCharsBack","getLines","begin","end","keepLastLF","i","lineIndent","first","last","queue","lineStart","Array","join","slice","module","exports"],"sources":["/Users/lord/Documents/Programmer/vue/VueProjects/cloudycraft-vue/blog-web/node_modules/markdown-it/lib/rules_block/state_block.js"],"sourcesContent":["// Parser state class\n\n'use strict';\n\nvar Token = require('../token');\nvar isSpace = require('../common/utils').isSpace;\n\n\nfunction StateBlock(src, md, env, tokens) {\n  var ch, s, start, pos, len, indent, offset, indent_found;\n\n  this.src = src;\n\n  // link to parser instance\n  this.md     = md;\n\n  this.env = env;\n\n  //\n  // Internal state vartiables\n  //\n\n  this.tokens = tokens;\n\n  this.bMarks = [];  // line begin offsets for fast jumps\n  this.eMarks = [];  // line end offsets for fast jumps\n  this.tShift = [];  // offsets of the first non-space characters (tabs not expanded)\n  this.sCount = [];  // indents for each line (tabs expanded)\n\n  // An amount of virtual spaces (tabs expanded) between beginning\n  // of each line (bMarks) and real beginning of that line.\n  //\n  // It exists only as a hack because blockquotes override bMarks\n  // losing information in the process.\n  //\n  // It's used only when expanding tabs, you can think about it as\n  // an initial tab length, e.g. bsCount=21 applied to string `\\t123`\n  // means first tab should be expanded to 4-21%4 === 3 spaces.\n  //\n  this.bsCount = [];\n\n  // block parser variables\n  this.blkIndent  = 0; // required block content indent (for example, if we are\n                       // inside a list, it would be positioned after list marker)\n  this.line       = 0; // line index in src\n  this.lineMax    = 0; // lines count\n  this.tight      = false;  // loose/tight mode for lists\n  this.ddIndent   = -1; // indent of the current dd block (-1 if there isn't any)\n  this.listIndent = -1; // indent of the current list block (-1 if there isn't any)\n\n  // can be 'blockquote', 'list', 'root', 'paragraph' or 'reference'\n  // used in lists to determine if they interrupt a paragraph\n  this.parentType = 'root';\n\n  this.level = 0;\n\n  // renderer\n  this.result = '';\n\n  // Create caches\n  // Generate markers.\n  s = this.src;\n  indent_found = false;\n\n  for (start = pos = indent = offset = 0, len = s.length; pos < len; pos++) {\n    ch = s.charCodeAt(pos);\n\n    if (!indent_found) {\n      if (isSpace(ch)) {\n        indent++;\n\n        if (ch === 0x09) {\n          offset += 4 - offset % 4;\n        } else {\n          offset++;\n        }\n        continue;\n      } else {\n        indent_found = true;\n      }\n    }\n\n    if (ch === 0x0A || pos === len - 1) {\n      if (ch !== 0x0A) { pos++; }\n      this.bMarks.push(start);\n      this.eMarks.push(pos);\n      this.tShift.push(indent);\n      this.sCount.push(offset);\n      this.bsCount.push(0);\n\n      indent_found = false;\n      indent = 0;\n      offset = 0;\n      start = pos + 1;\n    }\n  }\n\n  // Push fake entry to simplify cache bounds checks\n  this.bMarks.push(s.length);\n  this.eMarks.push(s.length);\n  this.tShift.push(0);\n  this.sCount.push(0);\n  this.bsCount.push(0);\n\n  this.lineMax = this.bMarks.length - 1; // don't count last fake line\n}\n\n// Push new token to \"stream\".\n//\nStateBlock.prototype.push = function (type, tag, nesting) {\n  var token = new Token(type, tag, nesting);\n  token.block = true;\n\n  if (nesting < 0) this.level--; // closing tag\n  token.level = this.level;\n  if (nesting > 0) this.level++; // opening tag\n\n  this.tokens.push(token);\n  return token;\n};\n\nStateBlock.prototype.isEmpty = function isEmpty(line) {\n  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];\n};\n\nStateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {\n  for (var max = this.lineMax; from < max; from++) {\n    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {\n      break;\n    }\n  }\n  return from;\n};\n\n// Skip spaces from given position.\nStateBlock.prototype.skipSpaces = function skipSpaces(pos) {\n  var ch;\n\n  for (var max = this.src.length; pos < max; pos++) {\n    ch = this.src.charCodeAt(pos);\n    if (!isSpace(ch)) { break; }\n  }\n  return pos;\n};\n\n// Skip spaces from given position in reverse.\nStateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {\n  if (pos <= min) { return pos; }\n\n  while (pos > min) {\n    if (!isSpace(this.src.charCodeAt(--pos))) { return pos + 1; }\n  }\n  return pos;\n};\n\n// Skip char codes from given position\nStateBlock.prototype.skipChars = function skipChars(pos, code) {\n  for (var max = this.src.length; pos < max; pos++) {\n    if (this.src.charCodeAt(pos) !== code) { break; }\n  }\n  return pos;\n};\n\n// Skip char codes reverse from given position - 1\nStateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {\n  if (pos <= min) { return pos; }\n\n  while (pos > min) {\n    if (code !== this.src.charCodeAt(--pos)) { return pos + 1; }\n  }\n  return pos;\n};\n\n// cut lines range from source.\nStateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {\n  var i, lineIndent, ch, first, last, queue, lineStart,\n      line = begin;\n\n  if (begin >= end) {\n    return '';\n  }\n\n  queue = new Array(end - begin);\n\n  for (i = 0; line < end; line++, i++) {\n    lineIndent = 0;\n    lineStart = first = this.bMarks[line];\n\n    if (line + 1 < end || keepLastLF) {\n      // No need for bounds check because we have fake entry on tail.\n      last = this.eMarks[line] + 1;\n    } else {\n      last = this.eMarks[line];\n    }\n\n    while (first < last && lineIndent < indent) {\n      ch = this.src.charCodeAt(first);\n\n      if (isSpace(ch)) {\n        if (ch === 0x09) {\n          lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;\n        } else {\n          lineIndent++;\n        }\n      } else if (first - lineStart < this.tShift[line]) {\n        // patched tShift masked characters to look like spaces (blockquotes, list markers)\n        lineIndent++;\n      } else {\n        break;\n      }\n\n      first++;\n    }\n\n    if (lineIndent > indent) {\n      // partially expanding tabs in code blocks, e.g '\\t\\tfoobar'\n      // with indent=2 becomes '  \\tfoobar'\n      queue[i] = new Array(lineIndent - indent + 1).join(' ') + this.src.slice(first, last);\n    } else {\n      queue[i] = this.src.slice(first, last);\n    }\n  }\n\n  return queue.join('');\n};\n\n// re-export Token class to use in block rules\nStateBlock.prototype.Token = Token;\n\n\nmodule.exports = StateBlock;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}