{"ast":null,"code":"import { feasibleTree } from './feasible-tree.js';\nimport { networkSimplex } from './network-simplex.js';\nimport { longestPath } from './util.js';\nexport { rank };\n/*\n * Assigns a rank to each node in the input graph that respects the \"minlen\"\n * constraint specified on edges between nodes.\n *\n * This basic structure is derived from Gansner, et al., \"A Technique for\n * Drawing Directed Graphs.\"\n *\n * Pre-conditions:\n *\n *    1. Graph must be a connected DAG\n *    2. Graph nodes must be objects\n *    3. Graph edges must have \"weight\" and \"minlen\" attributes\n *\n * Post-conditions:\n *\n *    1. Graph nodes will have a \"rank\" attribute based on the results of the\n *       algorithm. Ranks can start at any index (including negative), we'll\n *       fix them up later.\n */\n\nfunction rank(g) {\n  switch (g.graph().ranker) {\n    case 'network-simplex':\n      networkSimplexRanker(g);\n      break;\n\n    case 'tight-tree':\n      tightTreeRanker(g);\n      break;\n\n    case 'longest-path':\n      longestPathRanker(g);\n      break;\n\n    default:\n      networkSimplexRanker(g);\n  }\n} // A fast and simple ranker, but results are far from optimal.\n\n\nvar longestPathRanker = longestPath;\n\nfunction tightTreeRanker(g) {\n  longestPath(g);\n  feasibleTree(g);\n}\n\nfunction networkSimplexRanker(g) {\n  networkSimplex(g);\n}","map":{"version":3,"names":["feasibleTree","networkSimplex","longestPath","rank","g","graph","ranker","networkSimplexRanker","tightTreeRanker","longestPathRanker"],"sources":["/Users/lord/Documents/Programmer/vue/VueProjects/blog-vue/blog-web/node_modules/dagre-d3-es/src/dagre/rank/index.js"],"sourcesContent":["import { feasibleTree } from './feasible-tree.js';\nimport { networkSimplex } from './network-simplex.js';\nimport { longestPath } from './util.js';\n\nexport { rank };\n\n/*\n * Assigns a rank to each node in the input graph that respects the \"minlen\"\n * constraint specified on edges between nodes.\n *\n * This basic structure is derived from Gansner, et al., \"A Technique for\n * Drawing Directed Graphs.\"\n *\n * Pre-conditions:\n *\n *    1. Graph must be a connected DAG\n *    2. Graph nodes must be objects\n *    3. Graph edges must have \"weight\" and \"minlen\" attributes\n *\n * Post-conditions:\n *\n *    1. Graph nodes will have a \"rank\" attribute based on the results of the\n *       algorithm. Ranks can start at any index (including negative), we'll\n *       fix them up later.\n */\nfunction rank(g) {\n  switch (g.graph().ranker) {\n    case 'network-simplex':\n      networkSimplexRanker(g);\n      break;\n    case 'tight-tree':\n      tightTreeRanker(g);\n      break;\n    case 'longest-path':\n      longestPathRanker(g);\n      break;\n    default:\n      networkSimplexRanker(g);\n  }\n}\n\n// A fast and simple ranker, but results are far from optimal.\nvar longestPathRanker = longestPath;\n\nfunction tightTreeRanker(g) {\n  longestPath(g);\n  feasibleTree(g);\n}\n\nfunction networkSimplexRanker(g) {\n  networkSimplex(g);\n}\n"],"mappings":"AAAA,SAASA,YAAT,QAA6B,oBAA7B;AACA,SAASC,cAAT,QAA+B,sBAA/B;AACA,SAASC,WAAT,QAA4B,WAA5B;AAEA,SAASC,IAAT;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASA,IAAT,CAAcC,CAAd,EAAiB;EACf,QAAQA,CAAC,CAACC,KAAF,GAAUC,MAAlB;IACE,KAAK,iBAAL;MACEC,oBAAoB,CAACH,CAAD,CAApB;MACA;;IACF,KAAK,YAAL;MACEI,eAAe,CAACJ,CAAD,CAAf;MACA;;IACF,KAAK,cAAL;MACEK,iBAAiB,CAACL,CAAD,CAAjB;MACA;;IACF;MACEG,oBAAoB,CAACH,CAAD,CAApB;EAXJ;AAaD,C,CAED;;;AACA,IAAIK,iBAAiB,GAAGP,WAAxB;;AAEA,SAASM,eAAT,CAAyBJ,CAAzB,EAA4B;EAC1BF,WAAW,CAACE,CAAD,CAAX;EACAJ,YAAY,CAACI,CAAD,CAAZ;AACD;;AAED,SAASG,oBAAT,CAA8BH,CAA9B,EAAiC;EAC/BH,cAAc,CAACG,CAAD,CAAd;AACD"},"metadata":{},"sourceType":"module"}