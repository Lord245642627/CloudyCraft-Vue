{"ast":null,"code":"'use strict';\n/**\n * @param typeMap [Object] Map of MIME type -> Array[extensions]\n * @param ...\n */\n\nfunction Mime() {\n  this._types = Object.create(null);\n  this._extensions = Object.create(null);\n\n  for (let i = 0; i < arguments.length; i++) {\n    this.define(arguments[i]);\n  }\n\n  this.define = this.define.bind(this);\n  this.getType = this.getType.bind(this);\n  this.getExtension = this.getExtension.bind(this);\n}\n/**\n * Define mimetype -> extension mappings.  Each key is a mime-type that maps\n * to an array of extensions associated with the type.  The first extension is\n * used as the default extension for the type.\n *\n * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});\n *\n * If a type declares an extension that has already been defined, an error will\n * be thrown.  To suppress this error and force the extension to be associated\n * with the new type, pass `force`=true.  Alternatively, you may prefix the\n * extension with \"*\" to map the type to extension, without mapping the\n * extension to the type.\n *\n * e.g. mime.define({'audio/wav', ['wav']}, {'audio/x-wav', ['*wav']});\n *\n *\n * @param map (Object) type definitions\n * @param force (Boolean) if true, force overriding of existing definitions\n */\n\n\nMime.prototype.define = function (typeMap, force) {\n  for (let type in typeMap) {\n    let extensions = typeMap[type].map(function (t) {\n      return t.toLowerCase();\n    });\n    type = type.toLowerCase();\n\n    for (let i = 0; i < extensions.length; i++) {\n      const ext = extensions[i]; // '*' prefix = not the preferred type for this extension.  So fixup the\n      // extension, and skip it.\n\n      if (ext[0] === '*') {\n        continue;\n      }\n\n      if (!force && ext in this._types) {\n        throw new Error('Attempt to change mapping for \"' + ext + '\" extension from \"' + this._types[ext] + '\" to \"' + type + '\". Pass `force=true` to allow this, otherwise remove \"' + ext + '\" from the list of extensions for \"' + type + '\".');\n      }\n\n      this._types[ext] = type;\n    } // Use first extension as default\n\n\n    if (force || !this._extensions[type]) {\n      const ext = extensions[0];\n      this._extensions[type] = ext[0] !== '*' ? ext : ext.substr(1);\n    }\n  }\n};\n/**\n * Lookup a mime type based on extension\n */\n\n\nMime.prototype.getType = function (path) {\n  path = String(path);\n  let last = path.replace(/^.*[/\\\\]/, '').toLowerCase();\n  let ext = last.replace(/^.*\\./, '').toLowerCase();\n  let hasPath = last.length < path.length;\n  let hasDot = ext.length < last.length - 1;\n  return (hasDot || !hasPath) && this._types[ext] || null;\n};\n/**\n * Return file extension associated with a mime type\n */\n\n\nMime.prototype.getExtension = function (type) {\n  type = /^\\s*([^;\\s]*)/.test(type) && RegExp.$1;\n  return type && this._extensions[type.toLowerCase()] || null;\n};\n\nmodule.exports = Mime;","map":{"version":3,"names":["Mime","_types","Object","create","_extensions","i","arguments","length","define","bind","getType","getExtension","prototype","typeMap","force","type","extensions","map","t","toLowerCase","ext","Error","substr","path","String","last","replace","hasPath","hasDot","test","RegExp","$1","module","exports"],"sources":["/Users/lord/Documents/Programmer/vue/VueProjects/cloudycraft-vue/blog-web/node_modules/vue-avatar-cropper/node_modules/mime/Mime.js"],"sourcesContent":["'use strict';\n\n/**\n * @param typeMap [Object] Map of MIME type -> Array[extensions]\n * @param ...\n */\nfunction Mime() {\n  this._types = Object.create(null);\n  this._extensions = Object.create(null);\n\n  for (let i = 0; i < arguments.length; i++) {\n    this.define(arguments[i]);\n  }\n\n  this.define = this.define.bind(this);\n  this.getType = this.getType.bind(this);\n  this.getExtension = this.getExtension.bind(this);\n}\n\n/**\n * Define mimetype -> extension mappings.  Each key is a mime-type that maps\n * to an array of extensions associated with the type.  The first extension is\n * used as the default extension for the type.\n *\n * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});\n *\n * If a type declares an extension that has already been defined, an error will\n * be thrown.  To suppress this error and force the extension to be associated\n * with the new type, pass `force`=true.  Alternatively, you may prefix the\n * extension with \"*\" to map the type to extension, without mapping the\n * extension to the type.\n *\n * e.g. mime.define({'audio/wav', ['wav']}, {'audio/x-wav', ['*wav']});\n *\n *\n * @param map (Object) type definitions\n * @param force (Boolean) if true, force overriding of existing definitions\n */\nMime.prototype.define = function(typeMap, force) {\n  for (let type in typeMap) {\n    let extensions = typeMap[type].map(function(t) {\n      return t.toLowerCase();\n    });\n    type = type.toLowerCase();\n\n    for (let i = 0; i < extensions.length; i++) {\n      const ext = extensions[i];\n\n      // '*' prefix = not the preferred type for this extension.  So fixup the\n      // extension, and skip it.\n      if (ext[0] === '*') {\n        continue;\n      }\n\n      if (!force && (ext in this._types)) {\n        throw new Error(\n          'Attempt to change mapping for \"' + ext +\n          '\" extension from \"' + this._types[ext] + '\" to \"' + type +\n          '\". Pass `force=true` to allow this, otherwise remove \"' + ext +\n          '\" from the list of extensions for \"' + type + '\".'\n        );\n      }\n\n      this._types[ext] = type;\n    }\n\n    // Use first extension as default\n    if (force || !this._extensions[type]) {\n      const ext = extensions[0];\n      this._extensions[type] = (ext[0] !== '*') ? ext : ext.substr(1);\n    }\n  }\n};\n\n/**\n * Lookup a mime type based on extension\n */\nMime.prototype.getType = function(path) {\n  path = String(path);\n  let last = path.replace(/^.*[/\\\\]/, '').toLowerCase();\n  let ext = last.replace(/^.*\\./, '').toLowerCase();\n\n  let hasPath = last.length < path.length;\n  let hasDot = ext.length < last.length - 1;\n\n  return (hasDot || !hasPath) && this._types[ext] || null;\n};\n\n/**\n * Return file extension associated with a mime type\n */\nMime.prototype.getExtension = function(type) {\n  type = /^\\s*([^;\\s]*)/.test(type) && RegExp.$1;\n  return type && this._extensions[type.toLowerCase()] || null;\n};\n\nmodule.exports = Mime;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}