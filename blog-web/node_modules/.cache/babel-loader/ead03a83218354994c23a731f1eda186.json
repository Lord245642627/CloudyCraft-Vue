{"ast":null,"code":"import { l as log, g as getConfig, i as insertMarkers, s as setupGraphViewbox, a as getStylesFromArray, e as evaluate, c as common, b as insertNode, d as interpolateToCurve, f as insertEdgeLabel, h as db, p as parser } from \"./mermaid-ae477ddf.js\";\nimport { select, curveLinear, line } from \"d3\";\nimport { addHtmlLabel } from \"dagre-d3-es/src/dagre-js/label/add-html-label.js\";\nimport ELK from \"elkjs/lib/elk.bundled.js\";\nimport \"ts-dedent\";\nimport \"dayjs\";\nimport \"@braintree/sanitize-url\";\nimport \"dompurify\";\nimport \"khroma\";\nimport \"lodash-es/memoize.js\";\nimport \"stylis\";\nimport \"dagre-d3-es/src/dagre/index.js\";\nimport \"dagre-d3-es/src/graphlib/index.js\";\nimport \"dagre-d3-es/src/graphlib/json.js\";\nimport \"uuid\";\nimport \"dagre-d3-es\";\nimport \"dagre-d3-es/src/dagre-js/util.js\";\nimport \"dagre-d3-es/src/dagre-js/intersect/intersect-polygon.js\";\nimport \"dagre-d3-es/src/dagre-js/intersect/intersect-rect.js\";\nimport \"dayjs/plugin/isoWeek.js\";\nimport \"dayjs/plugin/customParseFormat.js\";\nimport \"dayjs/plugin/advancedFormat.js\";\nimport \"lodash-es/isEmpty.js\";\n\nconst findCommonAncestor = (id1, id2, treeData) => {\n  const {\n    parentById\n  } = treeData;\n  const visited = /* @__PURE__ */new Set();\n  let currentId = id1;\n\n  while (currentId) {\n    visited.add(currentId);\n\n    if (currentId === id2) {\n      return currentId;\n    }\n\n    currentId = parentById[currentId];\n  }\n\n  currentId = id2;\n\n  while (currentId) {\n    if (visited.has(currentId)) {\n      return currentId;\n    }\n\n    currentId = parentById[currentId];\n  }\n\n  return \"root\";\n};\n\nconst elk = new ELK();\nconst portPos = {};\nconst conf = {};\nlet nodeDb = {};\n\nconst addVertices = function (vert, svgId, root, doc, diagObj, parentLookupDb, graph) {\n  const svg = root.select(`[id=\"${svgId}\"]`);\n  const nodes = svg.insert(\"g\").attr(\"class\", \"nodes\");\n  const keys = Object.keys(vert);\n  keys.forEach(function (id) {\n    const vertex = vert[id];\n    let classStr = \"default\";\n\n    if (vertex.classes.length > 0) {\n      classStr = vertex.classes.join(\" \");\n    }\n\n    const styles2 = getStylesFromArray(vertex.styles);\n    let vertexText = vertex.text !== void 0 ? vertex.text : vertex.id;\n    let vertexNode;\n    const labelData = {\n      width: 0,\n      height: 0\n    };\n\n    if (evaluate(getConfig().flowchart.htmlLabels)) {\n      const node2 = {\n        label: vertexText.replace(/fa[blrs]?:fa-[\\w-]+/g, s => `<i class='${s.replace(\":\", \" \")}'></i>`)\n      };\n      vertexNode = addHtmlLabel(svg, node2).node();\n      const bbox = vertexNode.getBBox();\n      labelData.width = bbox.width;\n      labelData.height = bbox.height;\n      labelData.labelNode = vertexNode;\n      vertexNode.parentNode.removeChild(vertexNode);\n    } else {\n      const svgLabel = doc.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n      svgLabel.setAttribute(\"style\", styles2.labelStyle.replace(\"color:\", \"fill:\"));\n      const rows = vertexText.split(common.lineBreakRegex);\n\n      for (const row of rows) {\n        const tspan = doc.createElementNS(\"http://www.w3.org/2000/svg\", \"tspan\");\n        tspan.setAttributeNS(\"http://www.w3.org/XML/1998/namespace\", \"xml:space\", \"preserve\");\n        tspan.setAttribute(\"dy\", \"1em\");\n        tspan.setAttribute(\"x\", \"1\");\n        tspan.textContent = row;\n        svgLabel.appendChild(tspan);\n      }\n\n      vertexNode = svgLabel;\n      const bbox = vertexNode.getBBox();\n      labelData.width = bbox.width;\n      labelData.height = bbox.height;\n      labelData.labelNode = vertexNode;\n    }\n\n    const ports = [{\n      id: vertex.id + \"-west\",\n      layoutOptions: {\n        \"port.side\": \"WEST\"\n      }\n    }, {\n      id: vertex.id + \"-east\",\n      layoutOptions: {\n        \"port.side\": \"EAST\"\n      }\n    }, {\n      id: vertex.id + \"-south\",\n      layoutOptions: {\n        \"port.side\": \"SOUTH\"\n      }\n    }, {\n      id: vertex.id + \"-north\",\n      layoutOptions: {\n        \"port.side\": \"NORTH\"\n      }\n    }];\n    let radious = 0;\n    let _shape = \"\";\n    let layoutOptions = {};\n\n    switch (vertex.type) {\n      case \"round\":\n        radious = 5;\n        _shape = \"rect\";\n        break;\n\n      case \"square\":\n        _shape = \"rect\";\n        break;\n\n      case \"diamond\":\n        _shape = \"question\";\n        layoutOptions = {\n          portConstraints: \"FIXED_SIDE\"\n        };\n        break;\n\n      case \"hexagon\":\n        _shape = \"hexagon\";\n        break;\n\n      case \"odd\":\n        _shape = \"rect_left_inv_arrow\";\n        break;\n\n      case \"lean_right\":\n        _shape = \"lean_right\";\n        break;\n\n      case \"lean_left\":\n        _shape = \"lean_left\";\n        break;\n\n      case \"trapezoid\":\n        _shape = \"trapezoid\";\n        break;\n\n      case \"inv_trapezoid\":\n        _shape = \"inv_trapezoid\";\n        break;\n\n      case \"odd_right\":\n        _shape = \"rect_left_inv_arrow\";\n        break;\n\n      case \"circle\":\n        _shape = \"circle\";\n        break;\n\n      case \"ellipse\":\n        _shape = \"ellipse\";\n        break;\n\n      case \"stadium\":\n        _shape = \"stadium\";\n        break;\n\n      case \"subroutine\":\n        _shape = \"subroutine\";\n        break;\n\n      case \"cylinder\":\n        _shape = \"cylinder\";\n        break;\n\n      case \"group\":\n        _shape = \"rect\";\n        break;\n\n      case \"doublecircle\":\n        _shape = \"doublecircle\";\n        break;\n\n      default:\n        _shape = \"rect\";\n    }\n\n    const node = {\n      labelStyle: styles2.labelStyle,\n      shape: _shape,\n      labelText: vertexText,\n      rx: radious,\n      ry: radious,\n      class: classStr,\n      style: styles2.style,\n      id: vertex.id,\n      link: vertex.link,\n      linkTarget: vertex.linkTarget,\n      tooltip: diagObj.db.getTooltip(vertex.id) || \"\",\n      domId: diagObj.db.lookUpDomId(vertex.id),\n      haveCallback: vertex.haveCallback,\n      width: vertex.type === \"group\" ? 500 : void 0,\n      dir: vertex.dir,\n      type: vertex.type,\n      props: vertex.props,\n      padding: getConfig().flowchart.padding\n    };\n    let boundingBox;\n    let nodeEl;\n\n    if (node.type !== \"group\") {\n      nodeEl = insertNode(nodes, node, vertex.dir);\n      boundingBox = nodeEl.node().getBBox();\n    }\n\n    const data = {\n      id: vertex.id,\n      ports: vertex.type === \"diamond\" ? ports : [],\n      // labelStyle: styles.labelStyle,\n      // shape: _shape,\n      layoutOptions,\n      labelText: vertexText,\n      labelData,\n      // labels: [{ text: vertexText }],\n      // rx: radius,\n      // ry: radius,\n      // class: classStr,\n      // style: styles.style,\n      // link: vertex.link,\n      // linkTarget: vertex.linkTarget,\n      // tooltip: diagObj.db.getTooltip(vertex.id) || '',\n      domId: diagObj.db.lookUpDomId(vertex.id),\n      // haveCallback: vertex.haveCallback,\n      width: boundingBox == null ? void 0 : boundingBox.width,\n      height: boundingBox == null ? void 0 : boundingBox.height,\n      // dir: vertex.dir,\n      type: vertex.type,\n      // props: vertex.props,\n      // padding: getConfig().flowchart.padding,\n      // boundingBox,\n      el: nodeEl,\n      parent: parentLookupDb.parentById[vertex.id]\n    };\n    nodeDb[node.id] = data;\n  });\n  return graph;\n};\n\nconst getNextPosition = (position, edgeDirection, graphDirection) => {\n  const portPos2 = {\n    TB: {\n      in: {\n        north: \"north\"\n      },\n      out: {\n        south: \"west\",\n        west: \"east\",\n        east: \"south\"\n      }\n    },\n    LR: {\n      in: {\n        west: \"west\"\n      },\n      out: {\n        east: \"south\",\n        south: \"north\",\n        north: \"east\"\n      }\n    },\n    RL: {\n      in: {\n        east: \"east\"\n      },\n      out: {\n        west: \"north\",\n        north: \"south\",\n        south: \"west\"\n      }\n    },\n    BT: {\n      in: {\n        south: \"south\"\n      },\n      out: {\n        north: \"east\",\n        east: \"west\",\n        west: \"north\"\n      }\n    }\n  };\n  portPos2.TD = portPos2.TB;\n  log.info(\"abc88\", graphDirection, edgeDirection, position);\n  return portPos2[graphDirection][edgeDirection][position];\n};\n\nconst getNextPort = (node, edgeDirection, graphDirection) => {\n  log.info(\"getNextPort abc88\", {\n    node,\n    edgeDirection,\n    graphDirection\n  });\n\n  if (!portPos[node]) {\n    switch (graphDirection) {\n      case \"TB\":\n      case \"TD\":\n        portPos[node] = {\n          inPosition: \"north\",\n          outPosition: \"south\"\n        };\n        break;\n\n      case \"BT\":\n        portPos[node] = {\n          inPosition: \"south\",\n          outPosition: \"north\"\n        };\n        break;\n\n      case \"RL\":\n        portPos[node] = {\n          inPosition: \"east\",\n          outPosition: \"west\"\n        };\n        break;\n\n      case \"LR\":\n        portPos[node] = {\n          inPosition: \"west\",\n          outPosition: \"east\"\n        };\n        break;\n    }\n  }\n\n  const result = edgeDirection === \"in\" ? portPos[node].inPosition : portPos[node].outPosition;\n\n  if (edgeDirection === \"in\") {\n    portPos[node].inPosition = getNextPosition(portPos[node].inPosition, edgeDirection, graphDirection);\n  } else {\n    portPos[node].outPosition = getNextPosition(portPos[node].outPosition, edgeDirection, graphDirection);\n  }\n\n  return result;\n};\n\nconst getEdgeStartEndPoint = (edge, dir) => {\n  let source = edge.start;\n  let target = edge.end;\n  const startNode = nodeDb[source];\n  const endNode = nodeDb[target];\n\n  if (!startNode || !endNode) {\n    return {\n      source,\n      target\n    };\n  }\n\n  if (startNode.type === \"diamond\") {\n    source = `${source}-${getNextPort(source, \"out\", dir)}`;\n  }\n\n  if (endNode.type === \"diamond\") {\n    target = `${target}-${getNextPort(target, \"in\", dir)}`;\n  }\n\n  return {\n    source,\n    target\n  };\n};\n\nconst addEdges = function (edges, diagObj, graph, svg) {\n  log.info(\"abc78 edges = \", edges);\n  const labelsEl = svg.insert(\"g\").attr(\"class\", \"edgeLabels\");\n  let linkIdCnt = {};\n  let dir = diagObj.db.getDirection();\n  let defaultStyle;\n  let defaultLabelStyle;\n\n  if (edges.defaultStyle !== void 0) {\n    const defaultStyles = getStylesFromArray(edges.defaultStyle);\n    defaultStyle = defaultStyles.style;\n    defaultLabelStyle = defaultStyles.labelStyle;\n  }\n\n  edges.forEach(function (edge) {\n    var linkIdBase = \"L-\" + edge.start + \"-\" + edge.end;\n\n    if (linkIdCnt[linkIdBase] === void 0) {\n      linkIdCnt[linkIdBase] = 0;\n      log.info(\"abc78 new entry\", linkIdBase, linkIdCnt[linkIdBase]);\n    } else {\n      linkIdCnt[linkIdBase]++;\n      log.info(\"abc78 new entry\", linkIdBase, linkIdCnt[linkIdBase]);\n    }\n\n    let linkId = linkIdBase + \"-\" + linkIdCnt[linkIdBase];\n    log.info(\"abc78 new link id to be used is\", linkIdBase, linkId, linkIdCnt[linkIdBase]);\n    var linkNameStart = \"LS-\" + edge.start;\n    var linkNameEnd = \"LE-\" + edge.end;\n    const edgeData = {\n      style: \"\",\n      labelStyle: \"\"\n    };\n    edgeData.minlen = edge.length || 1;\n\n    if (edge.type === \"arrow_open\") {\n      edgeData.arrowhead = \"none\";\n    } else {\n      edgeData.arrowhead = \"normal\";\n    }\n\n    edgeData.arrowTypeStart = \"arrow_open\";\n    edgeData.arrowTypeEnd = \"arrow_open\";\n\n    switch (edge.type) {\n      case \"double_arrow_cross\":\n        edgeData.arrowTypeStart = \"arrow_cross\";\n\n      case \"arrow_cross\":\n        edgeData.arrowTypeEnd = \"arrow_cross\";\n        break;\n\n      case \"double_arrow_point\":\n        edgeData.arrowTypeStart = \"arrow_point\";\n\n      case \"arrow_point\":\n        edgeData.arrowTypeEnd = \"arrow_point\";\n        break;\n\n      case \"double_arrow_circle\":\n        edgeData.arrowTypeStart = \"arrow_circle\";\n\n      case \"arrow_circle\":\n        edgeData.arrowTypeEnd = \"arrow_circle\";\n        break;\n    }\n\n    let style = \"\";\n    let labelStyle = \"\";\n\n    switch (edge.stroke) {\n      case \"normal\":\n        style = \"fill:none;\";\n\n        if (defaultStyle !== void 0) {\n          style = defaultStyle;\n        }\n\n        if (defaultLabelStyle !== void 0) {\n          labelStyle = defaultLabelStyle;\n        }\n\n        edgeData.thickness = \"normal\";\n        edgeData.pattern = \"solid\";\n        break;\n\n      case \"dotted\":\n        edgeData.thickness = \"normal\";\n        edgeData.pattern = \"dotted\";\n        edgeData.style = \"fill:none;stroke-width:2px;stroke-dasharray:3;\";\n        break;\n\n      case \"thick\":\n        edgeData.thickness = \"thick\";\n        edgeData.pattern = \"solid\";\n        edgeData.style = \"stroke-width: 3.5px;fill:none;\";\n        break;\n    }\n\n    if (edge.style !== void 0) {\n      const styles2 = getStylesFromArray(edge.style);\n      style = styles2.style;\n      labelStyle = styles2.labelStyle;\n    }\n\n    edgeData.style = edgeData.style += style;\n    edgeData.labelStyle = edgeData.labelStyle += labelStyle;\n\n    if (edge.interpolate !== void 0) {\n      edgeData.curve = interpolateToCurve(edge.interpolate, curveLinear);\n    } else if (edges.defaultInterpolate !== void 0) {\n      edgeData.curve = interpolateToCurve(edges.defaultInterpolate, curveLinear);\n    } else {\n      edgeData.curve = interpolateToCurve(conf.curve, curveLinear);\n    }\n\n    if (edge.text === void 0) {\n      if (edge.style !== void 0) {\n        edgeData.arrowheadStyle = \"fill: #333\";\n      }\n    } else {\n      edgeData.arrowheadStyle = \"fill: #333\";\n      edgeData.labelpos = \"c\";\n    }\n\n    edgeData.labelType = \"text\";\n    edgeData.label = edge.text.replace(common.lineBreakRegex, \"\\n\");\n\n    if (edge.style === void 0) {\n      edgeData.style = edgeData.style || \"stroke: #333; stroke-width: 1.5px;fill:none;\";\n    }\n\n    edgeData.labelStyle = edgeData.labelStyle.replace(\"color:\", \"fill:\");\n    edgeData.id = linkId;\n    edgeData.classes = \"flowchart-link \" + linkNameStart + \" \" + linkNameEnd;\n    const labelEl = insertEdgeLabel(labelsEl, edgeData);\n    const {\n      source,\n      target\n    } = getEdgeStartEndPoint(edge, dir);\n    log.debug(\"abc78 source and target\", source, target);\n    graph.edges.push({\n      id: \"e\" + edge.start + edge.end,\n      sources: [source],\n      targets: [target],\n      labelEl,\n      labels: [{\n        width: edgeData.width,\n        height: edgeData.height,\n        orgWidth: edgeData.width,\n        orgHeight: edgeData.height,\n        text: edgeData.label,\n        layoutOptions: {\n          \"edgeLabels.inline\": \"true\",\n          \"edgeLabels.placement\": \"CENTER\"\n        }\n      }],\n      edgeData\n    });\n  });\n  return graph;\n};\n\nconst addMarkersToEdge = function (svgPath, edgeData, diagramType, arrowMarkerAbsolute) {\n  let url = \"\";\n\n  if (arrowMarkerAbsolute) {\n    url = window.location.protocol + \"//\" + window.location.host + window.location.pathname + window.location.search;\n    url = url.replace(/\\(/g, \"\\\\(\");\n    url = url.replace(/\\)/g, \"\\\\)\");\n  }\n\n  switch (edgeData.arrowTypeStart) {\n    case \"arrow_cross\":\n      svgPath.attr(\"marker-start\", \"url(\" + url + \"#\" + diagramType + \"-crossStart)\");\n      break;\n\n    case \"arrow_point\":\n      svgPath.attr(\"marker-start\", \"url(\" + url + \"#\" + diagramType + \"-pointStart)\");\n      break;\n\n    case \"arrow_barb\":\n      svgPath.attr(\"marker-start\", \"url(\" + url + \"#\" + diagramType + \"-barbStart)\");\n      break;\n\n    case \"arrow_circle\":\n      svgPath.attr(\"marker-start\", \"url(\" + url + \"#\" + diagramType + \"-circleStart)\");\n      break;\n\n    case \"aggregation\":\n      svgPath.attr(\"marker-start\", \"url(\" + url + \"#\" + diagramType + \"-aggregationStart)\");\n      break;\n\n    case \"extension\":\n      svgPath.attr(\"marker-start\", \"url(\" + url + \"#\" + diagramType + \"-extensionStart)\");\n      break;\n\n    case \"composition\":\n      svgPath.attr(\"marker-start\", \"url(\" + url + \"#\" + diagramType + \"-compositionStart)\");\n      break;\n\n    case \"dependency\":\n      svgPath.attr(\"marker-start\", \"url(\" + url + \"#\" + diagramType + \"-dependencyStart)\");\n      break;\n\n    case \"lollipop\":\n      svgPath.attr(\"marker-start\", \"url(\" + url + \"#\" + diagramType + \"-lollipopStart)\");\n      break;\n  }\n\n  switch (edgeData.arrowTypeEnd) {\n    case \"arrow_cross\":\n      svgPath.attr(\"marker-end\", \"url(\" + url + \"#\" + diagramType + \"-crossEnd)\");\n      break;\n\n    case \"arrow_point\":\n      svgPath.attr(\"marker-end\", \"url(\" + url + \"#\" + diagramType + \"-pointEnd)\");\n      break;\n\n    case \"arrow_barb\":\n      svgPath.attr(\"marker-end\", \"url(\" + url + \"#\" + diagramType + \"-barbEnd)\");\n      break;\n\n    case \"arrow_circle\":\n      svgPath.attr(\"marker-end\", \"url(\" + url + \"#\" + diagramType + \"-circleEnd)\");\n      break;\n\n    case \"aggregation\":\n      svgPath.attr(\"marker-end\", \"url(\" + url + \"#\" + diagramType + \"-aggregationEnd)\");\n      break;\n\n    case \"extension\":\n      svgPath.attr(\"marker-end\", \"url(\" + url + \"#\" + diagramType + \"-extensionEnd)\");\n      break;\n\n    case \"composition\":\n      svgPath.attr(\"marker-end\", \"url(\" + url + \"#\" + diagramType + \"-compositionEnd)\");\n      break;\n\n    case \"dependency\":\n      svgPath.attr(\"marker-end\", \"url(\" + url + \"#\" + diagramType + \"-dependencyEnd)\");\n      break;\n\n    case \"lollipop\":\n      svgPath.attr(\"marker-end\", \"url(\" + url + \"#\" + diagramType + \"-lollipopEnd)\");\n      break;\n  }\n};\n\nconst getClasses = function (text, diagObj) {\n  log.info(\"Extracting classes\");\n  diagObj.db.clear(\"ver-2\");\n\n  try {\n    diagObj.parse(text);\n    return diagObj.db.getClasses();\n  } catch (e) {\n    return {};\n  }\n};\n\nconst addSubGraphs = function (db2) {\n  const parentLookupDb = {\n    parentById: {},\n    childrenById: {}\n  };\n  const subgraphs = db2.getSubGraphs();\n  log.info(\"Subgraphs - \", subgraphs);\n  subgraphs.forEach(function (subgraph) {\n    subgraph.nodes.forEach(function (node) {\n      parentLookupDb.parentById[node] = subgraph.id;\n\n      if (parentLookupDb.childrenById[subgraph.id] === void 0) {\n        parentLookupDb.childrenById[subgraph.id] = [];\n      }\n\n      parentLookupDb.childrenById[subgraph.id].push(node);\n    });\n  });\n  subgraphs.forEach(function (subgraph) {\n    ({\n      id: subgraph.id\n    });\n\n    if (parentLookupDb.parentById[subgraph.id] !== void 0) {\n      parentLookupDb.parentById[subgraph.id];\n    }\n  });\n  return parentLookupDb;\n};\n\nconst calcOffset = function (src, dest, parentLookupDb) {\n  const ancestor = findCommonAncestor(src, dest, parentLookupDb);\n\n  if (ancestor === void 0 || ancestor === \"root\") {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n\n  const ancestorOffset = nodeDb[ancestor].offset;\n  return {\n    x: ancestorOffset.posX,\n    y: ancestorOffset.posY\n  };\n};\n\nconst insertEdge = function (edgesEl, edge, edgeData, diagObj, parentLookupDb) {\n  const offset = calcOffset(edge.sources[0], edge.targets[0], parentLookupDb);\n  const src = edge.sections[0].startPoint;\n  const dest = edge.sections[0].endPoint;\n  const segments = edge.sections[0].bendPoints ? edge.sections[0].bendPoints : [];\n  const segPoints = segments.map(segment => [segment.x + offset.x, segment.y + offset.y]);\n  const points = [[src.x + offset.x, src.y + offset.y], ...segPoints, [dest.x + offset.x, dest.y + offset.y]];\n  const curve = line().curve(curveLinear);\n  const edgePath = edgesEl.insert(\"path\").attr(\"d\", curve(points)).attr(\"class\", \"path\").attr(\"fill\", \"none\");\n  const edgeG = edgesEl.insert(\"g\").attr(\"class\", \"edgeLabel\");\n  const edgeWithLabel = select(edgeG.node().appendChild(edge.labelEl));\n  const box = edgeWithLabel.node().firstChild.getBoundingClientRect();\n  edgeWithLabel.attr(\"width\", box.width);\n  edgeWithLabel.attr(\"height\", box.height);\n  edgeG.attr(\"transform\", `translate(${edge.labels[0].x + offset.x}, ${edge.labels[0].y + offset.y})`);\n  addMarkersToEdge(edgePath, edgeData, diagObj.type, diagObj.arrowMarkerAbsolute);\n};\n\nconst insertChildren = (nodeArray, parentLookupDb) => {\n  nodeArray.forEach(node => {\n    if (!node.children) {\n      node.children = [];\n    }\n\n    const childIds = parentLookupDb.childrenById[node.id];\n\n    if (childIds) {\n      childIds.forEach(childId => {\n        node.children.push(nodeDb[childId]);\n      });\n    }\n\n    insertChildren(node.children, parentLookupDb);\n  });\n};\n\nconst draw = async function (text, id, _version, diagObj) {\n  var _a;\n\n  diagObj.db.clear();\n  nodeDb = {};\n  diagObj.db.setGen(\"gen-2\");\n  diagObj.parser.parse(text);\n  const renderEl = select(\"body\").append(\"div\").attr(\"style\", \"height:400px\").attr(\"id\", \"cy\");\n  let graph = {\n    id: \"root\",\n    layoutOptions: {\n      \"elk.hierarchyHandling\": \"INCLUDE_CHILDREN\",\n      \"org.eclipse.elk.padding\": \"[top=100, left=100, bottom=110, right=110]\",\n      \"elk.layered.spacing.edgeNodeBetweenLayers\": \"30\",\n      // 'elk.layered.mergeEdges': 'true',\n      \"elk.direction\": \"DOWN\" // 'elk.ports.sameLayerEdges': true,\n      // 'nodePlacement.strategy': 'SIMPLE',\n\n    },\n    children: [],\n    edges: []\n  };\n  log.info(\"Drawing flowchart using v3 renderer\", elk);\n  let dir = diagObj.db.getDirection();\n\n  switch (dir) {\n    case \"BT\":\n      graph.layoutOptions[\"elk.direction\"] = \"UP\";\n      break;\n\n    case \"TB\":\n      graph.layoutOptions[\"elk.direction\"] = \"DOWN\";\n      break;\n\n    case \"LR\":\n      graph.layoutOptions[\"elk.direction\"] = \"RIGHT\";\n      break;\n\n    case \"RL\":\n      graph.layoutOptions[\"elk.direction\"] = \"LEFT\";\n      break;\n  }\n\n  const {\n    securityLevel,\n    flowchart: conf2\n  } = getConfig();\n  let sandboxElement;\n\n  if (securityLevel === \"sandbox\") {\n    sandboxElement = select(\"#i\" + id);\n  }\n\n  const root = securityLevel === \"sandbox\" ? select(sandboxElement.nodes()[0].contentDocument.body) : select(\"body\");\n  const doc = securityLevel === \"sandbox\" ? sandboxElement.nodes()[0].contentDocument : document;\n  const svg = root.select(`[id=\"${id}\"]`);\n  const markers = [\"point\", \"circle\", \"cross\"];\n  insertMarkers(svg, markers, diagObj.type, diagObj.arrowMarkerAbsolute);\n  const vert = diagObj.db.getVertices();\n  let subG;\n  const subGraphs = diagObj.db.getSubGraphs();\n  log.info(\"Subgraphs - \", subGraphs);\n\n  for (let i = subGraphs.length - 1; i >= 0; i--) {\n    subG = subGraphs[i];\n    diagObj.db.addVertex(subG.id, subG.title, \"group\", void 0, subG.classes, subG.dir);\n  }\n\n  const subGraphsEl = svg.insert(\"g\").attr(\"class\", \"subgraphs\");\n  const parentLookupDb = addSubGraphs(diagObj.db);\n  graph = addVertices(vert, id, root, doc, diagObj, parentLookupDb, graph);\n  const edgesEl = svg.insert(\"g\").attr(\"class\", \"edges edgePath\");\n  const edges = diagObj.db.getEdges();\n  graph = addEdges(edges, diagObj, graph, svg);\n  const nodes = Object.keys(nodeDb);\n  nodes.forEach(nodeId => {\n    const node = nodeDb[nodeId];\n\n    if (!node.parent) {\n      graph.children.push(node);\n    }\n\n    if (parentLookupDb.childrenById[nodeId] !== void 0) {\n      node.labels = [{\n        text: node.labelText,\n        layoutOptions: {\n          \"nodeLabels.placement\": \"[H_CENTER, V_TOP, INSIDE]\"\n        },\n        width: node.labelData.width,\n        height: node.labelData.height\n      }];\n      delete node.x;\n      delete node.y;\n      delete node.width;\n      delete node.height;\n    }\n  });\n  insertChildren(graph.children, parentLookupDb);\n  log.info(\"after layout\", JSON.stringify(graph, null, 2));\n  const g = await elk.layout(graph);\n  drawNodes(0, 0, g.children, svg, subGraphsEl, diagObj, 0);\n  log.info(\"after layout\", g);\n  (_a = g.edges) == null ? void 0 : _a.map(edge => {\n    insertEdge(edgesEl, edge, edge.edgeData, diagObj, parentLookupDb);\n  });\n  setupGraphViewbox({}, svg, conf2.diagramPadding, conf2.useMaxWidth);\n  renderEl.remove();\n};\n\nconst drawNodes = (relX, relY, nodeArray, svg, subgraphsEl, diagObj, depth) => {\n  nodeArray.forEach(function (node) {\n    if (node) {\n      nodeDb[node.id].offset = {\n        posX: node.x + relX,\n        posY: node.y + relY,\n        x: relX,\n        y: relY,\n        depth,\n        width: node.width,\n        height: node.height\n      };\n\n      if (node.type === \"group\") {\n        const subgraphEl = subgraphsEl.insert(\"g\").attr(\"class\", \"subgraph\");\n        subgraphEl.insert(\"rect\").attr(\"class\", \"subgraph subgraph-lvl-\" + depth % 5 + \" node\").attr(\"x\", node.x + relX).attr(\"y\", node.y + relY).attr(\"width\", node.width).attr(\"height\", node.height);\n        const label = subgraphEl.insert(\"g\").attr(\"class\", \"label\");\n        label.attr(\"transform\", `translate(${node.labels[0].x + relX + node.x}, ${node.labels[0].y + relY + node.y})`);\n        label.node().appendChild(node.labelData.labelNode);\n        log.info(\"Id (UGH)= \", node.type, node.labels);\n      } else {\n        log.info(\"Id (UGH)= \", node.id);\n        node.el.attr(\"transform\", `translate(${node.x + relX + node.width / 2}, ${node.y + relY + node.height / 2})`);\n      }\n    }\n  });\n  nodeArray.forEach(function (node) {\n    if (node && node.type === \"group\") {\n      drawNodes(relX + node.x, relY + node.y, node.children, svg, subgraphsEl, diagObj, depth + 1);\n    }\n  });\n};\n\nconst renderer = {\n  getClasses,\n  draw\n};\n\nconst genSections = options => {\n  let sections = \"\";\n\n  for (let i = 0; i < 5; i++) {\n    sections += `\n      .subgraph-lvl-${i} {\n        fill: ${options[`surface${i}`]};\n        stroke: ${options[`surfacePeer${i}`]};\n      }\n    `;\n  }\n\n  return sections;\n};\n\nconst getStyles = options => `.label {\n    font-family: ${options.fontFamily};\n    color: ${options.nodeTextColor || options.textColor};\n  }\n  .cluster-label text {\n    fill: ${options.titleColor};\n  }\n  .cluster-label span {\n    color: ${options.titleColor};\n  }\n\n  .label text,span {\n    fill: ${options.nodeTextColor || options.textColor};\n    color: ${options.nodeTextColor || options.textColor};\n  }\n\n  .node rect,\n  .node circle,\n  .node ellipse,\n  .node polygon,\n  .node path {\n    fill: ${options.mainBkg};\n    stroke: ${options.nodeBorder};\n    stroke-width: 1px;\n  }\n\n  .node .label {\n    text-align: center;\n  }\n  .node.clickable {\n    cursor: pointer;\n  }\n\n  .arrowheadPath {\n    fill: ${options.arrowheadColor};\n  }\n\n  .edgePath .path {\n    stroke: ${options.lineColor};\n    stroke-width: 2.0px;\n  }\n\n  .flowchart-link {\n    stroke: ${options.lineColor};\n    fill: none;\n  }\n\n  .edgeLabel {\n    background-color: ${options.edgeLabelBackground};\n    rect {\n      opacity: 0.5;\n      background-color: ${options.edgeLabelBackground};\n      fill: ${options.edgeLabelBackground};\n    }\n    text-align: center;\n  }\n\n  .cluster rect {\n    fill: ${options.clusterBkg};\n    stroke: ${options.clusterBorder};\n    stroke-width: 1px;\n  }\n\n  .cluster text {\n    fill: ${options.titleColor};\n  }\n\n  .cluster span {\n    color: ${options.titleColor};\n  }\n  /* .cluster div {\n    color: ${options.titleColor};\n  } */\n\n  div.mermaidTooltip {\n    position: absolute;\n    text-align: center;\n    max-width: 200px;\n    padding: 2px;\n    font-family: ${options.fontFamily};\n    font-size: 12px;\n    background: ${options.tertiaryColor};\n    border: 1px solid ${options.border2};\n    border-radius: 2px;\n    pointer-events: none;\n    z-index: 100;\n  }\n\n  .flowchartTitleText {\n    text-anchor: middle;\n    font-size: 18px;\n    fill: ${options.textColor};\n  }\n  .subgraph {\n    stroke-width:2;\n    rx:3;\n  }\n  // .subgraph-lvl-1 {\n  //   fill:#ccc;\n  //   // stroke:black;\n  // }\n  ${genSections(options)}\n`;\n\nconst styles = getStyles;\nconst diagram = {\n  db,\n  renderer,\n  parser,\n  styles\n};\nexport { diagram };","map":{"version":3,"mappings":"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","names":["findCommonAncestor","id1","id2","treeData","parentById","Set","currentId","visited","add","has","elk","ELK","portPos","conf","nodeDb","addVertices","vert","svgId","root","doc","diagObj","parentLookupDb","graph","svg","select","nodes","insert","attr","keys","Object","forEach","id","vertex","classStr","classes","length","join","styles","getStylesFromArray","vertexText","text","vertexNode","labelData","width","height","evaluate","getConfig","flowchart","htmlLabels","node","label","replace","s","addHtmlLabel","bbox","getBBox","labelNode","parentNode","removeChild","svgLabel","createElementNS","setAttribute","labelStyle","rows","split","common","lineBreakRegex","row","tspan","setAttributeNS","textContent","appendChild","ports","layoutOptions","radious","_shape","type","portConstraints","shape","labelText","rx","ry","class","style","link","linkTarget","tooltip","db","getTooltip","domId","lookUpDomId","haveCallback","dir","props","padding","boundingBox","nodeEl","insertNode","data","el","parent","getNextPosition","position","edgeDirection","graphDirection","TB","in","north","out","south","west","east","LR","RL","BT","TD","log","info","getNextPort","inPosition","outPosition","result","getEdgeStartEndPoint","edge","source","start","target","end","startNode","endNode","addEdges","edges","labelsEl","linkIdCnt","getDirection","defaultStyle","defaultLabelStyle","defaultStyles","linkIdBase","linkId","linkNameStart","linkNameEnd","edgeData","minlen","arrowhead","arrowTypeStart","arrowTypeEnd","stroke","thickness","pattern","interpolate","curve","interpolateToCurve","curveLinear","defaultInterpolate","arrowheadStyle","labelpos","labelType","labelEl","insertEdgeLabel","debug","push","sources","targets","labels","orgWidth","orgHeight","addMarkersToEdge","svgPath","diagramType","arrowMarkerAbsolute","url","window","location","protocol","host","pathname","search","getClasses","clear","parse","e","addSubGraphs","childrenById","subgraphs","getSubGraphs","subgraph","calcOffset","src","dest","ancestor","x","y","ancestorOffset","offset","posX","posY","insertEdge","edgesEl","sections","startPoint","endPoint","segments","bendPoints","segPoints","map","segment","points","line","edgePath","edgeG","edgeWithLabel","box","firstChild","getBoundingClientRect","insertChildren","nodeArray","children","childIds","childId","draw","_version","setGen","parser","renderEl","append","securityLevel","sandboxElement","contentDocument","body","document","markers","insertMarkers","getVertices","subG","subGraphs","i","addVertex","title","subGraphsEl","getEdges","nodeId","JSON","stringify","g","layout","drawNodes","setupGraphViewbox","diagramPadding","useMaxWidth","remove","relX","relY","subgraphsEl","depth","subgraphEl","renderer","genSections","options","getStyles","fontFamily","nodeTextColor","textColor","titleColor","mainBkg","nodeBorder","arrowheadColor","lineColor","edgeLabelBackground","clusterBkg","clusterBorder","tertiaryColor","border2","diagram"],"sources":["../src/diagrams/flowchart/elk/render-utils.ts","../src/diagrams/flowchart/elk/flowRenderer-elk.js","../src/diagrams/flowchart/elk/styles.ts","../src/diagrams/flowchart/elk/flowchart-elk-definition.ts"],"sourcesContent":["export interface TreeData {\n  parentById: Record<string, string>;\n  childrenById: Record<string, string[]>;\n}\n\nexport const findCommonAncestor = (id1: string, id2: string, treeData: TreeData) => {\n  const { parentById } = treeData;\n  const visited = new Set();\n  let currentId = id1;\n  while (currentId) {\n    visited.add(currentId);\n    if (currentId === id2) {\n      return currentId;\n    }\n    currentId = parentById[currentId];\n  }\n  currentId = id2;\n  while (currentId) {\n    if (visited.has(currentId)) {\n      return currentId;\n    }\n    currentId = parentById[currentId];\n  }\n  return 'root';\n};\n","import { select, line, curveLinear } from 'd3';\nimport { insertNode } from '../../../dagre-wrapper/nodes.js';\nimport insertMarkers from '../../../dagre-wrapper/markers.js';\nimport { insertEdgeLabel } from '../../../dagre-wrapper/edges.js';\nimport { findCommonAncestor } from './render-utils';\nimport { addHtmlLabel } from 'dagre-d3-es/src/dagre-js/label/add-html-label.js';\nimport { getConfig } from '../../../config';\nimport { log } from '../../../logger';\nimport { setupGraphViewbox } from '../../../setupGraphViewbox';\nimport common, { evaluate } from '../../common/common';\nimport { interpolateToCurve, getStylesFromArray } from '../../../utils';\nimport ELK from 'elkjs/lib/elk.bundled.js';\nconst elk = new ELK();\n\nconst portPos = {};\n\nconst conf = {};\nexport const setConf = function (cnf) {\n  const keys = Object.keys(cnf);\n  for (const key of keys) {\n    conf[key] = cnf[key];\n  }\n};\n\nlet nodeDb = {};\n\n// /**\n//  * Function that adds the vertices found during parsing to the graph to be rendered.\n//  *\n//  * @param vert Object containing the vertices.\n//  * @param g The graph that is to be drawn.\n//  * @param svgId\n//  * @param root\n//  * @param doc\n//  * @param diagObj\n//  */\nexport const addVertices = function (vert, svgId, root, doc, diagObj, parentLookupDb, graph) {\n  const svg = root.select(`[id=\"${svgId}\"]`);\n  const nodes = svg.insert('g').attr('class', 'nodes');\n  const keys = Object.keys(vert);\n\n  // Iterate through each item in the vertex object (containing all the vertices found) in the graph definition\n  keys.forEach(function (id) {\n    const vertex = vert[id];\n\n    /**\n     * Variable for storing the classes for the vertex\n     *\n     * @type {string}\n     */\n    let classStr = 'default';\n    if (vertex.classes.length > 0) {\n      classStr = vertex.classes.join(' ');\n    }\n\n    const styles = getStylesFromArray(vertex.styles);\n\n    // Use vertex id as text in the box if no text is provided by the graph definition\n    let vertexText = vertex.text !== undefined ? vertex.text : vertex.id;\n\n    // We create a SVG label, either by delegating to addHtmlLabel or manually\n    let vertexNode;\n    const labelData = { width: 0, height: 0 };\n    if (evaluate(getConfig().flowchart.htmlLabels)) {\n      // TODO: addHtmlLabel accepts a labelStyle. Do we possibly have that?\n      const node = {\n        label: vertexText.replace(\n          /fa[blrs]?:fa-[\\w-]+/g,\n          (s) => `<i class='${s.replace(':', ' ')}'></i>`\n        ),\n      };\n      vertexNode = addHtmlLabel(svg, node).node();\n      const bbox = vertexNode.getBBox();\n      labelData.width = bbox.width;\n      labelData.height = bbox.height;\n      labelData.labelNode = vertexNode;\n      vertexNode.parentNode.removeChild(vertexNode);\n    } else {\n      const svgLabel = doc.createElementNS('http://www.w3.org/2000/svg', 'text');\n      svgLabel.setAttribute('style', styles.labelStyle.replace('color:', 'fill:'));\n\n      const rows = vertexText.split(common.lineBreakRegex);\n\n      for (const row of rows) {\n        const tspan = doc.createElementNS('http://www.w3.org/2000/svg', 'tspan');\n        tspan.setAttributeNS('http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve');\n        tspan.setAttribute('dy', '1em');\n        tspan.setAttribute('x', '1');\n        tspan.textContent = row;\n        svgLabel.appendChild(tspan);\n      }\n      vertexNode = svgLabel;\n      const bbox = vertexNode.getBBox();\n      labelData.width = bbox.width;\n      labelData.height = bbox.height;\n      labelData.labelNode = vertexNode;\n    }\n\n    const ports = [\n      {\n        id: vertex.id + '-west',\n        layoutOptions: {\n          'port.side': 'WEST',\n        },\n      },\n      {\n        id: vertex.id + '-east',\n        layoutOptions: {\n          'port.side': 'EAST',\n        },\n      },\n      {\n        id: vertex.id + '-south',\n        layoutOptions: {\n          'port.side': 'SOUTH',\n        },\n      },\n      {\n        id: vertex.id + '-north',\n        layoutOptions: {\n          'port.side': 'NORTH',\n        },\n      },\n    ];\n\n    let radious = 0;\n    let _shape = '';\n    let layoutOptions = {};\n    // Set the shape based parameters\n    switch (vertex.type) {\n      case 'round':\n        radious = 5;\n        _shape = 'rect';\n        break;\n      case 'square':\n        _shape = 'rect';\n        break;\n      case 'diamond':\n        _shape = 'question';\n        layoutOptions = {\n          portConstraints: 'FIXED_SIDE',\n        };\n        break;\n      case 'hexagon':\n        _shape = 'hexagon';\n        break;\n      case 'odd':\n        _shape = 'rect_left_inv_arrow';\n        break;\n      case 'lean_right':\n        _shape = 'lean_right';\n        break;\n      case 'lean_left':\n        _shape = 'lean_left';\n        break;\n      case 'trapezoid':\n        _shape = 'trapezoid';\n        break;\n      case 'inv_trapezoid':\n        _shape = 'inv_trapezoid';\n        break;\n      case 'odd_right':\n        _shape = 'rect_left_inv_arrow';\n        break;\n      case 'circle':\n        _shape = 'circle';\n        break;\n      case 'ellipse':\n        _shape = 'ellipse';\n        break;\n      case 'stadium':\n        _shape = 'stadium';\n        break;\n      case 'subroutine':\n        _shape = 'subroutine';\n        break;\n      case 'cylinder':\n        _shape = 'cylinder';\n        break;\n      case 'group':\n        _shape = 'rect';\n        break;\n      case 'doublecircle':\n        _shape = 'doublecircle';\n        break;\n      default:\n        _shape = 'rect';\n    }\n    // Add the node\n    const node = {\n      labelStyle: styles.labelStyle,\n      shape: _shape,\n      labelText: vertexText,\n      rx: radious,\n      ry: radious,\n      class: classStr,\n      style: styles.style,\n      id: vertex.id,\n      link: vertex.link,\n      linkTarget: vertex.linkTarget,\n      tooltip: diagObj.db.getTooltip(vertex.id) || '',\n      domId: diagObj.db.lookUpDomId(vertex.id),\n      haveCallback: vertex.haveCallback,\n      width: vertex.type === 'group' ? 500 : undefined,\n      dir: vertex.dir,\n      type: vertex.type,\n      props: vertex.props,\n      padding: getConfig().flowchart.padding,\n    };\n    let boundingBox;\n    let nodeEl;\n    if (node.type !== 'group') {\n      nodeEl = insertNode(nodes, node, vertex.dir);\n      boundingBox = nodeEl.node().getBBox();\n    }\n\n    const data = {\n      id: vertex.id,\n      ports: vertex.type === 'diamond' ? ports : [],\n      // labelStyle: styles.labelStyle,\n      // shape: _shape,\n      layoutOptions,\n      labelText: vertexText,\n      labelData,\n      // labels: [{ text: vertexText }],\n      // rx: radius,\n      // ry: radius,\n      // class: classStr,\n      // style: styles.style,\n      // link: vertex.link,\n      // linkTarget: vertex.linkTarget,\n      // tooltip: diagObj.db.getTooltip(vertex.id) || '',\n      domId: diagObj.db.lookUpDomId(vertex.id),\n      // haveCallback: vertex.haveCallback,\n      width: boundingBox?.width,\n      height: boundingBox?.height,\n      // dir: vertex.dir,\n      type: vertex.type,\n      // props: vertex.props,\n      // padding: getConfig().flowchart.padding,\n      // boundingBox,\n      el: nodeEl,\n      parent: parentLookupDb.parentById[vertex.id],\n    };\n    // if (!Object.keys(parentLookupDb.childrenById).includes(vertex.id)) {\n    // graph.children.push({\n    //   ...data,\n    // });\n    // }\n    nodeDb[node.id] = data;\n    // log.trace('setNode', {\n    //   labelStyle: styles.labelStyle,\n    //   shape: _shape,\n    //   labelText: vertexText,\n    //   rx: radius,\n    //   ry: radius,\n    //   class: classStr,\n    //   style: styles.style,\n    //   id: vertex.id,\n    //   domId: diagObj.db.lookUpDomId(vertex.id),\n    //   width: vertex.type === 'group' ? 500 : undefined,\n    //   type: vertex.type,\n    //   dir: vertex.dir,\n    //   props: vertex.props,\n    //   padding: getConfig().flowchart.padding,\n    //   parent: parentLookupDb.parentById[vertex.id],\n    // });\n  });\n  return graph;\n};\n\nconst getNextPosition = (position, edgeDirection, graphDirection) => {\n  const portPos = {\n    TB: {\n      in: {\n        north: 'north',\n      },\n      out: {\n        south: 'west',\n        west: 'east',\n        east: 'south',\n      },\n    },\n    LR: {\n      in: {\n        west: 'west',\n      },\n      out: {\n        east: 'south',\n        south: 'north',\n        north: 'east',\n      },\n    },\n    RL: {\n      in: {\n        east: 'east',\n      },\n      out: {\n        west: 'north',\n        north: 'south',\n        south: 'west',\n      },\n    },\n    BT: {\n      in: {\n        south: 'south',\n      },\n      out: {\n        north: 'east',\n        east: 'west',\n        west: 'north',\n      },\n    },\n  };\n  portPos.TD = portPos.TB;\n  log.info('abc88', graphDirection, edgeDirection, position);\n  return portPos[graphDirection][edgeDirection][position];\n  // return 'south';\n};\n\nconst getNextPort = (node, edgeDirection, graphDirection) => {\n  log.info('getNextPort abc88', { node, edgeDirection, graphDirection });\n  if (!portPos[node]) {\n    switch (graphDirection) {\n      case 'TB':\n      case 'TD':\n        portPos[node] = {\n          inPosition: 'north',\n          outPosition: 'south',\n        };\n        break;\n      case 'BT':\n        portPos[node] = {\n          inPosition: 'south',\n          outPosition: 'north',\n        };\n        break;\n      case 'RL':\n        portPos[node] = {\n          inPosition: 'east',\n          outPosition: 'west',\n        };\n        break;\n      case 'LR':\n        portPos[node] = {\n          inPosition: 'west',\n          outPosition: 'east',\n        };\n        break;\n    }\n  }\n  const result = edgeDirection === 'in' ? portPos[node].inPosition : portPos[node].outPosition;\n\n  if (edgeDirection === 'in') {\n    portPos[node].inPosition = getNextPosition(\n      portPos[node].inPosition,\n      edgeDirection,\n      graphDirection\n    );\n  } else {\n    portPos[node].outPosition = getNextPosition(\n      portPos[node].outPosition,\n      edgeDirection,\n      graphDirection\n    );\n  }\n  return result;\n};\n\nconst getEdgeStartEndPoint = (edge, dir) => {\n  let source = edge.start;\n  let target = edge.end;\n\n  const startNode = nodeDb[source];\n  const endNode = nodeDb[target];\n\n  if (!startNode || !endNode) {\n    return { source, target };\n  }\n\n  if (startNode.type === 'diamond') {\n    source = `${source}-${getNextPort(source, 'out', dir)}`;\n  }\n\n  if (endNode.type === 'diamond') {\n    target = `${target}-${getNextPort(target, 'in', dir)}`;\n  }\n\n  // Add the edge to the graph\n  return { source, target };\n};\n\n/**\n * Add edges to graph based on parsed graph definition\n *\n * @param {object} edges The edges to add to the graph\n * @param {object} g The graph object\n * @param cy\n * @param diagObj\n * @param graph\n * @param svg\n */\nexport const addEdges = function (edges, diagObj, graph, svg) {\n  log.info('abc78 edges = ', edges);\n  const labelsEl = svg.insert('g').attr('class', 'edgeLabels');\n  let linkIdCnt = {};\n  let dir = diagObj.db.getDirection();\n  let defaultStyle;\n  let defaultLabelStyle;\n\n  if (edges.defaultStyle !== undefined) {\n    const defaultStyles = getStylesFromArray(edges.defaultStyle);\n    defaultStyle = defaultStyles.style;\n    defaultLabelStyle = defaultStyles.labelStyle;\n  }\n\n  edges.forEach(function (edge) {\n    // Identify Link\n    var linkIdBase = 'L-' + edge.start + '-' + edge.end;\n    // count the links from+to the same node to give unique id\n    if (linkIdCnt[linkIdBase] === undefined) {\n      linkIdCnt[linkIdBase] = 0;\n      log.info('abc78 new entry', linkIdBase, linkIdCnt[linkIdBase]);\n    } else {\n      linkIdCnt[linkIdBase]++;\n      log.info('abc78 new entry', linkIdBase, linkIdCnt[linkIdBase]);\n    }\n    let linkId = linkIdBase + '-' + linkIdCnt[linkIdBase];\n    log.info('abc78 new link id to be used is', linkIdBase, linkId, linkIdCnt[linkIdBase]);\n    var linkNameStart = 'LS-' + edge.start;\n    var linkNameEnd = 'LE-' + edge.end;\n\n    const edgeData = { style: '', labelStyle: '' };\n    edgeData.minlen = edge.length || 1;\n    //edgeData.id = 'id' + cnt;\n\n    // Set link type for rendering\n    if (edge.type === 'arrow_open') {\n      edgeData.arrowhead = 'none';\n    } else {\n      edgeData.arrowhead = 'normal';\n    }\n\n    // Check of arrow types, placed here in order not to break old rendering\n    edgeData.arrowTypeStart = 'arrow_open';\n    edgeData.arrowTypeEnd = 'arrow_open';\n\n    /* eslint-disable no-fallthrough */\n    switch (edge.type) {\n      case 'double_arrow_cross':\n        edgeData.arrowTypeStart = 'arrow_cross';\n      case 'arrow_cross':\n        edgeData.arrowTypeEnd = 'arrow_cross';\n        break;\n      case 'double_arrow_point':\n        edgeData.arrowTypeStart = 'arrow_point';\n      case 'arrow_point':\n        edgeData.arrowTypeEnd = 'arrow_point';\n        break;\n      case 'double_arrow_circle':\n        edgeData.arrowTypeStart = 'arrow_circle';\n      case 'arrow_circle':\n        edgeData.arrowTypeEnd = 'arrow_circle';\n        break;\n    }\n\n    let style = '';\n    let labelStyle = '';\n\n    switch (edge.stroke) {\n      case 'normal':\n        style = 'fill:none;';\n        if (defaultStyle !== undefined) {\n          style = defaultStyle;\n        }\n        if (defaultLabelStyle !== undefined) {\n          labelStyle = defaultLabelStyle;\n        }\n        edgeData.thickness = 'normal';\n        edgeData.pattern = 'solid';\n        break;\n      case 'dotted':\n        edgeData.thickness = 'normal';\n        edgeData.pattern = 'dotted';\n        edgeData.style = 'fill:none;stroke-width:2px;stroke-dasharray:3;';\n        break;\n      case 'thick':\n        edgeData.thickness = 'thick';\n        edgeData.pattern = 'solid';\n        edgeData.style = 'stroke-width: 3.5px;fill:none;';\n        break;\n    }\n    if (edge.style !== undefined) {\n      const styles = getStylesFromArray(edge.style);\n      style = styles.style;\n      labelStyle = styles.labelStyle;\n    }\n\n    edgeData.style = edgeData.style += style;\n    edgeData.labelStyle = edgeData.labelStyle += labelStyle;\n\n    if (edge.interpolate !== undefined) {\n      edgeData.curve = interpolateToCurve(edge.interpolate, curveLinear);\n    } else if (edges.defaultInterpolate !== undefined) {\n      edgeData.curve = interpolateToCurve(edges.defaultInterpolate, curveLinear);\n    } else {\n      edgeData.curve = interpolateToCurve(conf.curve, curveLinear);\n    }\n\n    if (edge.text === undefined) {\n      if (edge.style !== undefined) {\n        edgeData.arrowheadStyle = 'fill: #333';\n      }\n    } else {\n      edgeData.arrowheadStyle = 'fill: #333';\n      edgeData.labelpos = 'c';\n    }\n\n    edgeData.labelType = 'text';\n    edgeData.label = edge.text.replace(common.lineBreakRegex, '\\n');\n\n    if (edge.style === undefined) {\n      edgeData.style = edgeData.style || 'stroke: #333; stroke-width: 1.5px;fill:none;';\n    }\n\n    edgeData.labelStyle = edgeData.labelStyle.replace('color:', 'fill:');\n\n    edgeData.id = linkId;\n    edgeData.classes = 'flowchart-link ' + linkNameStart + ' ' + linkNameEnd;\n\n    const labelEl = insertEdgeLabel(labelsEl, edgeData);\n\n    // calculate start and end points of the edge\n    const { source, target } = getEdgeStartEndPoint(edge, dir);\n    log.debug('abc78 source and target', source, target);\n    // Add the edge to the graph\n    graph.edges.push({\n      id: 'e' + edge.start + edge.end,\n      sources: [source],\n      targets: [target],\n      labelEl: labelEl,\n      labels: [\n        {\n          width: edgeData.width,\n          height: edgeData.height,\n          orgWidth: edgeData.width,\n          orgHeight: edgeData.height,\n          text: edgeData.label,\n          layoutOptions: {\n            'edgeLabels.inline': 'true',\n            'edgeLabels.placement': 'CENTER',\n          },\n        },\n      ],\n      edgeData,\n    });\n  });\n  return graph;\n};\n\n// TODO: break out and share with dagre wrapper. The current code in dagre wrapper also adds\n// adds the line to the graph, but we don't need that here. This is why we cant use the dagre\n// wrapper directly for this\n/**\n * Add the markers to the edge depending on the type of arrow is\n * @param svgPath\n * @param edgeData\n * @param diagramType\n * @param arrowMarkerAbsolute\n */\nconst addMarkersToEdge = function (svgPath, edgeData, diagramType, arrowMarkerAbsolute) {\n  let url = '';\n  // Check configuration for absolute path\n  if (arrowMarkerAbsolute) {\n    url =\n      window.location.protocol +\n      '//' +\n      window.location.host +\n      window.location.pathname +\n      window.location.search;\n    url = url.replace(/\\(/g, '\\\\(');\n    url = url.replace(/\\)/g, '\\\\)');\n  }\n\n  // look in edge data and decide which marker to use\n  switch (edgeData.arrowTypeStart) {\n    case 'arrow_cross':\n      svgPath.attr('marker-start', 'url(' + url + '#' + diagramType + '-crossStart' + ')');\n      break;\n    case 'arrow_point':\n      svgPath.attr('marker-start', 'url(' + url + '#' + diagramType + '-pointStart' + ')');\n      break;\n    case 'arrow_barb':\n      svgPath.attr('marker-start', 'url(' + url + '#' + diagramType + '-barbStart' + ')');\n      break;\n    case 'arrow_circle':\n      svgPath.attr('marker-start', 'url(' + url + '#' + diagramType + '-circleStart' + ')');\n      break;\n    case 'aggregation':\n      svgPath.attr('marker-start', 'url(' + url + '#' + diagramType + '-aggregationStart' + ')');\n      break;\n    case 'extension':\n      svgPath.attr('marker-start', 'url(' + url + '#' + diagramType + '-extensionStart' + ')');\n      break;\n    case 'composition':\n      svgPath.attr('marker-start', 'url(' + url + '#' + diagramType + '-compositionStart' + ')');\n      break;\n    case 'dependency':\n      svgPath.attr('marker-start', 'url(' + url + '#' + diagramType + '-dependencyStart' + ')');\n      break;\n    case 'lollipop':\n      svgPath.attr('marker-start', 'url(' + url + '#' + diagramType + '-lollipopStart' + ')');\n      break;\n    default:\n  }\n  switch (edgeData.arrowTypeEnd) {\n    case 'arrow_cross':\n      svgPath.attr('marker-end', 'url(' + url + '#' + diagramType + '-crossEnd' + ')');\n      break;\n    case 'arrow_point':\n      svgPath.attr('marker-end', 'url(' + url + '#' + diagramType + '-pointEnd' + ')');\n      break;\n    case 'arrow_barb':\n      svgPath.attr('marker-end', 'url(' + url + '#' + diagramType + '-barbEnd' + ')');\n      break;\n    case 'arrow_circle':\n      svgPath.attr('marker-end', 'url(' + url + '#' + diagramType + '-circleEnd' + ')');\n      break;\n    case 'aggregation':\n      svgPath.attr('marker-end', 'url(' + url + '#' + diagramType + '-aggregationEnd' + ')');\n      break;\n    case 'extension':\n      svgPath.attr('marker-end', 'url(' + url + '#' + diagramType + '-extensionEnd' + ')');\n      break;\n    case 'composition':\n      svgPath.attr('marker-end', 'url(' + url + '#' + diagramType + '-compositionEnd' + ')');\n      break;\n    case 'dependency':\n      svgPath.attr('marker-end', 'url(' + url + '#' + diagramType + '-dependencyEnd' + ')');\n      break;\n    case 'lollipop':\n      svgPath.attr('marker-end', 'url(' + url + '#' + diagramType + '-lollipopEnd' + ')');\n      break;\n    default:\n  }\n};\n\n/**\n * Returns the all the styles from classDef statements in the graph definition.\n *\n * @param text\n * @param diagObj\n * @returns {object} ClassDef styles\n */\nexport const getClasses = function (text, diagObj) {\n  log.info('Extracting classes');\n  diagObj.db.clear('ver-2');\n  try {\n    // Parse the graph definition\n    diagObj.parse(text);\n    return diagObj.db.getClasses();\n  } catch (e) {\n    return {};\n  }\n};\n\nconst addSubGraphs = function (db) {\n  const parentLookupDb = { parentById: {}, childrenById: {} };\n  const subgraphs = db.getSubGraphs();\n  log.info('Subgraphs - ', subgraphs);\n  subgraphs.forEach(function (subgraph) {\n    subgraph.nodes.forEach(function (node) {\n      parentLookupDb.parentById[node] = subgraph.id;\n      if (parentLookupDb.childrenById[subgraph.id] === undefined) {\n        parentLookupDb.childrenById[subgraph.id] = [];\n      }\n      parentLookupDb.childrenById[subgraph.id].push(node);\n    });\n  });\n\n  subgraphs.forEach(function (subgraph) {\n    const data = { id: subgraph.id };\n    if (parentLookupDb.parentById[subgraph.id] !== undefined) {\n      data.parent = parentLookupDb.parentById[subgraph.id];\n    }\n  });\n  return parentLookupDb;\n};\n\nconst calcOffset = function (src, dest, parentLookupDb) {\n  const ancestor = findCommonAncestor(src, dest, parentLookupDb);\n  if (ancestor === undefined || ancestor === 'root') {\n    return { x: 0, y: 0 };\n  }\n\n  const ancestorOffset = nodeDb[ancestor].offset;\n  return { x: ancestorOffset.posX, y: ancestorOffset.posY };\n};\n\nconst insertEdge = function (edgesEl, edge, edgeData, diagObj, parentLookupDb) {\n  const offset = calcOffset(edge.sources[0], edge.targets[0], parentLookupDb);\n\n  const src = edge.sections[0].startPoint;\n  const dest = edge.sections[0].endPoint;\n  const segments = edge.sections[0].bendPoints ? edge.sections[0].bendPoints : [];\n\n  const segPoints = segments.map((segment) => [segment.x + offset.x, segment.y + offset.y]);\n  const points = [\n    [src.x + offset.x, src.y + offset.y],\n    ...segPoints,\n    [dest.x + offset.x, dest.y + offset.y],\n  ];\n\n  // const curve = line().curve(curveBasis);\n  const curve = line().curve(curveLinear);\n  const edgePath = edgesEl\n    .insert('path')\n    .attr('d', curve(points))\n    .attr('class', 'path')\n    .attr('fill', 'none');\n  const edgeG = edgesEl.insert('g').attr('class', 'edgeLabel');\n  const edgeWithLabel = select(edgeG.node().appendChild(edge.labelEl));\n  const box = edgeWithLabel.node().firstChild.getBoundingClientRect();\n  edgeWithLabel.attr('width', box.width);\n  edgeWithLabel.attr('height', box.height);\n\n  edgeG.attr(\n    'transform',\n    `translate(${edge.labels[0].x + offset.x}, ${edge.labels[0].y + offset.y})`\n  );\n  addMarkersToEdge(edgePath, edgeData, diagObj.type, diagObj.arrowMarkerAbsolute);\n};\n\n/**\n * Recursive function that iterates over an array of nodes and inserts the children of each node.\n * It also recursively populates the inserts the children of the children and so on.\n * @param {*} graph\n * @param nodeArray\n * @param parentLookupDb\n */\nconst insertChildren = (nodeArray, parentLookupDb) => {\n  nodeArray.forEach((node) => {\n    // Check if we have reached the end of the tree\n    if (!node.children) {\n      node.children = [];\n    }\n    // Check if the node has children\n    const childIds = parentLookupDb.childrenById[node.id];\n    // If the node has children, add them to the node\n    if (childIds) {\n      childIds.forEach((childId) => {\n        node.children.push(nodeDb[childId]);\n      });\n    }\n    // Recursive call\n    insertChildren(node.children, parentLookupDb);\n  });\n};\n\n/**\n * Draws a flowchart in the tag with id: id based on the graph definition in text.\n *\n * @param text\n * @param id\n */\n\nexport const draw = async function (text, id, _version, diagObj) {\n  // Add temporary render element\n  diagObj.db.clear();\n  nodeDb = {};\n  diagObj.db.setGen('gen-2');\n  // Parse the graph definition\n  diagObj.parser.parse(text);\n\n  const renderEl = select('body').append('div').attr('style', 'height:400px').attr('id', 'cy');\n  let graph = {\n    id: 'root',\n    layoutOptions: {\n      'elk.hierarchyHandling': 'INCLUDE_CHILDREN',\n      'org.eclipse.elk.padding': '[top=100, left=100, bottom=110, right=110]',\n      'elk.layered.spacing.edgeNodeBetweenLayers': '30',\n      // 'elk.layered.mergeEdges': 'true',\n      'elk.direction': 'DOWN',\n      // 'elk.ports.sameLayerEdges': true,\n      // 'nodePlacement.strategy': 'SIMPLE',\n    },\n    children: [],\n    edges: [],\n  };\n  log.info('Drawing flowchart using v3 renderer', elk);\n\n  // Set the direction,\n  // Fetch the default direction, use TD if none was found\n  let dir = diagObj.db.getDirection();\n  switch (dir) {\n    case 'BT':\n      graph.layoutOptions['elk.direction'] = 'UP';\n      break;\n    case 'TB':\n      graph.layoutOptions['elk.direction'] = 'DOWN';\n      break;\n    case 'LR':\n      graph.layoutOptions['elk.direction'] = 'RIGHT';\n      break;\n    case 'RL':\n      graph.layoutOptions['elk.direction'] = 'LEFT';\n      break;\n  }\n  const { securityLevel, flowchart: conf } = getConfig();\n\n  // Find the root dom node to ne used in rendering\n  // Handle root and document for when rendering in sandbox mode\n  let sandboxElement;\n  if (securityLevel === 'sandbox') {\n    sandboxElement = select('#i' + id);\n  }\n  const root =\n    securityLevel === 'sandbox'\n      ? select(sandboxElement.nodes()[0].contentDocument.body)\n      : select('body');\n  const doc = securityLevel === 'sandbox' ? sandboxElement.nodes()[0].contentDocument : document;\n\n  const svg = root.select(`[id=\"${id}\"]`);\n\n  // Define the supported markers for the diagram\n  const markers = ['point', 'circle', 'cross'];\n\n  // Add the marker definitions to the svg as marker tags\n  insertMarkers(svg, markers, diagObj.type, diagObj.arrowMarkerAbsolute);\n\n  // Fetch the vertices/nodes and edges/links from the parsed graph definition\n  const vert = diagObj.db.getVertices();\n\n  // Setup nodes from the subgraphs with type group, these will be used\n  // as nodes with children in the subgraph\n  let subG;\n  const subGraphs = diagObj.db.getSubGraphs();\n  log.info('Subgraphs - ', subGraphs);\n  for (let i = subGraphs.length - 1; i >= 0; i--) {\n    subG = subGraphs[i];\n    diagObj.db.addVertex(subG.id, subG.title, 'group', undefined, subG.classes, subG.dir);\n  }\n\n  // Add an element in the svg to be used to hold the subgraphs container\n  // elements\n  const subGraphsEl = svg.insert('g').attr('class', 'subgraphs');\n\n  // Create the lookup db for the subgraphs and their children to used when creating\n  // the tree structured graph\n  const parentLookupDb = addSubGraphs(diagObj.db);\n\n  // Add the nodes to the graph, this will entail creating the actual nodes\n  // in order to get the size of the node. You can't get the size of a node\n  // that is not in the dom so we need to add it to the dom, get the size\n  // we will position the nodes when we get the layout from elkjs\n  graph = addVertices(vert, id, root, doc, diagObj, parentLookupDb, graph);\n\n  // Time for the edges, we start with adding an element in the node to hold the edges\n  const edgesEl = svg.insert('g').attr('class', 'edges edgePath');\n  // Fetch the edges form the parsed graph definition\n  const edges = diagObj.db.getEdges();\n\n  // Add the edges to the graph, this will entail creating the actual edges\n  graph = addEdges(edges, diagObj, graph, svg);\n\n  // Iterate through all nodes and add the top level nodes to the graph\n  const nodes = Object.keys(nodeDb);\n  nodes.forEach((nodeId) => {\n    const node = nodeDb[nodeId];\n    if (!node.parent) {\n      graph.children.push(node);\n    }\n    // Subgraph\n    if (parentLookupDb.childrenById[nodeId] !== undefined) {\n      node.labels = [\n        {\n          text: node.labelText,\n          layoutOptions: {\n            'nodeLabels.placement': '[H_CENTER, V_TOP, INSIDE]',\n          },\n          width: node.labelData.width,\n          height: node.labelData.height,\n        },\n      ];\n      delete node.x;\n      delete node.y;\n      delete node.width;\n      delete node.height;\n    }\n  });\n  insertChildren(graph.children, parentLookupDb);\n  log.info('after layout', JSON.stringify(graph, null, 2));\n  const g = await elk.layout(graph);\n  drawNodes(0, 0, g.children, svg, subGraphsEl, diagObj, 0);\n  log.info('after layout', g);\n  g.edges?.map((edge) => {\n    insertEdge(edgesEl, edge, edge.edgeData, diagObj, parentLookupDb);\n  });\n  setupGraphViewbox({}, svg, conf.diagramPadding, conf.useMaxWidth);\n  // Remove element after layout\n  renderEl.remove();\n};\n\nconst drawNodes = (relX, relY, nodeArray, svg, subgraphsEl, diagObj, depth) => {\n  nodeArray.forEach(function (node) {\n    if (node) {\n      nodeDb[node.id].offset = {\n        posX: node.x + relX,\n        posY: node.y + relY,\n        x: relX,\n        y: relY,\n        depth,\n        width: node.width,\n        height: node.height,\n      };\n      if (node.type === 'group') {\n        const subgraphEl = subgraphsEl.insert('g').attr('class', 'subgraph');\n        subgraphEl\n          .insert('rect')\n          .attr('class', 'subgraph subgraph-lvl-' + (depth % 5) + ' node')\n          .attr('x', node.x + relX)\n          .attr('y', node.y + relY)\n          .attr('width', node.width)\n          .attr('height', node.height);\n        const label = subgraphEl.insert('g').attr('class', 'label');\n        label.attr(\n          'transform',\n          `translate(${node.labels[0].x + relX + node.x}, ${node.labels[0].y + relY + node.y})`\n        );\n        label.node().appendChild(node.labelData.labelNode);\n\n        log.info('Id (UGH)= ', node.type, node.labels);\n      } else {\n        log.info('Id (UGH)= ', node.id);\n        node.el.attr(\n          'transform',\n          `translate(${node.x + relX + node.width / 2}, ${node.y + relY + node.height / 2})`\n        );\n      }\n    }\n  });\n  nodeArray.forEach(function (node) {\n    if (node && node.type === 'group') {\n      drawNodes(relX + node.x, relY + node.y, node.children, svg, subgraphsEl, diagObj, depth + 1);\n    }\n  });\n};\n\nexport default {\n  getClasses,\n  draw,\n};\n","/** Returns the styles given options */\nexport interface FlowChartStyleOptions {\n  arrowheadColor: string;\n  border2: string;\n  clusterBkg: string;\n  clusterBorder: string;\n  edgeLabelBackground: string;\n  fontFamily: string;\n  lineColor: string;\n  mainBkg: string;\n  nodeBorder: string;\n  nodeTextColor: string;\n  tertiaryColor: string;\n  textColor: string;\n  titleColor: string;\n  [key: string]: string;\n}\n\nconst genSections = (options: FlowChartStyleOptions) => {\n  let sections = '';\n\n  for (let i = 0; i < 5; i++) {\n    sections += `\n      .subgraph-lvl-${i} {\n        fill: ${options[`surface${i}`]};\n        stroke: ${options[`surfacePeer${i}`]};\n      }\n    `;\n  }\n  return sections;\n};\n\nconst getStyles = (options: FlowChartStyleOptions) =>\n  `.label {\n    font-family: ${options.fontFamily};\n    color: ${options.nodeTextColor || options.textColor};\n  }\n  .cluster-label text {\n    fill: ${options.titleColor};\n  }\n  .cluster-label span {\n    color: ${options.titleColor};\n  }\n\n  .label text,span {\n    fill: ${options.nodeTextColor || options.textColor};\n    color: ${options.nodeTextColor || options.textColor};\n  }\n\n  .node rect,\n  .node circle,\n  .node ellipse,\n  .node polygon,\n  .node path {\n    fill: ${options.mainBkg};\n    stroke: ${options.nodeBorder};\n    stroke-width: 1px;\n  }\n\n  .node .label {\n    text-align: center;\n  }\n  .node.clickable {\n    cursor: pointer;\n  }\n\n  .arrowheadPath {\n    fill: ${options.arrowheadColor};\n  }\n\n  .edgePath .path {\n    stroke: ${options.lineColor};\n    stroke-width: 2.0px;\n  }\n\n  .flowchart-link {\n    stroke: ${options.lineColor};\n    fill: none;\n  }\n\n  .edgeLabel {\n    background-color: ${options.edgeLabelBackground};\n    rect {\n      opacity: 0.5;\n      background-color: ${options.edgeLabelBackground};\n      fill: ${options.edgeLabelBackground};\n    }\n    text-align: center;\n  }\n\n  .cluster rect {\n    fill: ${options.clusterBkg};\n    stroke: ${options.clusterBorder};\n    stroke-width: 1px;\n  }\n\n  .cluster text {\n    fill: ${options.titleColor};\n  }\n\n  .cluster span {\n    color: ${options.titleColor};\n  }\n  /* .cluster div {\n    color: ${options.titleColor};\n  } */\n\n  div.mermaidTooltip {\n    position: absolute;\n    text-align: center;\n    max-width: 200px;\n    padding: 2px;\n    font-family: ${options.fontFamily};\n    font-size: 12px;\n    background: ${options.tertiaryColor};\n    border: 1px solid ${options.border2};\n    border-radius: 2px;\n    pointer-events: none;\n    z-index: 100;\n  }\n\n  .flowchartTitleText {\n    text-anchor: middle;\n    font-size: 18px;\n    fill: ${options.textColor};\n  }\n  .subgraph {\n    stroke-width:2;\n    rx:3;\n  }\n  // .subgraph-lvl-1 {\n  //   fill:#ccc;\n  //   // stroke:black;\n  // }\n  ${genSections(options)}\n`;\n\nexport default getStyles;\n","// @ts-ignore: JISON typing missing\nimport parser from '../parser/flow';\n\nimport * as db from '../flowDb';\nimport renderer from './flowRenderer-elk';\nimport styles from './styles';\n\nexport const diagram = {\n  db,\n  renderer,\n  parser,\n  styles,\n};\n"]},"metadata":{},"sourceType":"module"}