{"ast":null,"code":"/*!\n  * @intlify/message-resolver v9.1.10\n  * (c) 2022 kazuya kawaguchi\n  * Released under the MIT License.\n  */\n\n/**\r\n * Original Utilities\r\n * written by kazuya kawaguchi\r\n */\nif (process.env.NODE_ENV !== 'production') ;\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction hasOwn(obj, key) {\n  return hasOwnProperty.call(obj, key);\n}\n\nconst isObject = val => // eslint-disable-line\nval !== null && typeof val === 'object';\n\nconst pathStateMachine = [];\npathStateMachine[0\n/* BEFORE_PATH */\n] = {\n  [\"w\"\n  /* WORKSPACE */\n  ]: [0\n  /* BEFORE_PATH */\n  ],\n  [\"i\"\n  /* IDENT */\n  ]: [3\n  /* IN_IDENT */\n  , 0\n  /* APPEND */\n  ],\n  [\"[\"\n  /* LEFT_BRACKET */\n  ]: [4\n  /* IN_SUB_PATH */\n  ],\n  [\"o\"\n  /* END_OF_FAIL */\n  ]: [7\n  /* AFTER_PATH */\n  ]\n};\npathStateMachine[1\n/* IN_PATH */\n] = {\n  [\"w\"\n  /* WORKSPACE */\n  ]: [1\n  /* IN_PATH */\n  ],\n  [\".\"\n  /* DOT */\n  ]: [2\n  /* BEFORE_IDENT */\n  ],\n  [\"[\"\n  /* LEFT_BRACKET */\n  ]: [4\n  /* IN_SUB_PATH */\n  ],\n  [\"o\"\n  /* END_OF_FAIL */\n  ]: [7\n  /* AFTER_PATH */\n  ]\n};\npathStateMachine[2\n/* BEFORE_IDENT */\n] = {\n  [\"w\"\n  /* WORKSPACE */\n  ]: [2\n  /* BEFORE_IDENT */\n  ],\n  [\"i\"\n  /* IDENT */\n  ]: [3\n  /* IN_IDENT */\n  , 0\n  /* APPEND */\n  ],\n  [\"0\"\n  /* ZERO */\n  ]: [3\n  /* IN_IDENT */\n  , 0\n  /* APPEND */\n  ]\n};\npathStateMachine[3\n/* IN_IDENT */\n] = {\n  [\"i\"\n  /* IDENT */\n  ]: [3\n  /* IN_IDENT */\n  , 0\n  /* APPEND */\n  ],\n  [\"0\"\n  /* ZERO */\n  ]: [3\n  /* IN_IDENT */\n  , 0\n  /* APPEND */\n  ],\n  [\"w\"\n  /* WORKSPACE */\n  ]: [1\n  /* IN_PATH */\n  , 1\n  /* PUSH */\n  ],\n  [\".\"\n  /* DOT */\n  ]: [2\n  /* BEFORE_IDENT */\n  , 1\n  /* PUSH */\n  ],\n  [\"[\"\n  /* LEFT_BRACKET */\n  ]: [4\n  /* IN_SUB_PATH */\n  , 1\n  /* PUSH */\n  ],\n  [\"o\"\n  /* END_OF_FAIL */\n  ]: [7\n  /* AFTER_PATH */\n  , 1\n  /* PUSH */\n  ]\n};\npathStateMachine[4\n/* IN_SUB_PATH */\n] = {\n  [\"'\"\n  /* SINGLE_QUOTE */\n  ]: [5\n  /* IN_SINGLE_QUOTE */\n  , 0\n  /* APPEND */\n  ],\n  [\"\\\"\"\n  /* DOUBLE_QUOTE */\n  ]: [6\n  /* IN_DOUBLE_QUOTE */\n  , 0\n  /* APPEND */\n  ],\n  [\"[\"\n  /* LEFT_BRACKET */\n  ]: [4\n  /* IN_SUB_PATH */\n  , 2\n  /* INC_SUB_PATH_DEPTH */\n  ],\n  [\"]\"\n  /* RIGHT_BRACKET */\n  ]: [1\n  /* IN_PATH */\n  , 3\n  /* PUSH_SUB_PATH */\n  ],\n  [\"o\"\n  /* END_OF_FAIL */\n  ]: 8\n  /* ERROR */\n  ,\n  [\"l\"\n  /* ELSE */\n  ]: [4\n  /* IN_SUB_PATH */\n  , 0\n  /* APPEND */\n  ]\n};\npathStateMachine[5\n/* IN_SINGLE_QUOTE */\n] = {\n  [\"'\"\n  /* SINGLE_QUOTE */\n  ]: [4\n  /* IN_SUB_PATH */\n  , 0\n  /* APPEND */\n  ],\n  [\"o\"\n  /* END_OF_FAIL */\n  ]: 8\n  /* ERROR */\n  ,\n  [\"l\"\n  /* ELSE */\n  ]: [5\n  /* IN_SINGLE_QUOTE */\n  , 0\n  /* APPEND */\n  ]\n};\npathStateMachine[6\n/* IN_DOUBLE_QUOTE */\n] = {\n  [\"\\\"\"\n  /* DOUBLE_QUOTE */\n  ]: [4\n  /* IN_SUB_PATH */\n  , 0\n  /* APPEND */\n  ],\n  [\"o\"\n  /* END_OF_FAIL */\n  ]: 8\n  /* ERROR */\n  ,\n  [\"l\"\n  /* ELSE */\n  ]: [6\n  /* IN_DOUBLE_QUOTE */\n  , 0\n  /* APPEND */\n  ]\n};\n/**\r\n * Check if an expression is a literal value.\r\n */\n\nconst literalValueRE = /^\\s?(?:true|false|-?[\\d.]+|'[^']*'|\"[^\"]*\")\\s?$/;\n\nfunction isLiteral(exp) {\n  return literalValueRE.test(exp);\n}\n/**\r\n * Strip quotes from a string\r\n */\n\n\nfunction stripQuotes(str) {\n  const a = str.charCodeAt(0);\n  const b = str.charCodeAt(str.length - 1);\n  return a === b && (a === 0x22 || a === 0x27) ? str.slice(1, -1) : str;\n}\n/**\r\n * Determine the type of a character in a keypath.\r\n */\n\n\nfunction getPathCharType(ch) {\n  if (ch === undefined || ch === null) {\n    return \"o\"\n    /* END_OF_FAIL */\n    ;\n  }\n\n  const code = ch.charCodeAt(0);\n\n  switch (code) {\n    case 0x5b: // [\n\n    case 0x5d: // ]\n\n    case 0x2e: // .\n\n    case 0x22: // \"\n\n    case 0x27:\n      // '\n      return ch;\n\n    case 0x5f: // _\n\n    case 0x24: // $\n\n    case 0x2d:\n      // -\n      return \"i\"\n      /* IDENT */\n      ;\n\n    case 0x09: // Tab (HT)\n\n    case 0x0a: // Newline (LF)\n\n    case 0x0d: // Return (CR)\n\n    case 0xa0: // No-break space (NBSP)\n\n    case 0xfeff: // Byte Order Mark (BOM)\n\n    case 0x2028: // Line Separator (LS)\n\n    case 0x2029:\n      // Paragraph Separator (PS)\n      return \"w\"\n      /* WORKSPACE */\n      ;\n  }\n\n  return \"i\"\n  /* IDENT */\n  ;\n}\n/**\r\n * Format a subPath, return its plain form if it is\r\n * a literal string or number. Otherwise prepend the\r\n * dynamic indicator (*).\r\n */\n\n\nfunction formatSubPath(path) {\n  const trimmed = path.trim(); // invalid leading 0\n\n  if (path.charAt(0) === '0' && isNaN(parseInt(path))) {\n    return false;\n  }\n\n  return isLiteral(trimmed) ? stripQuotes(trimmed) : \"*\"\n  /* ASTARISK */\n  + trimmed;\n}\n/**\r\n * Parse a string path into an array of segments\r\n */\n\n\nfunction parse(path) {\n  const keys = [];\n  let index = -1;\n  let mode = 0\n  /* BEFORE_PATH */\n  ;\n  let subPathDepth = 0;\n  let c;\n  let key; // eslint-disable-line\n\n  let newChar;\n  let type;\n  let transition;\n  let action;\n  let typeMap;\n  const actions = [];\n\n  actions[0\n  /* APPEND */\n  ] = () => {\n    if (key === undefined) {\n      key = newChar;\n    } else {\n      key += newChar;\n    }\n  };\n\n  actions[1\n  /* PUSH */\n  ] = () => {\n    if (key !== undefined) {\n      keys.push(key);\n      key = undefined;\n    }\n  };\n\n  actions[2\n  /* INC_SUB_PATH_DEPTH */\n  ] = () => {\n    actions[0\n    /* APPEND */\n    ]();\n    subPathDepth++;\n  };\n\n  actions[3\n  /* PUSH_SUB_PATH */\n  ] = () => {\n    if (subPathDepth > 0) {\n      subPathDepth--;\n      mode = 4\n      /* IN_SUB_PATH */\n      ;\n      actions[0\n      /* APPEND */\n      ]();\n    } else {\n      subPathDepth = 0;\n\n      if (key === undefined) {\n        return false;\n      }\n\n      key = formatSubPath(key);\n\n      if (key === false) {\n        return false;\n      } else {\n        actions[1\n        /* PUSH */\n        ]();\n      }\n    }\n  };\n\n  function maybeUnescapeQuote() {\n    const nextChar = path[index + 1];\n\n    if (mode === 5\n    /* IN_SINGLE_QUOTE */\n    && nextChar === \"'\"\n    /* SINGLE_QUOTE */\n    || mode === 6\n    /* IN_DOUBLE_QUOTE */\n    && nextChar === \"\\\"\"\n    /* DOUBLE_QUOTE */\n    ) {\n      index++;\n      newChar = '\\\\' + nextChar;\n      actions[0\n      /* APPEND */\n      ]();\n      return true;\n    }\n  }\n\n  while (mode !== null) {\n    index++;\n    c = path[index];\n\n    if (c === '\\\\' && maybeUnescapeQuote()) {\n      continue;\n    }\n\n    type = getPathCharType(c);\n    typeMap = pathStateMachine[mode];\n    transition = typeMap[type] || typeMap[\"l\"\n    /* ELSE */\n    ] || 8\n    /* ERROR */\n    ; // check parse error\n\n    if (transition === 8\n    /* ERROR */\n    ) {\n      return;\n    }\n\n    mode = transition[0];\n\n    if (transition[1] !== undefined) {\n      action = actions[transition[1]];\n\n      if (action) {\n        newChar = c;\n\n        if (action() === false) {\n          return;\n        }\n      }\n    } // check parse finish\n\n\n    if (mode === 7\n    /* AFTER_PATH */\n    ) {\n      return keys;\n    }\n  }\n} // path token cache\n\n\nconst cache = new Map();\n\nfunction resolveValue(obj, path) {\n  // check object\n  if (!isObject(obj)) {\n    return null;\n  } // parse path\n\n\n  let hit = cache.get(path);\n\n  if (!hit) {\n    hit = parse(path);\n\n    if (hit) {\n      cache.set(path, hit);\n    }\n  } // check hit\n\n\n  if (!hit) {\n    return null;\n  } // resolve path value\n\n\n  const len = hit.length;\n  let last = obj;\n  let i = 0;\n\n  while (i < len) {\n    const val = last[hit[i]];\n\n    if (val === undefined) {\n      return null;\n    }\n\n    last = val;\n    i++;\n  }\n\n  return last;\n}\n/**\r\n * Transform flat json in obj to normal json in obj\r\n */\n\n\nfunction handleFlatJson(obj) {\n  // check obj\n  if (!isObject(obj)) {\n    return obj;\n  }\n\n  for (const key in obj) {\n    // check key\n    if (!hasOwn(obj, key)) {\n      continue;\n    } // handle for normal json\n\n\n    if (!key.includes(\".\"\n    /* DOT */\n    )) {\n      // recursive process value if value is also a object\n      if (isObject(obj[key])) {\n        handleFlatJson(obj[key]);\n      }\n    } // handle for flat json, transform to normal json\n    else {\n      // go to the last object\n      const subKeys = key.split(\".\"\n      /* DOT */\n      );\n      const lastIndex = subKeys.length - 1;\n      let currentObj = obj;\n\n      for (let i = 0; i < lastIndex; i++) {\n        if (!(subKeys[i] in currentObj)) {\n          currentObj[subKeys[i]] = {};\n        }\n\n        currentObj = currentObj[subKeys[i]];\n      } // update last object value, delete old property\n\n\n      currentObj[subKeys[lastIndex]] = obj[key];\n      delete obj[key]; // recursive process value if value is also a object\n\n      if (isObject(currentObj[subKeys[lastIndex]])) {\n        handleFlatJson(currentObj[subKeys[lastIndex]]);\n      }\n    }\n  }\n\n  return obj;\n}\n\nexport { handleFlatJson, parse, resolveValue };","map":{"version":3,"names":["process","env","NODE_ENV","hasOwnProperty","Object","prototype","hasOwn","obj","key","call","isObject","val","pathStateMachine","literalValueRE","isLiteral","exp","test","stripQuotes","str","a","charCodeAt","b","length","slice","getPathCharType","ch","undefined","code","formatSubPath","path","trimmed","trim","charAt","isNaN","parseInt","parse","keys","index","mode","subPathDepth","c","newChar","type","transition","action","typeMap","actions","push","maybeUnescapeQuote","nextChar","cache","Map","resolveValue","hit","get","set","len","last","i","handleFlatJson","includes","subKeys","split","lastIndex","currentObj"],"sources":["/Users/lord/Documents/Programmer/vue/VueProjects/blog-vue/blog-web/node_modules/@intlify/message-resolver/dist/message-resolver.esm-bundler.js"],"sourcesContent":["/*!\n  * @intlify/message-resolver v9.1.10\n  * (c) 2022 kazuya kawaguchi\n  * Released under the MIT License.\n  */\n/**\r\n * Original Utilities\r\n * written by kazuya kawaguchi\r\n */\r\nif ((process.env.NODE_ENV !== 'production')) ;\r\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\r\nfunction hasOwn(obj, key) {\r\n    return hasOwnProperty.call(obj, key);\r\n}\r\nconst isObject = (val) => // eslint-disable-line\r\n val !== null && typeof val === 'object';\n\nconst pathStateMachine = [];\r\npathStateMachine[0 /* BEFORE_PATH */] = {\r\n    [\"w\" /* WORKSPACE */]: [0 /* BEFORE_PATH */],\r\n    [\"i\" /* IDENT */]: [3 /* IN_IDENT */, 0 /* APPEND */],\r\n    [\"[\" /* LEFT_BRACKET */]: [4 /* IN_SUB_PATH */],\r\n    [\"o\" /* END_OF_FAIL */]: [7 /* AFTER_PATH */]\r\n};\r\npathStateMachine[1 /* IN_PATH */] = {\r\n    [\"w\" /* WORKSPACE */]: [1 /* IN_PATH */],\r\n    [\".\" /* DOT */]: [2 /* BEFORE_IDENT */],\r\n    [\"[\" /* LEFT_BRACKET */]: [4 /* IN_SUB_PATH */],\r\n    [\"o\" /* END_OF_FAIL */]: [7 /* AFTER_PATH */]\r\n};\r\npathStateMachine[2 /* BEFORE_IDENT */] = {\r\n    [\"w\" /* WORKSPACE */]: [2 /* BEFORE_IDENT */],\r\n    [\"i\" /* IDENT */]: [3 /* IN_IDENT */, 0 /* APPEND */],\r\n    [\"0\" /* ZERO */]: [3 /* IN_IDENT */, 0 /* APPEND */]\r\n};\r\npathStateMachine[3 /* IN_IDENT */] = {\r\n    [\"i\" /* IDENT */]: [3 /* IN_IDENT */, 0 /* APPEND */],\r\n    [\"0\" /* ZERO */]: [3 /* IN_IDENT */, 0 /* APPEND */],\r\n    [\"w\" /* WORKSPACE */]: [1 /* IN_PATH */, 1 /* PUSH */],\r\n    [\".\" /* DOT */]: [2 /* BEFORE_IDENT */, 1 /* PUSH */],\r\n    [\"[\" /* LEFT_BRACKET */]: [4 /* IN_SUB_PATH */, 1 /* PUSH */],\r\n    [\"o\" /* END_OF_FAIL */]: [7 /* AFTER_PATH */, 1 /* PUSH */]\r\n};\r\npathStateMachine[4 /* IN_SUB_PATH */] = {\r\n    [\"'\" /* SINGLE_QUOTE */]: [5 /* IN_SINGLE_QUOTE */, 0 /* APPEND */],\r\n    [\"\\\"\" /* DOUBLE_QUOTE */]: [6 /* IN_DOUBLE_QUOTE */, 0 /* APPEND */],\r\n    [\"[\" /* LEFT_BRACKET */]: [\r\n        4 /* IN_SUB_PATH */,\r\n        2 /* INC_SUB_PATH_DEPTH */\r\n    ],\r\n    [\"]\" /* RIGHT_BRACKET */]: [1 /* IN_PATH */, 3 /* PUSH_SUB_PATH */],\r\n    [\"o\" /* END_OF_FAIL */]: 8 /* ERROR */,\r\n    [\"l\" /* ELSE */]: [4 /* IN_SUB_PATH */, 0 /* APPEND */]\r\n};\r\npathStateMachine[5 /* IN_SINGLE_QUOTE */] = {\r\n    [\"'\" /* SINGLE_QUOTE */]: [4 /* IN_SUB_PATH */, 0 /* APPEND */],\r\n    [\"o\" /* END_OF_FAIL */]: 8 /* ERROR */,\r\n    [\"l\" /* ELSE */]: [5 /* IN_SINGLE_QUOTE */, 0 /* APPEND */]\r\n};\r\npathStateMachine[6 /* IN_DOUBLE_QUOTE */] = {\r\n    [\"\\\"\" /* DOUBLE_QUOTE */]: [4 /* IN_SUB_PATH */, 0 /* APPEND */],\r\n    [\"o\" /* END_OF_FAIL */]: 8 /* ERROR */,\r\n    [\"l\" /* ELSE */]: [6 /* IN_DOUBLE_QUOTE */, 0 /* APPEND */]\r\n};\r\n/**\r\n * Check if an expression is a literal value.\r\n */\r\nconst literalValueRE = /^\\s?(?:true|false|-?[\\d.]+|'[^']*'|\"[^\"]*\")\\s?$/;\r\nfunction isLiteral(exp) {\r\n    return literalValueRE.test(exp);\r\n}\r\n/**\r\n * Strip quotes from a string\r\n */\r\nfunction stripQuotes(str) {\r\n    const a = str.charCodeAt(0);\r\n    const b = str.charCodeAt(str.length - 1);\r\n    return a === b && (a === 0x22 || a === 0x27) ? str.slice(1, -1) : str;\r\n}\r\n/**\r\n * Determine the type of a character in a keypath.\r\n */\r\nfunction getPathCharType(ch) {\r\n    if (ch === undefined || ch === null) {\r\n        return \"o\" /* END_OF_FAIL */;\r\n    }\r\n    const code = ch.charCodeAt(0);\r\n    switch (code) {\r\n        case 0x5b: // [\r\n        case 0x5d: // ]\r\n        case 0x2e: // .\r\n        case 0x22: // \"\r\n        case 0x27: // '\r\n            return ch;\r\n        case 0x5f: // _\r\n        case 0x24: // $\r\n        case 0x2d: // -\r\n            return \"i\" /* IDENT */;\r\n        case 0x09: // Tab (HT)\r\n        case 0x0a: // Newline (LF)\r\n        case 0x0d: // Return (CR)\r\n        case 0xa0: // No-break space (NBSP)\r\n        case 0xfeff: // Byte Order Mark (BOM)\r\n        case 0x2028: // Line Separator (LS)\r\n        case 0x2029: // Paragraph Separator (PS)\r\n            return \"w\" /* WORKSPACE */;\r\n    }\r\n    return \"i\" /* IDENT */;\r\n}\r\n/**\r\n * Format a subPath, return its plain form if it is\r\n * a literal string or number. Otherwise prepend the\r\n * dynamic indicator (*).\r\n */\r\nfunction formatSubPath(path) {\r\n    const trimmed = path.trim();\r\n    // invalid leading 0\r\n    if (path.charAt(0) === '0' && isNaN(parseInt(path))) {\r\n        return false;\r\n    }\r\n    return isLiteral(trimmed)\r\n        ? stripQuotes(trimmed)\r\n        : \"*\" /* ASTARISK */ + trimmed;\r\n}\r\n/**\r\n * Parse a string path into an array of segments\r\n */\r\nfunction parse(path) {\r\n    const keys = [];\r\n    let index = -1;\r\n    let mode = 0 /* BEFORE_PATH */;\r\n    let subPathDepth = 0;\r\n    let c;\r\n    let key; // eslint-disable-line\r\n    let newChar;\r\n    let type;\r\n    let transition;\r\n    let action;\r\n    let typeMap;\r\n    const actions = [];\r\n    actions[0 /* APPEND */] = () => {\r\n        if (key === undefined) {\r\n            key = newChar;\r\n        }\r\n        else {\r\n            key += newChar;\r\n        }\r\n    };\r\n    actions[1 /* PUSH */] = () => {\r\n        if (key !== undefined) {\r\n            keys.push(key);\r\n            key = undefined;\r\n        }\r\n    };\r\n    actions[2 /* INC_SUB_PATH_DEPTH */] = () => {\r\n        actions[0 /* APPEND */]();\r\n        subPathDepth++;\r\n    };\r\n    actions[3 /* PUSH_SUB_PATH */] = () => {\r\n        if (subPathDepth > 0) {\r\n            subPathDepth--;\r\n            mode = 4 /* IN_SUB_PATH */;\r\n            actions[0 /* APPEND */]();\r\n        }\r\n        else {\r\n            subPathDepth = 0;\r\n            if (key === undefined) {\r\n                return false;\r\n            }\r\n            key = formatSubPath(key);\r\n            if (key === false) {\r\n                return false;\r\n            }\r\n            else {\r\n                actions[1 /* PUSH */]();\r\n            }\r\n        }\r\n    };\r\n    function maybeUnescapeQuote() {\r\n        const nextChar = path[index + 1];\r\n        if ((mode === 5 /* IN_SINGLE_QUOTE */ &&\r\n            nextChar === \"'\" /* SINGLE_QUOTE */) ||\r\n            (mode === 6 /* IN_DOUBLE_QUOTE */ &&\r\n                nextChar === \"\\\"\" /* DOUBLE_QUOTE */)) {\r\n            index++;\r\n            newChar = '\\\\' + nextChar;\r\n            actions[0 /* APPEND */]();\r\n            return true;\r\n        }\r\n    }\r\n    while (mode !== null) {\r\n        index++;\r\n        c = path[index];\r\n        if (c === '\\\\' && maybeUnescapeQuote()) {\r\n            continue;\r\n        }\r\n        type = getPathCharType(c);\r\n        typeMap = pathStateMachine[mode];\r\n        transition = typeMap[type] || typeMap[\"l\" /* ELSE */] || 8 /* ERROR */;\r\n        // check parse error\r\n        if (transition === 8 /* ERROR */) {\r\n            return;\r\n        }\r\n        mode = transition[0];\r\n        if (transition[1] !== undefined) {\r\n            action = actions[transition[1]];\r\n            if (action) {\r\n                newChar = c;\r\n                if (action() === false) {\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        // check parse finish\r\n        if (mode === 7 /* AFTER_PATH */) {\r\n            return keys;\r\n        }\r\n    }\r\n}\r\n// path token cache\r\nconst cache = new Map();\r\nfunction resolveValue(obj, path) {\r\n    // check object\r\n    if (!isObject(obj)) {\r\n        return null;\r\n    }\r\n    // parse path\r\n    let hit = cache.get(path);\r\n    if (!hit) {\r\n        hit = parse(path);\r\n        if (hit) {\r\n            cache.set(path, hit);\r\n        }\r\n    }\r\n    // check hit\r\n    if (!hit) {\r\n        return null;\r\n    }\r\n    // resolve path value\r\n    const len = hit.length;\r\n    let last = obj;\r\n    let i = 0;\r\n    while (i < len) {\r\n        const val = last[hit[i]];\r\n        if (val === undefined) {\r\n            return null;\r\n        }\r\n        last = val;\r\n        i++;\r\n    }\r\n    return last;\r\n}\r\n/**\r\n * Transform flat json in obj to normal json in obj\r\n */\r\nfunction handleFlatJson(obj) {\r\n    // check obj\r\n    if (!isObject(obj)) {\r\n        return obj;\r\n    }\r\n    for (const key in obj) {\r\n        // check key\r\n        if (!hasOwn(obj, key)) {\r\n            continue;\r\n        }\r\n        // handle for normal json\r\n        if (!key.includes(\".\" /* DOT */)) {\r\n            // recursive process value if value is also a object\r\n            if (isObject(obj[key])) {\r\n                handleFlatJson(obj[key]);\r\n            }\r\n        }\r\n        // handle for flat json, transform to normal json\r\n        else {\r\n            // go to the last object\r\n            const subKeys = key.split(\".\" /* DOT */);\r\n            const lastIndex = subKeys.length - 1;\r\n            let currentObj = obj;\r\n            for (let i = 0; i < lastIndex; i++) {\r\n                if (!(subKeys[i] in currentObj)) {\r\n                    currentObj[subKeys[i]] = {};\r\n                }\r\n                currentObj = currentObj[subKeys[i]];\r\n            }\r\n            // update last object value, delete old property\r\n            currentObj[subKeys[lastIndex]] = obj[key];\r\n            delete obj[key];\r\n            // recursive process value if value is also a object\r\n            if (isObject(currentObj[subKeys[lastIndex]])) {\r\n                handleFlatJson(currentObj[subKeys[lastIndex]]);\r\n            }\r\n        }\r\n    }\r\n    return obj;\r\n}\n\nexport { handleFlatJson, parse, resolveValue };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}