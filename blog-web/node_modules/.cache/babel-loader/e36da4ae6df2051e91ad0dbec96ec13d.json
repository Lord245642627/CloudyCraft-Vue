{"ast":null,"code":"// Join raw text tokens with the rest of the text\n//\n// This is set as a separate rule to provide an opportunity for plugins\n// to run text replacements after text join, but before escape join.\n//\n// For example, `\\:)` shouldn't be replaced with an emoji.\n//\n'use strict';\n\nmodule.exports = function text_join(state) {\n  var j,\n      l,\n      tokens,\n      curr,\n      max,\n      last,\n      blockTokens = state.tokens;\n\n  for (j = 0, l = blockTokens.length; j < l; j++) {\n    if (blockTokens[j].type !== 'inline') continue;\n    tokens = blockTokens[j].children;\n    max = tokens.length;\n\n    for (curr = 0; curr < max; curr++) {\n      if (tokens[curr].type === 'text_special') {\n        tokens[curr].type = 'text';\n      }\n    }\n\n    for (curr = last = 0; curr < max; curr++) {\n      if (tokens[curr].type === 'text' && curr + 1 < max && tokens[curr + 1].type === 'text') {\n        // collapse two adjacent text nodes\n        tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;\n      } else {\n        if (curr !== last) {\n          tokens[last] = tokens[curr];\n        }\n\n        last++;\n      }\n    }\n\n    if (curr !== last) {\n      tokens.length = last;\n    }\n  }\n};","map":{"version":3,"names":["module","exports","text_join","state","j","l","tokens","curr","max","last","blockTokens","length","type","children","content"],"sources":["/Users/lord/Documents/Programmer/vue/VueProjects/blog-vue/blog-web/node_modules/markdown-it/lib/rules_core/text_join.js"],"sourcesContent":["// Join raw text tokens with the rest of the text\n//\n// This is set as a separate rule to provide an opportunity for plugins\n// to run text replacements after text join, but before escape join.\n//\n// For example, `\\:)` shouldn't be replaced with an emoji.\n//\n'use strict';\n\n\nmodule.exports = function text_join(state) {\n  var j, l, tokens, curr, max, last,\n      blockTokens = state.tokens;\n\n  for (j = 0, l = blockTokens.length; j < l; j++) {\n    if (blockTokens[j].type !== 'inline') continue;\n\n    tokens = blockTokens[j].children;\n    max = tokens.length;\n\n    for (curr = 0; curr < max; curr++) {\n      if (tokens[curr].type === 'text_special') {\n        tokens[curr].type = 'text';\n      }\n    }\n\n    for (curr = last = 0; curr < max; curr++) {\n      if (tokens[curr].type === 'text' &&\n          curr + 1 < max &&\n          tokens[curr + 1].type === 'text') {\n\n        // collapse two adjacent text nodes\n        tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;\n      } else {\n        if (curr !== last) { tokens[last] = tokens[curr]; }\n\n        last++;\n      }\n    }\n\n    if (curr !== last) {\n      tokens.length = last;\n    }\n  }\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGAA,MAAM,CAACC,OAAP,GAAiB,SAASC,SAAT,CAAmBC,KAAnB,EAA0B;EACzC,IAAIC,CAAJ;EAAA,IAAOC,CAAP;EAAA,IAAUC,MAAV;EAAA,IAAkBC,IAAlB;EAAA,IAAwBC,GAAxB;EAAA,IAA6BC,IAA7B;EAAA,IACIC,WAAW,GAAGP,KAAK,CAACG,MADxB;;EAGA,KAAKF,CAAC,GAAG,CAAJ,EAAOC,CAAC,GAAGK,WAAW,CAACC,MAA5B,EAAoCP,CAAC,GAAGC,CAAxC,EAA2CD,CAAC,EAA5C,EAAgD;IAC9C,IAAIM,WAAW,CAACN,CAAD,CAAX,CAAeQ,IAAf,KAAwB,QAA5B,EAAsC;IAEtCN,MAAM,GAAGI,WAAW,CAACN,CAAD,CAAX,CAAeS,QAAxB;IACAL,GAAG,GAAGF,MAAM,CAACK,MAAb;;IAEA,KAAKJ,IAAI,GAAG,CAAZ,EAAeA,IAAI,GAAGC,GAAtB,EAA2BD,IAAI,EAA/B,EAAmC;MACjC,IAAID,MAAM,CAACC,IAAD,CAAN,CAAaK,IAAb,KAAsB,cAA1B,EAA0C;QACxCN,MAAM,CAACC,IAAD,CAAN,CAAaK,IAAb,GAAoB,MAApB;MACD;IACF;;IAED,KAAKL,IAAI,GAAGE,IAAI,GAAG,CAAnB,EAAsBF,IAAI,GAAGC,GAA7B,EAAkCD,IAAI,EAAtC,EAA0C;MACxC,IAAID,MAAM,CAACC,IAAD,CAAN,CAAaK,IAAb,KAAsB,MAAtB,IACAL,IAAI,GAAG,CAAP,GAAWC,GADX,IAEAF,MAAM,CAACC,IAAI,GAAG,CAAR,CAAN,CAAiBK,IAAjB,KAA0B,MAF9B,EAEsC;QAEpC;QACAN,MAAM,CAACC,IAAI,GAAG,CAAR,CAAN,CAAiBO,OAAjB,GAA2BR,MAAM,CAACC,IAAD,CAAN,CAAaO,OAAb,GAAuBR,MAAM,CAACC,IAAI,GAAG,CAAR,CAAN,CAAiBO,OAAnE;MACD,CAND,MAMO;QACL,IAAIP,IAAI,KAAKE,IAAb,EAAmB;UAAEH,MAAM,CAACG,IAAD,CAAN,GAAeH,MAAM,CAACC,IAAD,CAArB;QAA8B;;QAEnDE,IAAI;MACL;IACF;;IAED,IAAIF,IAAI,KAAKE,IAAb,EAAmB;MACjBH,MAAM,CAACK,MAAP,GAAgBF,IAAhB;IACD;EACF;AACF,CAlCD"},"metadata":{},"sourceType":"script"}