{"ast":null,"code":"// Parse backticks\n'use strict';\n\nmodule.exports = function backtick(state, silent) {\n  var start,\n      max,\n      marker,\n      token,\n      matchStart,\n      matchEnd,\n      openerLength,\n      closerLength,\n      pos = state.pos,\n      ch = state.src.charCodeAt(pos);\n\n  if (ch !== 0x60\n  /* ` */\n  ) {\n    return false;\n  }\n\n  start = pos;\n  pos++;\n  max = state.posMax; // scan marker length\n\n  while (pos < max && state.src.charCodeAt(pos) === 0x60\n  /* ` */\n  ) {\n    pos++;\n  }\n\n  marker = state.src.slice(start, pos);\n  openerLength = marker.length;\n\n  if (state.backticksScanned && (state.backticks[openerLength] || 0) <= start) {\n    if (!silent) state.pending += marker;\n    state.pos += openerLength;\n    return true;\n  }\n\n  matchStart = matchEnd = pos; // Nothing found in the cache, scan until the end of the line (or until marker is found)\n\n  while ((matchStart = state.src.indexOf('`', matchEnd)) !== -1) {\n    matchEnd = matchStart + 1; // scan marker length\n\n    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 0x60\n    /* ` */\n    ) {\n      matchEnd++;\n    }\n\n    closerLength = matchEnd - matchStart;\n\n    if (closerLength === openerLength) {\n      // Found matching closer length.\n      if (!silent) {\n        token = state.push('code_inline', 'code', 0);\n        token.markup = marker;\n        token.content = state.src.slice(pos, matchStart).replace(/\\n/g, ' ').replace(/^ (.+) $/, '$1');\n      }\n\n      state.pos = matchEnd;\n      return true;\n    } // Some different length found, put it in cache as upper limit of where closer can be found\n\n\n    state.backticks[closerLength] = matchStart;\n  } // Scanned through the end, didn't find anything\n\n\n  state.backticksScanned = true;\n  if (!silent) state.pending += marker;\n  state.pos += openerLength;\n  return true;\n};","map":{"version":3,"names":["module","exports","backtick","state","silent","start","max","marker","token","matchStart","matchEnd","openerLength","closerLength","pos","ch","src","charCodeAt","posMax","slice","length","backticksScanned","backticks","pending","indexOf","push","markup","content","replace"],"sources":["/Users/lord/Documents/Programmer/vue/VueProjects/cloudycraft-vue/blog-web/node_modules/markdown-it/lib/rules_inline/backticks.js"],"sourcesContent":["// Parse backticks\n\n'use strict';\n\n\nmodule.exports = function backtick(state, silent) {\n  var start, max, marker, token, matchStart, matchEnd, openerLength, closerLength,\n      pos = state.pos,\n      ch = state.src.charCodeAt(pos);\n\n  if (ch !== 0x60/* ` */) { return false; }\n\n  start = pos;\n  pos++;\n  max = state.posMax;\n\n  // scan marker length\n  while (pos < max && state.src.charCodeAt(pos) === 0x60/* ` */) { pos++; }\n\n  marker = state.src.slice(start, pos);\n  openerLength = marker.length;\n\n  if (state.backticksScanned && (state.backticks[openerLength] || 0) <= start) {\n    if (!silent) state.pending += marker;\n    state.pos += openerLength;\n    return true;\n  }\n\n  matchStart = matchEnd = pos;\n\n  // Nothing found in the cache, scan until the end of the line (or until marker is found)\n  while ((matchStart = state.src.indexOf('`', matchEnd)) !== -1) {\n    matchEnd = matchStart + 1;\n\n    // scan marker length\n    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 0x60/* ` */) { matchEnd++; }\n\n    closerLength = matchEnd - matchStart;\n\n    if (closerLength === openerLength) {\n      // Found matching closer length.\n      if (!silent) {\n        token     = state.push('code_inline', 'code', 0);\n        token.markup  = marker;\n        token.content = state.src.slice(pos, matchStart)\n          .replace(/\\n/g, ' ')\n          .replace(/^ (.+) $/, '$1');\n      }\n      state.pos = matchEnd;\n      return true;\n    }\n\n    // Some different length found, put it in cache as upper limit of where closer can be found\n    state.backticks[closerLength] = matchStart;\n  }\n\n  // Scanned through the end, didn't find anything\n  state.backticksScanned = true;\n\n  if (!silent) state.pending += marker;\n  state.pos += openerLength;\n  return true;\n};\n"],"mappings":"AAAA;AAEA;;AAGAA,MAAM,CAACC,OAAP,GAAiB,SAASC,QAAT,CAAkBC,KAAlB,EAAyBC,MAAzB,EAAiC;EAChD,IAAIC,KAAJ;EAAA,IAAWC,GAAX;EAAA,IAAgBC,MAAhB;EAAA,IAAwBC,KAAxB;EAAA,IAA+BC,UAA/B;EAAA,IAA2CC,QAA3C;EAAA,IAAqDC,YAArD;EAAA,IAAmEC,YAAnE;EAAA,IACIC,GAAG,GAAGV,KAAK,CAACU,GADhB;EAAA,IAEIC,EAAE,GAAGX,KAAK,CAACY,GAAN,CAAUC,UAAV,CAAqBH,GAArB,CAFT;;EAIA,IAAIC,EAAE,KAAK;EAAI;EAAf,EAAwB;IAAE,OAAO,KAAP;EAAe;;EAEzCT,KAAK,GAAGQ,GAAR;EACAA,GAAG;EACHP,GAAG,GAAGH,KAAK,CAACc,MAAZ,CATgD,CAWhD;;EACA,OAAOJ,GAAG,GAAGP,GAAN,IAAaH,KAAK,CAACY,GAAN,CAAUC,UAAV,CAAqBH,GAArB,MAA8B;EAAI;EAAtD,EAA+D;IAAEA,GAAG;EAAK;;EAEzEN,MAAM,GAAGJ,KAAK,CAACY,GAAN,CAAUG,KAAV,CAAgBb,KAAhB,EAAuBQ,GAAvB,CAAT;EACAF,YAAY,GAAGJ,MAAM,CAACY,MAAtB;;EAEA,IAAIhB,KAAK,CAACiB,gBAAN,IAA0B,CAACjB,KAAK,CAACkB,SAAN,CAAgBV,YAAhB,KAAiC,CAAlC,KAAwCN,KAAtE,EAA6E;IAC3E,IAAI,CAACD,MAAL,EAAaD,KAAK,CAACmB,OAAN,IAAiBf,MAAjB;IACbJ,KAAK,CAACU,GAAN,IAAaF,YAAb;IACA,OAAO,IAAP;EACD;;EAEDF,UAAU,GAAGC,QAAQ,GAAGG,GAAxB,CAvBgD,CAyBhD;;EACA,OAAO,CAACJ,UAAU,GAAGN,KAAK,CAACY,GAAN,CAAUQ,OAAV,CAAkB,GAAlB,EAAuBb,QAAvB,CAAd,MAAoD,CAAC,CAA5D,EAA+D;IAC7DA,QAAQ,GAAGD,UAAU,GAAG,CAAxB,CAD6D,CAG7D;;IACA,OAAOC,QAAQ,GAAGJ,GAAX,IAAkBH,KAAK,CAACY,GAAN,CAAUC,UAAV,CAAqBN,QAArB,MAAmC;IAAI;IAAhE,EAAyE;MAAEA,QAAQ;IAAK;;IAExFE,YAAY,GAAGF,QAAQ,GAAGD,UAA1B;;IAEA,IAAIG,YAAY,KAAKD,YAArB,EAAmC;MACjC;MACA,IAAI,CAACP,MAAL,EAAa;QACXI,KAAK,GAAOL,KAAK,CAACqB,IAAN,CAAW,aAAX,EAA0B,MAA1B,EAAkC,CAAlC,CAAZ;QACAhB,KAAK,CAACiB,MAAN,GAAgBlB,MAAhB;QACAC,KAAK,CAACkB,OAAN,GAAgBvB,KAAK,CAACY,GAAN,CAAUG,KAAV,CAAgBL,GAAhB,EAAqBJ,UAArB,EACbkB,OADa,CACL,KADK,EACE,GADF,EAEbA,OAFa,CAEL,UAFK,EAEO,IAFP,CAAhB;MAGD;;MACDxB,KAAK,CAACU,GAAN,GAAYH,QAAZ;MACA,OAAO,IAAP;IACD,CAnB4D,CAqB7D;;;IACAP,KAAK,CAACkB,SAAN,CAAgBT,YAAhB,IAAgCH,UAAhC;EACD,CAjD+C,CAmDhD;;;EACAN,KAAK,CAACiB,gBAAN,GAAyB,IAAzB;EAEA,IAAI,CAAChB,MAAL,EAAaD,KAAK,CAACmB,OAAN,IAAiBf,MAAjB;EACbJ,KAAK,CAACU,GAAN,IAAaF,YAAb;EACA,OAAO,IAAP;AACD,CAzDD"},"metadata":{},"sourceType":"script"}