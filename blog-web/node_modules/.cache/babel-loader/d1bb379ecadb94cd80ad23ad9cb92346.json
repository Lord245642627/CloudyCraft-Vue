{"ast":null,"code":"/*!\n  * @intlify/message-resolver v9.1.10\n  * (c) 2022 kazuya kawaguchi\n  * Released under the MIT License.\n  */\n\n/**\r\n * Original Utilities\r\n * written by kazuya kawaguchi\r\n */\nif (process.env.NODE_ENV !== 'production') ;\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction hasOwn(obj, key) {\n  return hasOwnProperty.call(obj, key);\n}\n\nconst isObject = val => // eslint-disable-line\nval !== null && typeof val === 'object';\n\nconst pathStateMachine = [];\npathStateMachine[0\n/* BEFORE_PATH */\n] = {\n  [\"w\"\n  /* WORKSPACE */\n  ]: [0\n  /* BEFORE_PATH */\n  ],\n  [\"i\"\n  /* IDENT */\n  ]: [3\n  /* IN_IDENT */\n  , 0\n  /* APPEND */\n  ],\n  [\"[\"\n  /* LEFT_BRACKET */\n  ]: [4\n  /* IN_SUB_PATH */\n  ],\n  [\"o\"\n  /* END_OF_FAIL */\n  ]: [7\n  /* AFTER_PATH */\n  ]\n};\npathStateMachine[1\n/* IN_PATH */\n] = {\n  [\"w\"\n  /* WORKSPACE */\n  ]: [1\n  /* IN_PATH */\n  ],\n  [\".\"\n  /* DOT */\n  ]: [2\n  /* BEFORE_IDENT */\n  ],\n  [\"[\"\n  /* LEFT_BRACKET */\n  ]: [4\n  /* IN_SUB_PATH */\n  ],\n  [\"o\"\n  /* END_OF_FAIL */\n  ]: [7\n  /* AFTER_PATH */\n  ]\n};\npathStateMachine[2\n/* BEFORE_IDENT */\n] = {\n  [\"w\"\n  /* WORKSPACE */\n  ]: [2\n  /* BEFORE_IDENT */\n  ],\n  [\"i\"\n  /* IDENT */\n  ]: [3\n  /* IN_IDENT */\n  , 0\n  /* APPEND */\n  ],\n  [\"0\"\n  /* ZERO */\n  ]: [3\n  /* IN_IDENT */\n  , 0\n  /* APPEND */\n  ]\n};\npathStateMachine[3\n/* IN_IDENT */\n] = {\n  [\"i\"\n  /* IDENT */\n  ]: [3\n  /* IN_IDENT */\n  , 0\n  /* APPEND */\n  ],\n  [\"0\"\n  /* ZERO */\n  ]: [3\n  /* IN_IDENT */\n  , 0\n  /* APPEND */\n  ],\n  [\"w\"\n  /* WORKSPACE */\n  ]: [1\n  /* IN_PATH */\n  , 1\n  /* PUSH */\n  ],\n  [\".\"\n  /* DOT */\n  ]: [2\n  /* BEFORE_IDENT */\n  , 1\n  /* PUSH */\n  ],\n  [\"[\"\n  /* LEFT_BRACKET */\n  ]: [4\n  /* IN_SUB_PATH */\n  , 1\n  /* PUSH */\n  ],\n  [\"o\"\n  /* END_OF_FAIL */\n  ]: [7\n  /* AFTER_PATH */\n  , 1\n  /* PUSH */\n  ]\n};\npathStateMachine[4\n/* IN_SUB_PATH */\n] = {\n  [\"'\"\n  /* SINGLE_QUOTE */\n  ]: [5\n  /* IN_SINGLE_QUOTE */\n  , 0\n  /* APPEND */\n  ],\n  [\"\\\"\"\n  /* DOUBLE_QUOTE */\n  ]: [6\n  /* IN_DOUBLE_QUOTE */\n  , 0\n  /* APPEND */\n  ],\n  [\"[\"\n  /* LEFT_BRACKET */\n  ]: [4\n  /* IN_SUB_PATH */\n  , 2\n  /* INC_SUB_PATH_DEPTH */\n  ],\n  [\"]\"\n  /* RIGHT_BRACKET */\n  ]: [1\n  /* IN_PATH */\n  , 3\n  /* PUSH_SUB_PATH */\n  ],\n  [\"o\"\n  /* END_OF_FAIL */\n  ]: 8\n  /* ERROR */\n  ,\n  [\"l\"\n  /* ELSE */\n  ]: [4\n  /* IN_SUB_PATH */\n  , 0\n  /* APPEND */\n  ]\n};\npathStateMachine[5\n/* IN_SINGLE_QUOTE */\n] = {\n  [\"'\"\n  /* SINGLE_QUOTE */\n  ]: [4\n  /* IN_SUB_PATH */\n  , 0\n  /* APPEND */\n  ],\n  [\"o\"\n  /* END_OF_FAIL */\n  ]: 8\n  /* ERROR */\n  ,\n  [\"l\"\n  /* ELSE */\n  ]: [5\n  /* IN_SINGLE_QUOTE */\n  , 0\n  /* APPEND */\n  ]\n};\npathStateMachine[6\n/* IN_DOUBLE_QUOTE */\n] = {\n  [\"\\\"\"\n  /* DOUBLE_QUOTE */\n  ]: [4\n  /* IN_SUB_PATH */\n  , 0\n  /* APPEND */\n  ],\n  [\"o\"\n  /* END_OF_FAIL */\n  ]: 8\n  /* ERROR */\n  ,\n  [\"l\"\n  /* ELSE */\n  ]: [6\n  /* IN_DOUBLE_QUOTE */\n  , 0\n  /* APPEND */\n  ]\n};\n/**\r\n * Check if an expression is a literal value.\r\n */\n\nconst literalValueRE = /^\\s?(?:true|false|-?[\\d.]+|'[^']*'|\"[^\"]*\")\\s?$/;\n\nfunction isLiteral(exp) {\n  return literalValueRE.test(exp);\n}\n/**\r\n * Strip quotes from a string\r\n */\n\n\nfunction stripQuotes(str) {\n  const a = str.charCodeAt(0);\n  const b = str.charCodeAt(str.length - 1);\n  return a === b && (a === 0x22 || a === 0x27) ? str.slice(1, -1) : str;\n}\n/**\r\n * Determine the type of a character in a keypath.\r\n */\n\n\nfunction getPathCharType(ch) {\n  if (ch === undefined || ch === null) {\n    return \"o\"\n    /* END_OF_FAIL */\n    ;\n  }\n\n  const code = ch.charCodeAt(0);\n\n  switch (code) {\n    case 0x5b: // [\n\n    case 0x5d: // ]\n\n    case 0x2e: // .\n\n    case 0x22: // \"\n\n    case 0x27:\n      // '\n      return ch;\n\n    case 0x5f: // _\n\n    case 0x24: // $\n\n    case 0x2d:\n      // -\n      return \"i\"\n      /* IDENT */\n      ;\n\n    case 0x09: // Tab (HT)\n\n    case 0x0a: // Newline (LF)\n\n    case 0x0d: // Return (CR)\n\n    case 0xa0: // No-break space (NBSP)\n\n    case 0xfeff: // Byte Order Mark (BOM)\n\n    case 0x2028: // Line Separator (LS)\n\n    case 0x2029:\n      // Paragraph Separator (PS)\n      return \"w\"\n      /* WORKSPACE */\n      ;\n  }\n\n  return \"i\"\n  /* IDENT */\n  ;\n}\n/**\r\n * Format a subPath, return its plain form if it is\r\n * a literal string or number. Otherwise prepend the\r\n * dynamic indicator (*).\r\n */\n\n\nfunction formatSubPath(path) {\n  const trimmed = path.trim(); // invalid leading 0\n\n  if (path.charAt(0) === '0' && isNaN(parseInt(path))) {\n    return false;\n  }\n\n  return isLiteral(trimmed) ? stripQuotes(trimmed) : \"*\"\n  /* ASTARISK */\n  + trimmed;\n}\n/**\r\n * Parse a string path into an array of segments\r\n */\n\n\nfunction parse(path) {\n  const keys = [];\n  let index = -1;\n  let mode = 0\n  /* BEFORE_PATH */\n  ;\n  let subPathDepth = 0;\n  let c;\n  let key; // eslint-disable-line\n\n  let newChar;\n  let type;\n  let transition;\n  let action;\n  let typeMap;\n  const actions = [];\n\n  actions[0\n  /* APPEND */\n  ] = () => {\n    if (key === undefined) {\n      key = newChar;\n    } else {\n      key += newChar;\n    }\n  };\n\n  actions[1\n  /* PUSH */\n  ] = () => {\n    if (key !== undefined) {\n      keys.push(key);\n      key = undefined;\n    }\n  };\n\n  actions[2\n  /* INC_SUB_PATH_DEPTH */\n  ] = () => {\n    actions[0\n    /* APPEND */\n    ]();\n    subPathDepth++;\n  };\n\n  actions[3\n  /* PUSH_SUB_PATH */\n  ] = () => {\n    if (subPathDepth > 0) {\n      subPathDepth--;\n      mode = 4\n      /* IN_SUB_PATH */\n      ;\n      actions[0\n      /* APPEND */\n      ]();\n    } else {\n      subPathDepth = 0;\n\n      if (key === undefined) {\n        return false;\n      }\n\n      key = formatSubPath(key);\n\n      if (key === false) {\n        return false;\n      } else {\n        actions[1\n        /* PUSH */\n        ]();\n      }\n    }\n  };\n\n  function maybeUnescapeQuote() {\n    const nextChar = path[index + 1];\n\n    if (mode === 5\n    /* IN_SINGLE_QUOTE */\n    && nextChar === \"'\"\n    /* SINGLE_QUOTE */\n    || mode === 6\n    /* IN_DOUBLE_QUOTE */\n    && nextChar === \"\\\"\"\n    /* DOUBLE_QUOTE */\n    ) {\n      index++;\n      newChar = '\\\\' + nextChar;\n      actions[0\n      /* APPEND */\n      ]();\n      return true;\n    }\n  }\n\n  while (mode !== null) {\n    index++;\n    c = path[index];\n\n    if (c === '\\\\' && maybeUnescapeQuote()) {\n      continue;\n    }\n\n    type = getPathCharType(c);\n    typeMap = pathStateMachine[mode];\n    transition = typeMap[type] || typeMap[\"l\"\n    /* ELSE */\n    ] || 8\n    /* ERROR */\n    ; // check parse error\n\n    if (transition === 8\n    /* ERROR */\n    ) {\n      return;\n    }\n\n    mode = transition[0];\n\n    if (transition[1] !== undefined) {\n      action = actions[transition[1]];\n\n      if (action) {\n        newChar = c;\n\n        if (action() === false) {\n          return;\n        }\n      }\n    } // check parse finish\n\n\n    if (mode === 7\n    /* AFTER_PATH */\n    ) {\n      return keys;\n    }\n  }\n} // path token cache\n\n\nconst cache = new Map();\n\nfunction resolveValue(obj, path) {\n  // check object\n  if (!isObject(obj)) {\n    return null;\n  } // parse path\n\n\n  let hit = cache.get(path);\n\n  if (!hit) {\n    hit = parse(path);\n\n    if (hit) {\n      cache.set(path, hit);\n    }\n  } // check hit\n\n\n  if (!hit) {\n    return null;\n  } // resolve path value\n\n\n  const len = hit.length;\n  let last = obj;\n  let i = 0;\n\n  while (i < len) {\n    const val = last[hit[i]];\n\n    if (val === undefined) {\n      return null;\n    }\n\n    last = val;\n    i++;\n  }\n\n  return last;\n}\n/**\r\n * Transform flat json in obj to normal json in obj\r\n */\n\n\nfunction handleFlatJson(obj) {\n  // check obj\n  if (!isObject(obj)) {\n    return obj;\n  }\n\n  for (const key in obj) {\n    // check key\n    if (!hasOwn(obj, key)) {\n      continue;\n    } // handle for normal json\n\n\n    if (!key.includes(\".\"\n    /* DOT */\n    )) {\n      // recursive process value if value is also a object\n      if (isObject(obj[key])) {\n        handleFlatJson(obj[key]);\n      }\n    } // handle for flat json, transform to normal json\n    else {\n      // go to the last object\n      const subKeys = key.split(\".\"\n      /* DOT */\n      );\n      const lastIndex = subKeys.length - 1;\n      let currentObj = obj;\n\n      for (let i = 0; i < lastIndex; i++) {\n        if (!(subKeys[i] in currentObj)) {\n          currentObj[subKeys[i]] = {};\n        }\n\n        currentObj = currentObj[subKeys[i]];\n      } // update last object value, delete old property\n\n\n      currentObj[subKeys[lastIndex]] = obj[key];\n      delete obj[key]; // recursive process value if value is also a object\n\n      if (isObject(currentObj[subKeys[lastIndex]])) {\n        handleFlatJson(currentObj[subKeys[lastIndex]]);\n      }\n    }\n  }\n\n  return obj;\n}\n\nexport { handleFlatJson, parse, resolveValue };","map":null,"metadata":{},"sourceType":"module"}