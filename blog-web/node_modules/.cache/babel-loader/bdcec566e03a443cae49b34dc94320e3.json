{"ast":null,"code":"// For each opening emphasis-like marker find a matching closing one\n//\n'use strict';\n\nfunction processDelimiters(state, delimiters) {\n  var closerIdx,\n      openerIdx,\n      closer,\n      opener,\n      minOpenerIdx,\n      newMinOpenerIdx,\n      isOddMatch,\n      lastJump,\n      openersBottom = {},\n      max = delimiters.length;\n  if (!max) return; // headerIdx is the first delimiter of the current (where closer is) delimiter run\n\n  var headerIdx = 0;\n  var lastTokenIdx = -2; // needs any value lower than -1\n\n  var jumps = [];\n\n  for (closerIdx = 0; closerIdx < max; closerIdx++) {\n    closer = delimiters[closerIdx];\n    jumps.push(0); // markers belong to same delimiter run if:\n    //  - they have adjacent tokens\n    //  - AND markers are the same\n    //\n\n    if (delimiters[headerIdx].marker !== closer.marker || lastTokenIdx !== closer.token - 1) {\n      headerIdx = closerIdx;\n    }\n\n    lastTokenIdx = closer.token; // Length is only used for emphasis-specific \"rule of 3\",\n    // if it's not defined (in strikethrough or 3rd party plugins),\n    // we can default it to 0 to disable those checks.\n    //\n\n    closer.length = closer.length || 0;\n    if (!closer.close) continue; // Previously calculated lower bounds (previous fails)\n    // for each marker, each delimiter length modulo 3,\n    // and for whether this closer can be an opener;\n    // https://github.com/commonmark/cmark/commit/34250e12ccebdc6372b8b49c44fab57c72443460\n\n    if (!openersBottom.hasOwnProperty(closer.marker)) {\n      openersBottom[closer.marker] = [-1, -1, -1, -1, -1, -1];\n    }\n\n    minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + closer.length % 3];\n    openerIdx = headerIdx - jumps[headerIdx] - 1;\n    newMinOpenerIdx = openerIdx;\n\n    for (; openerIdx > minOpenerIdx; openerIdx -= jumps[openerIdx] + 1) {\n      opener = delimiters[openerIdx];\n      if (opener.marker !== closer.marker) continue;\n\n      if (opener.open && opener.end < 0) {\n        isOddMatch = false; // from spec:\n        //\n        // If one of the delimiters can both open and close emphasis, then the\n        // sum of the lengths of the delimiter runs containing the opening and\n        // closing delimiters must not be a multiple of 3 unless both lengths\n        // are multiples of 3.\n        //\n\n        if (opener.close || closer.open) {\n          if ((opener.length + closer.length) % 3 === 0) {\n            if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {\n              isOddMatch = true;\n            }\n          }\n        }\n\n        if (!isOddMatch) {\n          // If previous delimiter cannot be an opener, we can safely skip\n          // the entire sequence in future checks. This is required to make\n          // sure algorithm has linear complexity (see *_*_*_*_*_... case).\n          //\n          lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ? jumps[openerIdx - 1] + 1 : 0;\n          jumps[closerIdx] = closerIdx - openerIdx + lastJump;\n          jumps[openerIdx] = lastJump;\n          closer.open = false;\n          opener.end = closerIdx;\n          opener.close = false;\n          newMinOpenerIdx = -1; // treat next token as start of run,\n          // it optimizes skips in **<...>**a**<...>** pathological case\n\n          lastTokenIdx = -2;\n          break;\n        }\n      }\n    }\n\n    if (newMinOpenerIdx !== -1) {\n      // If match for this delimiter run failed, we want to set lower bound for\n      // future lookups. This is required to make sure algorithm has linear\n      // complexity.\n      //\n      // See details here:\n      // https://github.com/commonmark/cmark/issues/178#issuecomment-270417442\n      //\n      openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length || 0) % 3] = newMinOpenerIdx;\n    }\n  }\n}\n\nmodule.exports = function link_pairs(state) {\n  var curr,\n      tokens_meta = state.tokens_meta,\n      max = state.tokens_meta.length;\n  processDelimiters(state, state.delimiters);\n\n  for (curr = 0; curr < max; curr++) {\n    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {\n      processDelimiters(state, tokens_meta[curr].delimiters);\n    }\n  }\n};","map":{"version":3,"names":["processDelimiters","state","delimiters","closerIdx","openerIdx","closer","opener","minOpenerIdx","newMinOpenerIdx","isOddMatch","lastJump","openersBottom","max","length","headerIdx","lastTokenIdx","jumps","push","marker","token","close","hasOwnProperty","open","end","module","exports","link_pairs","curr","tokens_meta"],"sources":["/Users/lord/Documents/Programmer/vue/VueProjects/cloudycraft-vue/blog-web/node_modules/markdown-it/lib/rules_inline/balance_pairs.js"],"sourcesContent":["// For each opening emphasis-like marker find a matching closing one\n//\n'use strict';\n\n\nfunction processDelimiters(state, delimiters) {\n  var closerIdx, openerIdx, closer, opener, minOpenerIdx, newMinOpenerIdx,\n      isOddMatch, lastJump,\n      openersBottom = {},\n      max = delimiters.length;\n\n  if (!max) return;\n\n  // headerIdx is the first delimiter of the current (where closer is) delimiter run\n  var headerIdx = 0;\n  var lastTokenIdx = -2; // needs any value lower than -1\n  var jumps = [];\n\n  for (closerIdx = 0; closerIdx < max; closerIdx++) {\n    closer = delimiters[closerIdx];\n\n    jumps.push(0);\n\n    // markers belong to same delimiter run if:\n    //  - they have adjacent tokens\n    //  - AND markers are the same\n    //\n    if (delimiters[headerIdx].marker !== closer.marker || lastTokenIdx !== closer.token - 1) {\n      headerIdx = closerIdx;\n    }\n\n    lastTokenIdx = closer.token;\n\n    // Length is only used for emphasis-specific \"rule of 3\",\n    // if it's not defined (in strikethrough or 3rd party plugins),\n    // we can default it to 0 to disable those checks.\n    //\n    closer.length = closer.length || 0;\n\n    if (!closer.close) continue;\n\n    // Previously calculated lower bounds (previous fails)\n    // for each marker, each delimiter length modulo 3,\n    // and for whether this closer can be an opener;\n    // https://github.com/commonmark/cmark/commit/34250e12ccebdc6372b8b49c44fab57c72443460\n    if (!openersBottom.hasOwnProperty(closer.marker)) {\n      openersBottom[closer.marker] = [ -1, -1, -1, -1, -1, -1 ];\n    }\n\n    minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length % 3)];\n\n    openerIdx = headerIdx - jumps[headerIdx] - 1;\n\n    newMinOpenerIdx = openerIdx;\n\n    for (; openerIdx > minOpenerIdx; openerIdx -= jumps[openerIdx] + 1) {\n      opener = delimiters[openerIdx];\n\n      if (opener.marker !== closer.marker) continue;\n\n      if (opener.open && opener.end < 0) {\n\n        isOddMatch = false;\n\n        // from spec:\n        //\n        // If one of the delimiters can both open and close emphasis, then the\n        // sum of the lengths of the delimiter runs containing the opening and\n        // closing delimiters must not be a multiple of 3 unless both lengths\n        // are multiples of 3.\n        //\n        if (opener.close || closer.open) {\n          if ((opener.length + closer.length) % 3 === 0) {\n            if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {\n              isOddMatch = true;\n            }\n          }\n        }\n\n        if (!isOddMatch) {\n          // If previous delimiter cannot be an opener, we can safely skip\n          // the entire sequence in future checks. This is required to make\n          // sure algorithm has linear complexity (see *_*_*_*_*_... case).\n          //\n          lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ?\n            jumps[openerIdx - 1] + 1 :\n            0;\n\n          jumps[closerIdx] = closerIdx - openerIdx + lastJump;\n          jumps[openerIdx] = lastJump;\n\n          closer.open  = false;\n          opener.end   = closerIdx;\n          opener.close = false;\n          newMinOpenerIdx = -1;\n          // treat next token as start of run,\n          // it optimizes skips in **<...>**a**<...>** pathological case\n          lastTokenIdx = -2;\n          break;\n        }\n      }\n    }\n\n    if (newMinOpenerIdx !== -1) {\n      // If match for this delimiter run failed, we want to set lower bound for\n      // future lookups. This is required to make sure algorithm has linear\n      // complexity.\n      //\n      // See details here:\n      // https://github.com/commonmark/cmark/issues/178#issuecomment-270417442\n      //\n      openersBottom[closer.marker][(closer.open ? 3 : 0) + ((closer.length || 0) % 3)] = newMinOpenerIdx;\n    }\n  }\n}\n\n\nmodule.exports = function link_pairs(state) {\n  var curr,\n      tokens_meta = state.tokens_meta,\n      max = state.tokens_meta.length;\n\n  processDelimiters(state, state.delimiters);\n\n  for (curr = 0; curr < max; curr++) {\n    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {\n      processDelimiters(state, tokens_meta[curr].delimiters);\n    }\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}