{"ast":null,"code":"import { l as log, g as getConfig, i as insertMarkers, s as setupGraphViewbox, a as getStylesFromArray, e as evaluate, c as common, b as insertNode, d as interpolateToCurve, f as insertEdgeLabel, h as db, p as parser } from \"./mermaid-ae477ddf.js\";\nimport { select, curveLinear, line } from \"d3\";\nimport { addHtmlLabel } from \"dagre-d3-es/src/dagre-js/label/add-html-label.js\";\nimport ELK from \"elkjs/lib/elk.bundled.js\";\nimport \"ts-dedent\";\nimport \"dayjs\";\nimport \"@braintree/sanitize-url\";\nimport \"dompurify\";\nimport \"khroma\";\nimport \"lodash-es/memoize.js\";\nimport \"stylis\";\nimport \"dagre-d3-es/src/dagre/index.js\";\nimport \"dagre-d3-es/src/graphlib/index.js\";\nimport \"dagre-d3-es/src/graphlib/json.js\";\nimport \"uuid\";\nimport \"dagre-d3-es\";\nimport \"dagre-d3-es/src/dagre-js/util.js\";\nimport \"dagre-d3-es/src/dagre-js/intersect/intersect-polygon.js\";\nimport \"dagre-d3-es/src/dagre-js/intersect/intersect-rect.js\";\nimport \"dayjs/plugin/isoWeek.js\";\nimport \"dayjs/plugin/customParseFormat.js\";\nimport \"dayjs/plugin/advancedFormat.js\";\nimport \"lodash-es/isEmpty.js\";\n\nconst findCommonAncestor = (id1, id2, treeData) => {\n  const {\n    parentById\n  } = treeData;\n  const visited = /* @__PURE__ */new Set();\n  let currentId = id1;\n\n  while (currentId) {\n    visited.add(currentId);\n\n    if (currentId === id2) {\n      return currentId;\n    }\n\n    currentId = parentById[currentId];\n  }\n\n  currentId = id2;\n\n  while (currentId) {\n    if (visited.has(currentId)) {\n      return currentId;\n    }\n\n    currentId = parentById[currentId];\n  }\n\n  return \"root\";\n};\n\nconst elk = new ELK();\nconst portPos = {};\nconst conf = {};\nlet nodeDb = {};\n\nconst addVertices = function (vert, svgId, root, doc, diagObj, parentLookupDb, graph) {\n  const svg = root.select(`[id=\"${svgId}\"]`);\n  const nodes = svg.insert(\"g\").attr(\"class\", \"nodes\");\n  const keys = Object.keys(vert);\n  keys.forEach(function (id) {\n    const vertex = vert[id];\n    let classStr = \"default\";\n\n    if (vertex.classes.length > 0) {\n      classStr = vertex.classes.join(\" \");\n    }\n\n    const styles2 = getStylesFromArray(vertex.styles);\n    let vertexText = vertex.text !== void 0 ? vertex.text : vertex.id;\n    let vertexNode;\n    const labelData = {\n      width: 0,\n      height: 0\n    };\n\n    if (evaluate(getConfig().flowchart.htmlLabels)) {\n      const node2 = {\n        label: vertexText.replace(/fa[blrs]?:fa-[\\w-]+/g, s => `<i class='${s.replace(\":\", \" \")}'></i>`)\n      };\n      vertexNode = addHtmlLabel(svg, node2).node();\n      const bbox = vertexNode.getBBox();\n      labelData.width = bbox.width;\n      labelData.height = bbox.height;\n      labelData.labelNode = vertexNode;\n      vertexNode.parentNode.removeChild(vertexNode);\n    } else {\n      const svgLabel = doc.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n      svgLabel.setAttribute(\"style\", styles2.labelStyle.replace(\"color:\", \"fill:\"));\n      const rows = vertexText.split(common.lineBreakRegex);\n\n      for (const row of rows) {\n        const tspan = doc.createElementNS(\"http://www.w3.org/2000/svg\", \"tspan\");\n        tspan.setAttributeNS(\"http://www.w3.org/XML/1998/namespace\", \"xml:space\", \"preserve\");\n        tspan.setAttribute(\"dy\", \"1em\");\n        tspan.setAttribute(\"x\", \"1\");\n        tspan.textContent = row;\n        svgLabel.appendChild(tspan);\n      }\n\n      vertexNode = svgLabel;\n      const bbox = vertexNode.getBBox();\n      labelData.width = bbox.width;\n      labelData.height = bbox.height;\n      labelData.labelNode = vertexNode;\n    }\n\n    const ports = [{\n      id: vertex.id + \"-west\",\n      layoutOptions: {\n        \"port.side\": \"WEST\"\n      }\n    }, {\n      id: vertex.id + \"-east\",\n      layoutOptions: {\n        \"port.side\": \"EAST\"\n      }\n    }, {\n      id: vertex.id + \"-south\",\n      layoutOptions: {\n        \"port.side\": \"SOUTH\"\n      }\n    }, {\n      id: vertex.id + \"-north\",\n      layoutOptions: {\n        \"port.side\": \"NORTH\"\n      }\n    }];\n    let radious = 0;\n    let _shape = \"\";\n    let layoutOptions = {};\n\n    switch (vertex.type) {\n      case \"round\":\n        radious = 5;\n        _shape = \"rect\";\n        break;\n\n      case \"square\":\n        _shape = \"rect\";\n        break;\n\n      case \"diamond\":\n        _shape = \"question\";\n        layoutOptions = {\n          portConstraints: \"FIXED_SIDE\"\n        };\n        break;\n\n      case \"hexagon\":\n        _shape = \"hexagon\";\n        break;\n\n      case \"odd\":\n        _shape = \"rect_left_inv_arrow\";\n        break;\n\n      case \"lean_right\":\n        _shape = \"lean_right\";\n        break;\n\n      case \"lean_left\":\n        _shape = \"lean_left\";\n        break;\n\n      case \"trapezoid\":\n        _shape = \"trapezoid\";\n        break;\n\n      case \"inv_trapezoid\":\n        _shape = \"inv_trapezoid\";\n        break;\n\n      case \"odd_right\":\n        _shape = \"rect_left_inv_arrow\";\n        break;\n\n      case \"circle\":\n        _shape = \"circle\";\n        break;\n\n      case \"ellipse\":\n        _shape = \"ellipse\";\n        break;\n\n      case \"stadium\":\n        _shape = \"stadium\";\n        break;\n\n      case \"subroutine\":\n        _shape = \"subroutine\";\n        break;\n\n      case \"cylinder\":\n        _shape = \"cylinder\";\n        break;\n\n      case \"group\":\n        _shape = \"rect\";\n        break;\n\n      case \"doublecircle\":\n        _shape = \"doublecircle\";\n        break;\n\n      default:\n        _shape = \"rect\";\n    }\n\n    const node = {\n      labelStyle: styles2.labelStyle,\n      shape: _shape,\n      labelText: vertexText,\n      rx: radious,\n      ry: radious,\n      class: classStr,\n      style: styles2.style,\n      id: vertex.id,\n      link: vertex.link,\n      linkTarget: vertex.linkTarget,\n      tooltip: diagObj.db.getTooltip(vertex.id) || \"\",\n      domId: diagObj.db.lookUpDomId(vertex.id),\n      haveCallback: vertex.haveCallback,\n      width: vertex.type === \"group\" ? 500 : void 0,\n      dir: vertex.dir,\n      type: vertex.type,\n      props: vertex.props,\n      padding: getConfig().flowchart.padding\n    };\n    let boundingBox;\n    let nodeEl;\n\n    if (node.type !== \"group\") {\n      nodeEl = insertNode(nodes, node, vertex.dir);\n      boundingBox = nodeEl.node().getBBox();\n    }\n\n    const data = {\n      id: vertex.id,\n      ports: vertex.type === \"diamond\" ? ports : [],\n      // labelStyle: styles.labelStyle,\n      // shape: _shape,\n      layoutOptions,\n      labelText: vertexText,\n      labelData,\n      // labels: [{ text: vertexText }],\n      // rx: radius,\n      // ry: radius,\n      // class: classStr,\n      // style: styles.style,\n      // link: vertex.link,\n      // linkTarget: vertex.linkTarget,\n      // tooltip: diagObj.db.getTooltip(vertex.id) || '',\n      domId: diagObj.db.lookUpDomId(vertex.id),\n      // haveCallback: vertex.haveCallback,\n      width: boundingBox == null ? void 0 : boundingBox.width,\n      height: boundingBox == null ? void 0 : boundingBox.height,\n      // dir: vertex.dir,\n      type: vertex.type,\n      // props: vertex.props,\n      // padding: getConfig().flowchart.padding,\n      // boundingBox,\n      el: nodeEl,\n      parent: parentLookupDb.parentById[vertex.id]\n    };\n    nodeDb[node.id] = data;\n  });\n  return graph;\n};\n\nconst getNextPosition = (position, edgeDirection, graphDirection) => {\n  const portPos2 = {\n    TB: {\n      in: {\n        north: \"north\"\n      },\n      out: {\n        south: \"west\",\n        west: \"east\",\n        east: \"south\"\n      }\n    },\n    LR: {\n      in: {\n        west: \"west\"\n      },\n      out: {\n        east: \"south\",\n        south: \"north\",\n        north: \"east\"\n      }\n    },\n    RL: {\n      in: {\n        east: \"east\"\n      },\n      out: {\n        west: \"north\",\n        north: \"south\",\n        south: \"west\"\n      }\n    },\n    BT: {\n      in: {\n        south: \"south\"\n      },\n      out: {\n        north: \"east\",\n        east: \"west\",\n        west: \"north\"\n      }\n    }\n  };\n  portPos2.TD = portPos2.TB;\n  log.info(\"abc88\", graphDirection, edgeDirection, position);\n  return portPos2[graphDirection][edgeDirection][position];\n};\n\nconst getNextPort = (node, edgeDirection, graphDirection) => {\n  log.info(\"getNextPort abc88\", {\n    node,\n    edgeDirection,\n    graphDirection\n  });\n\n  if (!portPos[node]) {\n    switch (graphDirection) {\n      case \"TB\":\n      case \"TD\":\n        portPos[node] = {\n          inPosition: \"north\",\n          outPosition: \"south\"\n        };\n        break;\n\n      case \"BT\":\n        portPos[node] = {\n          inPosition: \"south\",\n          outPosition: \"north\"\n        };\n        break;\n\n      case \"RL\":\n        portPos[node] = {\n          inPosition: \"east\",\n          outPosition: \"west\"\n        };\n        break;\n\n      case \"LR\":\n        portPos[node] = {\n          inPosition: \"west\",\n          outPosition: \"east\"\n        };\n        break;\n    }\n  }\n\n  const result = edgeDirection === \"in\" ? portPos[node].inPosition : portPos[node].outPosition;\n\n  if (edgeDirection === \"in\") {\n    portPos[node].inPosition = getNextPosition(portPos[node].inPosition, edgeDirection, graphDirection);\n  } else {\n    portPos[node].outPosition = getNextPosition(portPos[node].outPosition, edgeDirection, graphDirection);\n  }\n\n  return result;\n};\n\nconst getEdgeStartEndPoint = (edge, dir) => {\n  let source = edge.start;\n  let target = edge.end;\n  const startNode = nodeDb[source];\n  const endNode = nodeDb[target];\n\n  if (!startNode || !endNode) {\n    return {\n      source,\n      target\n    };\n  }\n\n  if (startNode.type === \"diamond\") {\n    source = `${source}-${getNextPort(source, \"out\", dir)}`;\n  }\n\n  if (endNode.type === \"diamond\") {\n    target = `${target}-${getNextPort(target, \"in\", dir)}`;\n  }\n\n  return {\n    source,\n    target\n  };\n};\n\nconst addEdges = function (edges, diagObj, graph, svg) {\n  log.info(\"abc78 edges = \", edges);\n  const labelsEl = svg.insert(\"g\").attr(\"class\", \"edgeLabels\");\n  let linkIdCnt = {};\n  let dir = diagObj.db.getDirection();\n  let defaultStyle;\n  let defaultLabelStyle;\n\n  if (edges.defaultStyle !== void 0) {\n    const defaultStyles = getStylesFromArray(edges.defaultStyle);\n    defaultStyle = defaultStyles.style;\n    defaultLabelStyle = defaultStyles.labelStyle;\n  }\n\n  edges.forEach(function (edge) {\n    var linkIdBase = \"L-\" + edge.start + \"-\" + edge.end;\n\n    if (linkIdCnt[linkIdBase] === void 0) {\n      linkIdCnt[linkIdBase] = 0;\n      log.info(\"abc78 new entry\", linkIdBase, linkIdCnt[linkIdBase]);\n    } else {\n      linkIdCnt[linkIdBase]++;\n      log.info(\"abc78 new entry\", linkIdBase, linkIdCnt[linkIdBase]);\n    }\n\n    let linkId = linkIdBase + \"-\" + linkIdCnt[linkIdBase];\n    log.info(\"abc78 new link id to be used is\", linkIdBase, linkId, linkIdCnt[linkIdBase]);\n    var linkNameStart = \"LS-\" + edge.start;\n    var linkNameEnd = \"LE-\" + edge.end;\n    const edgeData = {\n      style: \"\",\n      labelStyle: \"\"\n    };\n    edgeData.minlen = edge.length || 1;\n\n    if (edge.type === \"arrow_open\") {\n      edgeData.arrowhead = \"none\";\n    } else {\n      edgeData.arrowhead = \"normal\";\n    }\n\n    edgeData.arrowTypeStart = \"arrow_open\";\n    edgeData.arrowTypeEnd = \"arrow_open\";\n\n    switch (edge.type) {\n      case \"double_arrow_cross\":\n        edgeData.arrowTypeStart = \"arrow_cross\";\n\n      case \"arrow_cross\":\n        edgeData.arrowTypeEnd = \"arrow_cross\";\n        break;\n\n      case \"double_arrow_point\":\n        edgeData.arrowTypeStart = \"arrow_point\";\n\n      case \"arrow_point\":\n        edgeData.arrowTypeEnd = \"arrow_point\";\n        break;\n\n      case \"double_arrow_circle\":\n        edgeData.arrowTypeStart = \"arrow_circle\";\n\n      case \"arrow_circle\":\n        edgeData.arrowTypeEnd = \"arrow_circle\";\n        break;\n    }\n\n    let style = \"\";\n    let labelStyle = \"\";\n\n    switch (edge.stroke) {\n      case \"normal\":\n        style = \"fill:none;\";\n\n        if (defaultStyle !== void 0) {\n          style = defaultStyle;\n        }\n\n        if (defaultLabelStyle !== void 0) {\n          labelStyle = defaultLabelStyle;\n        }\n\n        edgeData.thickness = \"normal\";\n        edgeData.pattern = \"solid\";\n        break;\n\n      case \"dotted\":\n        edgeData.thickness = \"normal\";\n        edgeData.pattern = \"dotted\";\n        edgeData.style = \"fill:none;stroke-width:2px;stroke-dasharray:3;\";\n        break;\n\n      case \"thick\":\n        edgeData.thickness = \"thick\";\n        edgeData.pattern = \"solid\";\n        edgeData.style = \"stroke-width: 3.5px;fill:none;\";\n        break;\n    }\n\n    if (edge.style !== void 0) {\n      const styles2 = getStylesFromArray(edge.style);\n      style = styles2.style;\n      labelStyle = styles2.labelStyle;\n    }\n\n    edgeData.style = edgeData.style += style;\n    edgeData.labelStyle = edgeData.labelStyle += labelStyle;\n\n    if (edge.interpolate !== void 0) {\n      edgeData.curve = interpolateToCurve(edge.interpolate, curveLinear);\n    } else if (edges.defaultInterpolate !== void 0) {\n      edgeData.curve = interpolateToCurve(edges.defaultInterpolate, curveLinear);\n    } else {\n      edgeData.curve = interpolateToCurve(conf.curve, curveLinear);\n    }\n\n    if (edge.text === void 0) {\n      if (edge.style !== void 0) {\n        edgeData.arrowheadStyle = \"fill: #333\";\n      }\n    } else {\n      edgeData.arrowheadStyle = \"fill: #333\";\n      edgeData.labelpos = \"c\";\n    }\n\n    edgeData.labelType = \"text\";\n    edgeData.label = edge.text.replace(common.lineBreakRegex, \"\\n\");\n\n    if (edge.style === void 0) {\n      edgeData.style = edgeData.style || \"stroke: #333; stroke-width: 1.5px;fill:none;\";\n    }\n\n    edgeData.labelStyle = edgeData.labelStyle.replace(\"color:\", \"fill:\");\n    edgeData.id = linkId;\n    edgeData.classes = \"flowchart-link \" + linkNameStart + \" \" + linkNameEnd;\n    const labelEl = insertEdgeLabel(labelsEl, edgeData);\n    const {\n      source,\n      target\n    } = getEdgeStartEndPoint(edge, dir);\n    log.debug(\"abc78 source and target\", source, target);\n    graph.edges.push({\n      id: \"e\" + edge.start + edge.end,\n      sources: [source],\n      targets: [target],\n      labelEl,\n      labels: [{\n        width: edgeData.width,\n        height: edgeData.height,\n        orgWidth: edgeData.width,\n        orgHeight: edgeData.height,\n        text: edgeData.label,\n        layoutOptions: {\n          \"edgeLabels.inline\": \"true\",\n          \"edgeLabels.placement\": \"CENTER\"\n        }\n      }],\n      edgeData\n    });\n  });\n  return graph;\n};\n\nconst addMarkersToEdge = function (svgPath, edgeData, diagramType, arrowMarkerAbsolute) {\n  let url = \"\";\n\n  if (arrowMarkerAbsolute) {\n    url = window.location.protocol + \"//\" + window.location.host + window.location.pathname + window.location.search;\n    url = url.replace(/\\(/g, \"\\\\(\");\n    url = url.replace(/\\)/g, \"\\\\)\");\n  }\n\n  switch (edgeData.arrowTypeStart) {\n    case \"arrow_cross\":\n      svgPath.attr(\"marker-start\", \"url(\" + url + \"#\" + diagramType + \"-crossStart)\");\n      break;\n\n    case \"arrow_point\":\n      svgPath.attr(\"marker-start\", \"url(\" + url + \"#\" + diagramType + \"-pointStart)\");\n      break;\n\n    case \"arrow_barb\":\n      svgPath.attr(\"marker-start\", \"url(\" + url + \"#\" + diagramType + \"-barbStart)\");\n      break;\n\n    case \"arrow_circle\":\n      svgPath.attr(\"marker-start\", \"url(\" + url + \"#\" + diagramType + \"-circleStart)\");\n      break;\n\n    case \"aggregation\":\n      svgPath.attr(\"marker-start\", \"url(\" + url + \"#\" + diagramType + \"-aggregationStart)\");\n      break;\n\n    case \"extension\":\n      svgPath.attr(\"marker-start\", \"url(\" + url + \"#\" + diagramType + \"-extensionStart)\");\n      break;\n\n    case \"composition\":\n      svgPath.attr(\"marker-start\", \"url(\" + url + \"#\" + diagramType + \"-compositionStart)\");\n      break;\n\n    case \"dependency\":\n      svgPath.attr(\"marker-start\", \"url(\" + url + \"#\" + diagramType + \"-dependencyStart)\");\n      break;\n\n    case \"lollipop\":\n      svgPath.attr(\"marker-start\", \"url(\" + url + \"#\" + diagramType + \"-lollipopStart)\");\n      break;\n  }\n\n  switch (edgeData.arrowTypeEnd) {\n    case \"arrow_cross\":\n      svgPath.attr(\"marker-end\", \"url(\" + url + \"#\" + diagramType + \"-crossEnd)\");\n      break;\n\n    case \"arrow_point\":\n      svgPath.attr(\"marker-end\", \"url(\" + url + \"#\" + diagramType + \"-pointEnd)\");\n      break;\n\n    case \"arrow_barb\":\n      svgPath.attr(\"marker-end\", \"url(\" + url + \"#\" + diagramType + \"-barbEnd)\");\n      break;\n\n    case \"arrow_circle\":\n      svgPath.attr(\"marker-end\", \"url(\" + url + \"#\" + diagramType + \"-circleEnd)\");\n      break;\n\n    case \"aggregation\":\n      svgPath.attr(\"marker-end\", \"url(\" + url + \"#\" + diagramType + \"-aggregationEnd)\");\n      break;\n\n    case \"extension\":\n      svgPath.attr(\"marker-end\", \"url(\" + url + \"#\" + diagramType + \"-extensionEnd)\");\n      break;\n\n    case \"composition\":\n      svgPath.attr(\"marker-end\", \"url(\" + url + \"#\" + diagramType + \"-compositionEnd)\");\n      break;\n\n    case \"dependency\":\n      svgPath.attr(\"marker-end\", \"url(\" + url + \"#\" + diagramType + \"-dependencyEnd)\");\n      break;\n\n    case \"lollipop\":\n      svgPath.attr(\"marker-end\", \"url(\" + url + \"#\" + diagramType + \"-lollipopEnd)\");\n      break;\n  }\n};\n\nconst getClasses = function (text, diagObj) {\n  log.info(\"Extracting classes\");\n  diagObj.db.clear(\"ver-2\");\n\n  try {\n    diagObj.parse(text);\n    return diagObj.db.getClasses();\n  } catch (e) {\n    return {};\n  }\n};\n\nconst addSubGraphs = function (db2) {\n  const parentLookupDb = {\n    parentById: {},\n    childrenById: {}\n  };\n  const subgraphs = db2.getSubGraphs();\n  log.info(\"Subgraphs - \", subgraphs);\n  subgraphs.forEach(function (subgraph) {\n    subgraph.nodes.forEach(function (node) {\n      parentLookupDb.parentById[node] = subgraph.id;\n\n      if (parentLookupDb.childrenById[subgraph.id] === void 0) {\n        parentLookupDb.childrenById[subgraph.id] = [];\n      }\n\n      parentLookupDb.childrenById[subgraph.id].push(node);\n    });\n  });\n  subgraphs.forEach(function (subgraph) {\n    ({\n      id: subgraph.id\n    });\n\n    if (parentLookupDb.parentById[subgraph.id] !== void 0) {\n      parentLookupDb.parentById[subgraph.id];\n    }\n  });\n  return parentLookupDb;\n};\n\nconst calcOffset = function (src, dest, parentLookupDb) {\n  const ancestor = findCommonAncestor(src, dest, parentLookupDb);\n\n  if (ancestor === void 0 || ancestor === \"root\") {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n\n  const ancestorOffset = nodeDb[ancestor].offset;\n  return {\n    x: ancestorOffset.posX,\n    y: ancestorOffset.posY\n  };\n};\n\nconst insertEdge = function (edgesEl, edge, edgeData, diagObj, parentLookupDb) {\n  const offset = calcOffset(edge.sources[0], edge.targets[0], parentLookupDb);\n  const src = edge.sections[0].startPoint;\n  const dest = edge.sections[0].endPoint;\n  const segments = edge.sections[0].bendPoints ? edge.sections[0].bendPoints : [];\n  const segPoints = segments.map(segment => [segment.x + offset.x, segment.y + offset.y]);\n  const points = [[src.x + offset.x, src.y + offset.y], ...segPoints, [dest.x + offset.x, dest.y + offset.y]];\n  const curve = line().curve(curveLinear);\n  const edgePath = edgesEl.insert(\"path\").attr(\"d\", curve(points)).attr(\"class\", \"path\").attr(\"fill\", \"none\");\n  const edgeG = edgesEl.insert(\"g\").attr(\"class\", \"edgeLabel\");\n  const edgeWithLabel = select(edgeG.node().appendChild(edge.labelEl));\n  const box = edgeWithLabel.node().firstChild.getBoundingClientRect();\n  edgeWithLabel.attr(\"width\", box.width);\n  edgeWithLabel.attr(\"height\", box.height);\n  edgeG.attr(\"transform\", `translate(${edge.labels[0].x + offset.x}, ${edge.labels[0].y + offset.y})`);\n  addMarkersToEdge(edgePath, edgeData, diagObj.type, diagObj.arrowMarkerAbsolute);\n};\n\nconst insertChildren = (nodeArray, parentLookupDb) => {\n  nodeArray.forEach(node => {\n    if (!node.children) {\n      node.children = [];\n    }\n\n    const childIds = parentLookupDb.childrenById[node.id];\n\n    if (childIds) {\n      childIds.forEach(childId => {\n        node.children.push(nodeDb[childId]);\n      });\n    }\n\n    insertChildren(node.children, parentLookupDb);\n  });\n};\n\nconst draw = async function (text, id, _version, diagObj) {\n  var _a;\n\n  diagObj.db.clear();\n  nodeDb = {};\n  diagObj.db.setGen(\"gen-2\");\n  diagObj.parser.parse(text);\n  const renderEl = select(\"body\").append(\"div\").attr(\"style\", \"height:400px\").attr(\"id\", \"cy\");\n  let graph = {\n    id: \"root\",\n    layoutOptions: {\n      \"elk.hierarchyHandling\": \"INCLUDE_CHILDREN\",\n      \"org.eclipse.elk.padding\": \"[top=100, left=100, bottom=110, right=110]\",\n      \"elk.layered.spacing.edgeNodeBetweenLayers\": \"30\",\n      // 'elk.layered.mergeEdges': 'true',\n      \"elk.direction\": \"DOWN\" // 'elk.ports.sameLayerEdges': true,\n      // 'nodePlacement.strategy': 'SIMPLE',\n\n    },\n    children: [],\n    edges: []\n  };\n  log.info(\"Drawing flowchart using v3 renderer\", elk);\n  let dir = diagObj.db.getDirection();\n\n  switch (dir) {\n    case \"BT\":\n      graph.layoutOptions[\"elk.direction\"] = \"UP\";\n      break;\n\n    case \"TB\":\n      graph.layoutOptions[\"elk.direction\"] = \"DOWN\";\n      break;\n\n    case \"LR\":\n      graph.layoutOptions[\"elk.direction\"] = \"RIGHT\";\n      break;\n\n    case \"RL\":\n      graph.layoutOptions[\"elk.direction\"] = \"LEFT\";\n      break;\n  }\n\n  const {\n    securityLevel,\n    flowchart: conf2\n  } = getConfig();\n  let sandboxElement;\n\n  if (securityLevel === \"sandbox\") {\n    sandboxElement = select(\"#i\" + id);\n  }\n\n  const root = securityLevel === \"sandbox\" ? select(sandboxElement.nodes()[0].contentDocument.body) : select(\"body\");\n  const doc = securityLevel === \"sandbox\" ? sandboxElement.nodes()[0].contentDocument : document;\n  const svg = root.select(`[id=\"${id}\"]`);\n  const markers = [\"point\", \"circle\", \"cross\"];\n  insertMarkers(svg, markers, diagObj.type, diagObj.arrowMarkerAbsolute);\n  const vert = diagObj.db.getVertices();\n  let subG;\n  const subGraphs = diagObj.db.getSubGraphs();\n  log.info(\"Subgraphs - \", subGraphs);\n\n  for (let i = subGraphs.length - 1; i >= 0; i--) {\n    subG = subGraphs[i];\n    diagObj.db.addVertex(subG.id, subG.title, \"group\", void 0, subG.classes, subG.dir);\n  }\n\n  const subGraphsEl = svg.insert(\"g\").attr(\"class\", \"subgraphs\");\n  const parentLookupDb = addSubGraphs(diagObj.db);\n  graph = addVertices(vert, id, root, doc, diagObj, parentLookupDb, graph);\n  const edgesEl = svg.insert(\"g\").attr(\"class\", \"edges edgePath\");\n  const edges = diagObj.db.getEdges();\n  graph = addEdges(edges, diagObj, graph, svg);\n  const nodes = Object.keys(nodeDb);\n  nodes.forEach(nodeId => {\n    const node = nodeDb[nodeId];\n\n    if (!node.parent) {\n      graph.children.push(node);\n    }\n\n    if (parentLookupDb.childrenById[nodeId] !== void 0) {\n      node.labels = [{\n        text: node.labelText,\n        layoutOptions: {\n          \"nodeLabels.placement\": \"[H_CENTER, V_TOP, INSIDE]\"\n        },\n        width: node.labelData.width,\n        height: node.labelData.height\n      }];\n      delete node.x;\n      delete node.y;\n      delete node.width;\n      delete node.height;\n    }\n  });\n  insertChildren(graph.children, parentLookupDb);\n  log.info(\"after layout\", JSON.stringify(graph, null, 2));\n  const g = await elk.layout(graph);\n  drawNodes(0, 0, g.children, svg, subGraphsEl, diagObj, 0);\n  log.info(\"after layout\", g);\n  (_a = g.edges) == null ? void 0 : _a.map(edge => {\n    insertEdge(edgesEl, edge, edge.edgeData, diagObj, parentLookupDb);\n  });\n  setupGraphViewbox({}, svg, conf2.diagramPadding, conf2.useMaxWidth);\n  renderEl.remove();\n};\n\nconst drawNodes = (relX, relY, nodeArray, svg, subgraphsEl, diagObj, depth) => {\n  nodeArray.forEach(function (node) {\n    if (node) {\n      nodeDb[node.id].offset = {\n        posX: node.x + relX,\n        posY: node.y + relY,\n        x: relX,\n        y: relY,\n        depth,\n        width: node.width,\n        height: node.height\n      };\n\n      if (node.type === \"group\") {\n        const subgraphEl = subgraphsEl.insert(\"g\").attr(\"class\", \"subgraph\");\n        subgraphEl.insert(\"rect\").attr(\"class\", \"subgraph subgraph-lvl-\" + depth % 5 + \" node\").attr(\"x\", node.x + relX).attr(\"y\", node.y + relY).attr(\"width\", node.width).attr(\"height\", node.height);\n        const label = subgraphEl.insert(\"g\").attr(\"class\", \"label\");\n        label.attr(\"transform\", `translate(${node.labels[0].x + relX + node.x}, ${node.labels[0].y + relY + node.y})`);\n        label.node().appendChild(node.labelData.labelNode);\n        log.info(\"Id (UGH)= \", node.type, node.labels);\n      } else {\n        log.info(\"Id (UGH)= \", node.id);\n        node.el.attr(\"transform\", `translate(${node.x + relX + node.width / 2}, ${node.y + relY + node.height / 2})`);\n      }\n    }\n  });\n  nodeArray.forEach(function (node) {\n    if (node && node.type === \"group\") {\n      drawNodes(relX + node.x, relY + node.y, node.children, svg, subgraphsEl, diagObj, depth + 1);\n    }\n  });\n};\n\nconst renderer = {\n  getClasses,\n  draw\n};\n\nconst genSections = options => {\n  let sections = \"\";\n\n  for (let i = 0; i < 5; i++) {\n    sections += `\n      .subgraph-lvl-${i} {\n        fill: ${options[`surface${i}`]};\n        stroke: ${options[`surfacePeer${i}`]};\n      }\n    `;\n  }\n\n  return sections;\n};\n\nconst getStyles = options => `.label {\n    font-family: ${options.fontFamily};\n    color: ${options.nodeTextColor || options.textColor};\n  }\n  .cluster-label text {\n    fill: ${options.titleColor};\n  }\n  .cluster-label span {\n    color: ${options.titleColor};\n  }\n\n  .label text,span {\n    fill: ${options.nodeTextColor || options.textColor};\n    color: ${options.nodeTextColor || options.textColor};\n  }\n\n  .node rect,\n  .node circle,\n  .node ellipse,\n  .node polygon,\n  .node path {\n    fill: ${options.mainBkg};\n    stroke: ${options.nodeBorder};\n    stroke-width: 1px;\n  }\n\n  .node .label {\n    text-align: center;\n  }\n  .node.clickable {\n    cursor: pointer;\n  }\n\n  .arrowheadPath {\n    fill: ${options.arrowheadColor};\n  }\n\n  .edgePath .path {\n    stroke: ${options.lineColor};\n    stroke-width: 2.0px;\n  }\n\n  .flowchart-link {\n    stroke: ${options.lineColor};\n    fill: none;\n  }\n\n  .edgeLabel {\n    background-color: ${options.edgeLabelBackground};\n    rect {\n      opacity: 0.5;\n      background-color: ${options.edgeLabelBackground};\n      fill: ${options.edgeLabelBackground};\n    }\n    text-align: center;\n  }\n\n  .cluster rect {\n    fill: ${options.clusterBkg};\n    stroke: ${options.clusterBorder};\n    stroke-width: 1px;\n  }\n\n  .cluster text {\n    fill: ${options.titleColor};\n  }\n\n  .cluster span {\n    color: ${options.titleColor};\n  }\n  /* .cluster div {\n    color: ${options.titleColor};\n  } */\n\n  div.mermaidTooltip {\n    position: absolute;\n    text-align: center;\n    max-width: 200px;\n    padding: 2px;\n    font-family: ${options.fontFamily};\n    font-size: 12px;\n    background: ${options.tertiaryColor};\n    border: 1px solid ${options.border2};\n    border-radius: 2px;\n    pointer-events: none;\n    z-index: 100;\n  }\n\n  .flowchartTitleText {\n    text-anchor: middle;\n    font-size: 18px;\n    fill: ${options.textColor};\n  }\n  .subgraph {\n    stroke-width:2;\n    rx:3;\n  }\n  // .subgraph-lvl-1 {\n  //   fill:#ccc;\n  //   // stroke:black;\n  // }\n  ${genSections(options)}\n`;\n\nconst styles = getStyles;\nconst diagram = {\n  db,\n  renderer,\n  parser,\n  styles\n};\nexport { diagram };","map":null,"metadata":{},"sourceType":"module"}