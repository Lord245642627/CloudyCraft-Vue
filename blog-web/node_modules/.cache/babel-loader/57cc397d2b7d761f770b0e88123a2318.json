{"ast":null,"code":"/*!\n  * @intlify/message-compiler v9.1.10\n  * (c) 2022 kazuya kawaguchi\n  * Released under the MIT License.\n  */\nimport { format, assign, isString } from '@intlify/shared';\n/** @internal */\n\nconst errorMessages = {\n  // tokenizer error messages\n  [0\n  /* EXPECTED_TOKEN */\n  ]: `Expected token: '{0}'`,\n  [1\n  /* INVALID_TOKEN_IN_PLACEHOLDER */\n  ]: `Invalid token in placeholder: '{0}'`,\n  [2\n  /* UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER */\n  ]: `Unterminated single quote in placeholder`,\n  [3\n  /* UNKNOWN_ESCAPE_SEQUENCE */\n  ]: `Unknown escape sequence: \\\\{0}`,\n  [4\n  /* INVALID_UNICODE_ESCAPE_SEQUENCE */\n  ]: `Invalid unicode escape sequence: {0}`,\n  [5\n  /* UNBALANCED_CLOSING_BRACE */\n  ]: `Unbalanced closing brace`,\n  [6\n  /* UNTERMINATED_CLOSING_BRACE */\n  ]: `Unterminated closing brace`,\n  [7\n  /* EMPTY_PLACEHOLDER */\n  ]: `Empty placeholder`,\n  [8\n  /* NOT_ALLOW_NEST_PLACEHOLDER */\n  ]: `Not allowed nest placeholder`,\n  [9\n  /* INVALID_LINKED_FORMAT */\n  ]: `Invalid linked format`,\n  // parser error messages\n  [10\n  /* MUST_HAVE_MESSAGES_IN_PLURAL */\n  ]: `Plural must have messages`,\n  [11\n  /* UNEXPECTED_EMPTY_LINKED_MODIFIER */\n  ]: `Unexpected empty linked modifier`,\n  [12\n  /* UNEXPECTED_EMPTY_LINKED_KEY */\n  ]: `Unexpected empty linked key`,\n  [13\n  /* UNEXPECTED_LEXICAL_ANALYSIS */\n  ]: `Unexpected lexical analysis in token: '{0}'`\n};\n\nfunction createCompileError(code, loc, options = {}) {\n  const {\n    domain,\n    messages,\n    args\n  } = options;\n  const msg = process.env.NODE_ENV !== 'production' ? format((messages || errorMessages)[code] || '', ...(args || [])) : code;\n  const error = new SyntaxError(String(msg));\n  error.code = code;\n\n  if (loc) {\n    error.location = loc;\n  }\n\n  error.domain = domain;\n  return error;\n}\n/** @internal */\n\n\nfunction defaultOnError(error) {\n  throw error;\n}\n\nconst LocationStub = {\n  start: {\n    line: 1,\n    column: 1,\n    offset: 0\n  },\n  end: {\n    line: 1,\n    column: 1,\n    offset: 0\n  }\n};\n\nfunction createPosition(line, column, offset) {\n  return {\n    line,\n    column,\n    offset\n  };\n}\n\nfunction createLocation(start, end, source) {\n  const loc = {\n    start,\n    end\n  };\n\n  if (source != null) {\n    loc.source = source;\n  }\n\n  return loc;\n}\n\nconst CHAR_SP = ' ';\nconst CHAR_CR = '\\r';\nconst CHAR_LF = '\\n';\nconst CHAR_LS = String.fromCharCode(0x2028);\nconst CHAR_PS = String.fromCharCode(0x2029);\n\nfunction createScanner(str) {\n  const _buf = str;\n  let _index = 0;\n  let _line = 1;\n  let _column = 1;\n  let _peekOffset = 0;\n\n  const isCRLF = index => _buf[index] === CHAR_CR && _buf[index + 1] === CHAR_LF;\n\n  const isLF = index => _buf[index] === CHAR_LF;\n\n  const isPS = index => _buf[index] === CHAR_PS;\n\n  const isLS = index => _buf[index] === CHAR_LS;\n\n  const isLineEnd = index => isCRLF(index) || isLF(index) || isPS(index) || isLS(index);\n\n  const index = () => _index;\n\n  const line = () => _line;\n\n  const column = () => _column;\n\n  const peekOffset = () => _peekOffset;\n\n  const charAt = offset => isCRLF(offset) || isPS(offset) || isLS(offset) ? CHAR_LF : _buf[offset];\n\n  const currentChar = () => charAt(_index);\n\n  const currentPeek = () => charAt(_index + _peekOffset);\n\n  function next() {\n    _peekOffset = 0;\n\n    if (isLineEnd(_index)) {\n      _line++;\n      _column = 0;\n    }\n\n    if (isCRLF(_index)) {\n      _index++;\n    }\n\n    _index++;\n    _column++;\n    return _buf[_index];\n  }\n\n  function peek() {\n    if (isCRLF(_index + _peekOffset)) {\n      _peekOffset++;\n    }\n\n    _peekOffset++;\n    return _buf[_index + _peekOffset];\n  }\n\n  function reset() {\n    _index = 0;\n    _line = 1;\n    _column = 1;\n    _peekOffset = 0;\n  }\n\n  function resetPeek(offset = 0) {\n    _peekOffset = offset;\n  }\n\n  function skipToPeek() {\n    const target = _index + _peekOffset; // eslint-disable-next-line no-unmodified-loop-condition\n\n    while (target !== _index) {\n      next();\n    }\n\n    _peekOffset = 0;\n  }\n\n  return {\n    index,\n    line,\n    column,\n    peekOffset,\n    charAt,\n    currentChar,\n    currentPeek,\n    next,\n    peek,\n    reset,\n    resetPeek,\n    skipToPeek\n  };\n}\n\nconst EOF = undefined;\nconst LITERAL_DELIMITER = \"'\";\nconst ERROR_DOMAIN$1 = 'tokenizer';\n\nfunction createTokenizer(source, options = {}) {\n  const location = options.location !== false;\n\n  const _scnr = createScanner(source);\n\n  const currentOffset = () => _scnr.index();\n\n  const currentPosition = () => createPosition(_scnr.line(), _scnr.column(), _scnr.index());\n\n  const _initLoc = currentPosition();\n\n  const _initOffset = currentOffset();\n\n  const _context = {\n    currentType: 14\n    /* EOF */\n    ,\n    offset: _initOffset,\n    startLoc: _initLoc,\n    endLoc: _initLoc,\n    lastType: 14\n    /* EOF */\n    ,\n    lastOffset: _initOffset,\n    lastStartLoc: _initLoc,\n    lastEndLoc: _initLoc,\n    braceNest: 0,\n    inLinked: false,\n    text: ''\n  };\n\n  const context = () => _context;\n\n  const {\n    onError\n  } = options;\n\n  function emitError(code, pos, offset, ...args) {\n    const ctx = context();\n    pos.column += offset;\n    pos.offset += offset;\n\n    if (onError) {\n      const loc = createLocation(ctx.startLoc, pos);\n      const err = createCompileError(code, loc, {\n        domain: ERROR_DOMAIN$1,\n        args\n      });\n      onError(err);\n    }\n  }\n\n  function getToken(context, type, value) {\n    context.endLoc = currentPosition();\n    context.currentType = type;\n    const token = {\n      type\n    };\n\n    if (location) {\n      token.loc = createLocation(context.startLoc, context.endLoc);\n    }\n\n    if (value != null) {\n      token.value = value;\n    }\n\n    return token;\n  }\n\n  const getEndToken = context => getToken(context, 14\n  /* EOF */\n  );\n\n  function eat(scnr, ch) {\n    if (scnr.currentChar() === ch) {\n      scnr.next();\n      return ch;\n    } else {\n      emitError(0\n      /* EXPECTED_TOKEN */\n      , currentPosition(), 0, ch);\n      return '';\n    }\n  }\n\n  function peekSpaces(scnr) {\n    let buf = '';\n\n    while (scnr.currentPeek() === CHAR_SP || scnr.currentPeek() === CHAR_LF) {\n      buf += scnr.currentPeek();\n      scnr.peek();\n    }\n\n    return buf;\n  }\n\n  function skipSpaces(scnr) {\n    const buf = peekSpaces(scnr);\n    scnr.skipToPeek();\n    return buf;\n  }\n\n  function isIdentifierStart(ch) {\n    if (ch === EOF) {\n      return false;\n    }\n\n    const cc = ch.charCodeAt(0);\n    return cc >= 97 && cc <= 122 || // a-z\n    cc >= 65 && cc <= 90 || // A-Z\n    cc === 95 // _\n    ;\n  }\n\n  function isNumberStart(ch) {\n    if (ch === EOF) {\n      return false;\n    }\n\n    const cc = ch.charCodeAt(0);\n    return cc >= 48 && cc <= 57; // 0-9\n  }\n\n  function isNamedIdentifierStart(scnr, context) {\n    const {\n      currentType\n    } = context;\n\n    if (currentType !== 2\n    /* BraceLeft */\n    ) {\n      return false;\n    }\n\n    peekSpaces(scnr);\n    const ret = isIdentifierStart(scnr.currentPeek());\n    scnr.resetPeek();\n    return ret;\n  }\n\n  function isListIdentifierStart(scnr, context) {\n    const {\n      currentType\n    } = context;\n\n    if (currentType !== 2\n    /* BraceLeft */\n    ) {\n      return false;\n    }\n\n    peekSpaces(scnr);\n    const ch = scnr.currentPeek() === '-' ? scnr.peek() : scnr.currentPeek();\n    const ret = isNumberStart(ch);\n    scnr.resetPeek();\n    return ret;\n  }\n\n  function isLiteralStart(scnr, context) {\n    const {\n      currentType\n    } = context;\n\n    if (currentType !== 2\n    /* BraceLeft */\n    ) {\n      return false;\n    }\n\n    peekSpaces(scnr);\n    const ret = scnr.currentPeek() === LITERAL_DELIMITER;\n    scnr.resetPeek();\n    return ret;\n  }\n\n  function isLinkedDotStart(scnr, context) {\n    const {\n      currentType\n    } = context;\n\n    if (currentType !== 8\n    /* LinkedAlias */\n    ) {\n      return false;\n    }\n\n    peekSpaces(scnr);\n    const ret = scnr.currentPeek() === \".\"\n    /* LinkedDot */\n    ;\n    scnr.resetPeek();\n    return ret;\n  }\n\n  function isLinkedModifierStart(scnr, context) {\n    const {\n      currentType\n    } = context;\n\n    if (currentType !== 9\n    /* LinkedDot */\n    ) {\n      return false;\n    }\n\n    peekSpaces(scnr);\n    const ret = isIdentifierStart(scnr.currentPeek());\n    scnr.resetPeek();\n    return ret;\n  }\n\n  function isLinkedDelimiterStart(scnr, context) {\n    const {\n      currentType\n    } = context;\n\n    if (!(currentType === 8\n    /* LinkedAlias */\n    || currentType === 12\n    /* LinkedModifier */\n    )) {\n      return false;\n    }\n\n    peekSpaces(scnr);\n    const ret = scnr.currentPeek() === \":\"\n    /* LinkedDelimiter */\n    ;\n    scnr.resetPeek();\n    return ret;\n  }\n\n  function isLinkedReferStart(scnr, context) {\n    const {\n      currentType\n    } = context;\n\n    if (currentType !== 10\n    /* LinkedDelimiter */\n    ) {\n      return false;\n    }\n\n    const fn = () => {\n      const ch = scnr.currentPeek();\n\n      if (ch === \"{\"\n      /* BraceLeft */\n      ) {\n        return isIdentifierStart(scnr.peek());\n      } else if (ch === \"@\"\n      /* LinkedAlias */\n      || ch === \"%\"\n      /* Modulo */\n      || ch === \"|\"\n      /* Pipe */\n      || ch === \":\"\n      /* LinkedDelimiter */\n      || ch === \".\"\n      /* LinkedDot */\n      || ch === CHAR_SP || !ch) {\n        return false;\n      } else if (ch === CHAR_LF) {\n        scnr.peek();\n        return fn();\n      } else {\n        // other characters\n        return isIdentifierStart(ch);\n      }\n    };\n\n    const ret = fn();\n    scnr.resetPeek();\n    return ret;\n  }\n\n  function isPluralStart(scnr) {\n    peekSpaces(scnr);\n    const ret = scnr.currentPeek() === \"|\"\n    /* Pipe */\n    ;\n    scnr.resetPeek();\n    return ret;\n  }\n\n  function isTextStart(scnr, reset = true) {\n    const fn = (hasSpace = false, prev = '', detectModulo = false) => {\n      const ch = scnr.currentPeek();\n\n      if (ch === \"{\"\n      /* BraceLeft */\n      ) {\n        return prev === \"%\"\n        /* Modulo */\n        ? false : hasSpace;\n      } else if (ch === \"@\"\n      /* LinkedAlias */\n      || !ch) {\n        return prev === \"%\"\n        /* Modulo */\n        ? true : hasSpace;\n      } else if (ch === \"%\"\n      /* Modulo */\n      ) {\n        scnr.peek();\n        return fn(hasSpace, \"%\"\n        /* Modulo */\n        , true);\n      } else if (ch === \"|\"\n      /* Pipe */\n      ) {\n        return prev === \"%\"\n        /* Modulo */\n        || detectModulo ? true : !(prev === CHAR_SP || prev === CHAR_LF);\n      } else if (ch === CHAR_SP) {\n        scnr.peek();\n        return fn(true, CHAR_SP, detectModulo);\n      } else if (ch === CHAR_LF) {\n        scnr.peek();\n        return fn(true, CHAR_LF, detectModulo);\n      } else {\n        return true;\n      }\n    };\n\n    const ret = fn();\n    reset && scnr.resetPeek();\n    return ret;\n  }\n\n  function takeChar(scnr, fn) {\n    const ch = scnr.currentChar();\n\n    if (ch === EOF) {\n      return EOF;\n    }\n\n    if (fn(ch)) {\n      scnr.next();\n      return ch;\n    }\n\n    return null;\n  }\n\n  function takeIdentifierChar(scnr) {\n    const closure = ch => {\n      const cc = ch.charCodeAt(0);\n      return cc >= 97 && cc <= 122 || // a-z\n      cc >= 65 && cc <= 90 || // A-Z\n      cc >= 48 && cc <= 57 || // 0-9\n      cc === 95 || // _\n      cc === 36 // $\n      ;\n    };\n\n    return takeChar(scnr, closure);\n  }\n\n  function takeDigit(scnr) {\n    const closure = ch => {\n      const cc = ch.charCodeAt(0);\n      return cc >= 48 && cc <= 57; // 0-9\n    };\n\n    return takeChar(scnr, closure);\n  }\n\n  function takeHexDigit(scnr) {\n    const closure = ch => {\n      const cc = ch.charCodeAt(0);\n      return cc >= 48 && cc <= 57 || // 0-9\n      cc >= 65 && cc <= 70 || // A-F\n      cc >= 97 && cc <= 102; // a-f\n    };\n\n    return takeChar(scnr, closure);\n  }\n\n  function getDigits(scnr) {\n    let ch = '';\n    let num = '';\n\n    while (ch = takeDigit(scnr)) {\n      num += ch;\n    }\n\n    return num;\n  }\n\n  function readText(scnr) {\n    let buf = '';\n\n    while (true) {\n      const ch = scnr.currentChar();\n\n      if (ch === \"{\"\n      /* BraceLeft */\n      || ch === \"}\"\n      /* BraceRight */\n      || ch === \"@\"\n      /* LinkedAlias */\n      || ch === \"|\"\n      /* Pipe */\n      || !ch) {\n        break;\n      } else if (ch === \"%\"\n      /* Modulo */\n      ) {\n        if (isTextStart(scnr)) {\n          buf += ch;\n          scnr.next();\n        } else {\n          break;\n        }\n      } else if (ch === CHAR_SP || ch === CHAR_LF) {\n        if (isTextStart(scnr)) {\n          buf += ch;\n          scnr.next();\n        } else if (isPluralStart(scnr)) {\n          break;\n        } else {\n          buf += ch;\n          scnr.next();\n        }\n      } else {\n        buf += ch;\n        scnr.next();\n      }\n    }\n\n    return buf;\n  }\n\n  function readNamedIdentifier(scnr) {\n    skipSpaces(scnr);\n    let ch = '';\n    let name = '';\n\n    while (ch = takeIdentifierChar(scnr)) {\n      name += ch;\n    }\n\n    if (scnr.currentChar() === EOF) {\n      emitError(6\n      /* UNTERMINATED_CLOSING_BRACE */\n      , currentPosition(), 0);\n    }\n\n    return name;\n  }\n\n  function readListIdentifier(scnr) {\n    skipSpaces(scnr);\n    let value = '';\n\n    if (scnr.currentChar() === '-') {\n      scnr.next();\n      value += `-${getDigits(scnr)}`;\n    } else {\n      value += getDigits(scnr);\n    }\n\n    if (scnr.currentChar() === EOF) {\n      emitError(6\n      /* UNTERMINATED_CLOSING_BRACE */\n      , currentPosition(), 0);\n    }\n\n    return value;\n  }\n\n  function readLiteral(scnr) {\n    skipSpaces(scnr);\n    eat(scnr, `\\'`);\n    let ch = '';\n    let literal = '';\n\n    const fn = x => x !== LITERAL_DELIMITER && x !== CHAR_LF;\n\n    while (ch = takeChar(scnr, fn)) {\n      if (ch === '\\\\') {\n        literal += readEscapeSequence(scnr);\n      } else {\n        literal += ch;\n      }\n    }\n\n    const current = scnr.currentChar();\n\n    if (current === CHAR_LF || current === EOF) {\n      emitError(2\n      /* UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER */\n      , currentPosition(), 0); // TODO: Is it correct really?\n\n      if (current === CHAR_LF) {\n        scnr.next();\n        eat(scnr, `\\'`);\n      }\n\n      return literal;\n    }\n\n    eat(scnr, `\\'`);\n    return literal;\n  }\n\n  function readEscapeSequence(scnr) {\n    const ch = scnr.currentChar();\n\n    switch (ch) {\n      case '\\\\':\n      case `\\'`:\n        scnr.next();\n        return `\\\\${ch}`;\n\n      case 'u':\n        return readUnicodeEscapeSequence(scnr, ch, 4);\n\n      case 'U':\n        return readUnicodeEscapeSequence(scnr, ch, 6);\n\n      default:\n        emitError(3\n        /* UNKNOWN_ESCAPE_SEQUENCE */\n        , currentPosition(), 0, ch);\n        return '';\n    }\n  }\n\n  function readUnicodeEscapeSequence(scnr, unicode, digits) {\n    eat(scnr, unicode);\n    let sequence = '';\n\n    for (let i = 0; i < digits; i++) {\n      const ch = takeHexDigit(scnr);\n\n      if (!ch) {\n        emitError(4\n        /* INVALID_UNICODE_ESCAPE_SEQUENCE */\n        , currentPosition(), 0, `\\\\${unicode}${sequence}${scnr.currentChar()}`);\n        break;\n      }\n\n      sequence += ch;\n    }\n\n    return `\\\\${unicode}${sequence}`;\n  }\n\n  function readInvalidIdentifier(scnr) {\n    skipSpaces(scnr);\n    let ch = '';\n    let identifiers = '';\n\n    const closure = ch => ch !== \"{\"\n    /* BraceLeft */\n    && ch !== \"}\"\n    /* BraceRight */\n    && ch !== CHAR_SP && ch !== CHAR_LF;\n\n    while (ch = takeChar(scnr, closure)) {\n      identifiers += ch;\n    }\n\n    return identifiers;\n  }\n\n  function readLinkedModifier(scnr) {\n    let ch = '';\n    let name = '';\n\n    while (ch = takeIdentifierChar(scnr)) {\n      name += ch;\n    }\n\n    return name;\n  }\n\n  function readLinkedRefer(scnr) {\n    const fn = (detect = false, buf) => {\n      const ch = scnr.currentChar();\n\n      if (ch === \"{\"\n      /* BraceLeft */\n      || ch === \"%\"\n      /* Modulo */\n      || ch === \"@\"\n      /* LinkedAlias */\n      || ch === \"|\"\n      /* Pipe */\n      || !ch) {\n        return buf;\n      } else if (ch === CHAR_SP) {\n        return buf;\n      } else if (ch === CHAR_LF) {\n        buf += ch;\n        scnr.next();\n        return fn(detect, buf);\n      } else {\n        buf += ch;\n        scnr.next();\n        return fn(true, buf);\n      }\n    };\n\n    return fn(false, '');\n  }\n\n  function readPlural(scnr) {\n    skipSpaces(scnr);\n    const plural = eat(scnr, \"|\"\n    /* Pipe */\n    );\n    skipSpaces(scnr);\n    return plural;\n  } // TODO: We need refactoring of token parsing ...\n\n\n  function readTokenInPlaceholder(scnr, context) {\n    let token = null;\n    const ch = scnr.currentChar();\n\n    switch (ch) {\n      case \"{\"\n      /* BraceLeft */\n      :\n        if (context.braceNest >= 1) {\n          emitError(8\n          /* NOT_ALLOW_NEST_PLACEHOLDER */\n          , currentPosition(), 0);\n        }\n\n        scnr.next();\n        token = getToken(context, 2\n        /* BraceLeft */\n        , \"{\"\n        /* BraceLeft */\n        );\n        skipSpaces(scnr);\n        context.braceNest++;\n        return token;\n\n      case \"}\"\n      /* BraceRight */\n      :\n        if (context.braceNest > 0 && context.currentType === 2\n        /* BraceLeft */\n        ) {\n          emitError(7\n          /* EMPTY_PLACEHOLDER */\n          , currentPosition(), 0);\n        }\n\n        scnr.next();\n        token = getToken(context, 3\n        /* BraceRight */\n        , \"}\"\n        /* BraceRight */\n        );\n        context.braceNest--;\n        context.braceNest > 0 && skipSpaces(scnr);\n\n        if (context.inLinked && context.braceNest === 0) {\n          context.inLinked = false;\n        }\n\n        return token;\n\n      case \"@\"\n      /* LinkedAlias */\n      :\n        if (context.braceNest > 0) {\n          emitError(6\n          /* UNTERMINATED_CLOSING_BRACE */\n          , currentPosition(), 0);\n        }\n\n        token = readTokenInLinked(scnr, context) || getEndToken(context);\n        context.braceNest = 0;\n        return token;\n\n      default:\n        let validNamedIdentifier = true;\n        let validListIdentifier = true;\n        let validLiteral = true;\n\n        if (isPluralStart(scnr)) {\n          if (context.braceNest > 0) {\n            emitError(6\n            /* UNTERMINATED_CLOSING_BRACE */\n            , currentPosition(), 0);\n          }\n\n          token = getToken(context, 1\n          /* Pipe */\n          , readPlural(scnr)); // reset\n\n          context.braceNest = 0;\n          context.inLinked = false;\n          return token;\n        }\n\n        if (context.braceNest > 0 && (context.currentType === 5\n        /* Named */\n        || context.currentType === 6\n        /* List */\n        || context.currentType === 7\n        /* Literal */\n        )) {\n          emitError(6\n          /* UNTERMINATED_CLOSING_BRACE */\n          , currentPosition(), 0);\n          context.braceNest = 0;\n          return readToken(scnr, context);\n        }\n\n        if (validNamedIdentifier = isNamedIdentifierStart(scnr, context)) {\n          token = getToken(context, 5\n          /* Named */\n          , readNamedIdentifier(scnr));\n          skipSpaces(scnr);\n          return token;\n        }\n\n        if (validListIdentifier = isListIdentifierStart(scnr, context)) {\n          token = getToken(context, 6\n          /* List */\n          , readListIdentifier(scnr));\n          skipSpaces(scnr);\n          return token;\n        }\n\n        if (validLiteral = isLiteralStart(scnr, context)) {\n          token = getToken(context, 7\n          /* Literal */\n          , readLiteral(scnr));\n          skipSpaces(scnr);\n          return token;\n        }\n\n        if (!validNamedIdentifier && !validListIdentifier && !validLiteral) {\n          // TODO: we should be re-designed invalid cases, when we will extend message syntax near the future ...\n          token = getToken(context, 13\n          /* InvalidPlace */\n          , readInvalidIdentifier(scnr));\n          emitError(1\n          /* INVALID_TOKEN_IN_PLACEHOLDER */\n          , currentPosition(), 0, token.value);\n          skipSpaces(scnr);\n          return token;\n        }\n\n        break;\n    }\n\n    return token;\n  } // TODO: We need refactoring of token parsing ...\n\n\n  function readTokenInLinked(scnr, context) {\n    const {\n      currentType\n    } = context;\n    let token = null;\n    const ch = scnr.currentChar();\n\n    if ((currentType === 8\n    /* LinkedAlias */\n    || currentType === 9\n    /* LinkedDot */\n    || currentType === 12\n    /* LinkedModifier */\n    || currentType === 10\n    /* LinkedDelimiter */\n    ) && (ch === CHAR_LF || ch === CHAR_SP)) {\n      emitError(9\n      /* INVALID_LINKED_FORMAT */\n      , currentPosition(), 0);\n    }\n\n    switch (ch) {\n      case \"@\"\n      /* LinkedAlias */\n      :\n        scnr.next();\n        token = getToken(context, 8\n        /* LinkedAlias */\n        , \"@\"\n        /* LinkedAlias */\n        );\n        context.inLinked = true;\n        return token;\n\n      case \".\"\n      /* LinkedDot */\n      :\n        skipSpaces(scnr);\n        scnr.next();\n        return getToken(context, 9\n        /* LinkedDot */\n        , \".\"\n        /* LinkedDot */\n        );\n\n      case \":\"\n      /* LinkedDelimiter */\n      :\n        skipSpaces(scnr);\n        scnr.next();\n        return getToken(context, 10\n        /* LinkedDelimiter */\n        , \":\"\n        /* LinkedDelimiter */\n        );\n\n      default:\n        if (isPluralStart(scnr)) {\n          token = getToken(context, 1\n          /* Pipe */\n          , readPlural(scnr)); // reset\n\n          context.braceNest = 0;\n          context.inLinked = false;\n          return token;\n        }\n\n        if (isLinkedDotStart(scnr, context) || isLinkedDelimiterStart(scnr, context)) {\n          skipSpaces(scnr);\n          return readTokenInLinked(scnr, context);\n        }\n\n        if (isLinkedModifierStart(scnr, context)) {\n          skipSpaces(scnr);\n          return getToken(context, 12\n          /* LinkedModifier */\n          , readLinkedModifier(scnr));\n        }\n\n        if (isLinkedReferStart(scnr, context)) {\n          skipSpaces(scnr);\n\n          if (ch === \"{\"\n          /* BraceLeft */\n          ) {\n            // scan the placeholder\n            return readTokenInPlaceholder(scnr, context) || token;\n          } else {\n            return getToken(context, 11\n            /* LinkedKey */\n            , readLinkedRefer(scnr));\n          }\n        }\n\n        if (currentType === 8\n        /* LinkedAlias */\n        ) {\n          emitError(9\n          /* INVALID_LINKED_FORMAT */\n          , currentPosition(), 0);\n        }\n\n        context.braceNest = 0;\n        context.inLinked = false;\n        return readToken(scnr, context);\n    }\n  } // TODO: We need refactoring of token parsing ...\n\n\n  function readToken(scnr, context) {\n    let token = {\n      type: 14\n      /* EOF */\n\n    };\n\n    if (context.braceNest > 0) {\n      return readTokenInPlaceholder(scnr, context) || getEndToken(context);\n    }\n\n    if (context.inLinked) {\n      return readTokenInLinked(scnr, context) || getEndToken(context);\n    }\n\n    const ch = scnr.currentChar();\n\n    switch (ch) {\n      case \"{\"\n      /* BraceLeft */\n      :\n        return readTokenInPlaceholder(scnr, context) || getEndToken(context);\n\n      case \"}\"\n      /* BraceRight */\n      :\n        emitError(5\n        /* UNBALANCED_CLOSING_BRACE */\n        , currentPosition(), 0);\n        scnr.next();\n        return getToken(context, 3\n        /* BraceRight */\n        , \"}\"\n        /* BraceRight */\n        );\n\n      case \"@\"\n      /* LinkedAlias */\n      :\n        return readTokenInLinked(scnr, context) || getEndToken(context);\n\n      default:\n        if (isPluralStart(scnr)) {\n          token = getToken(context, 1\n          /* Pipe */\n          , readPlural(scnr)); // reset\n\n          context.braceNest = 0;\n          context.inLinked = false;\n          return token;\n        }\n\n        if (isTextStart(scnr)) {\n          return getToken(context, 0\n          /* Text */\n          , readText(scnr));\n        }\n\n        if (ch === \"%\"\n        /* Modulo */\n        ) {\n          scnr.next();\n          return getToken(context, 4\n          /* Modulo */\n          , \"%\"\n          /* Modulo */\n          );\n        }\n\n        break;\n    }\n\n    return token;\n  }\n\n  function nextToken() {\n    const {\n      currentType,\n      offset,\n      startLoc,\n      endLoc\n    } = _context;\n    _context.lastType = currentType;\n    _context.lastOffset = offset;\n    _context.lastStartLoc = startLoc;\n    _context.lastEndLoc = endLoc;\n    _context.offset = currentOffset();\n    _context.startLoc = currentPosition();\n\n    if (_scnr.currentChar() === EOF) {\n      return getToken(_context, 14\n      /* EOF */\n      );\n    }\n\n    return readToken(_scnr, _context);\n  }\n\n  return {\n    nextToken,\n    currentOffset,\n    currentPosition,\n    context\n  };\n}\n\nconst ERROR_DOMAIN = 'parser'; // Backslash backslash, backslash quote, uHHHH, UHHHHHH.\n\nconst KNOWN_ESCAPES = /(?:\\\\\\\\|\\\\'|\\\\u([0-9a-fA-F]{4})|\\\\U([0-9a-fA-F]{6}))/g;\n\nfunction fromEscapeSequence(match, codePoint4, codePoint6) {\n  switch (match) {\n    case `\\\\\\\\`:\n      return `\\\\`;\n\n    case `\\\\\\'`:\n      return `\\'`;\n\n    default:\n      {\n        const codePoint = parseInt(codePoint4 || codePoint6, 16);\n\n        if (codePoint <= 0xd7ff || codePoint >= 0xe000) {\n          return String.fromCodePoint(codePoint);\n        } // invalid ...\n        // Replace them with U+FFFD REPLACEMENT CHARACTER.\n\n\n        return '�';\n      }\n  }\n}\n\nfunction createParser(options = {}) {\n  const location = options.location !== false;\n  const {\n    onError\n  } = options;\n\n  function emitError(tokenzer, code, start, offset, ...args) {\n    const end = tokenzer.currentPosition();\n    end.offset += offset;\n    end.column += offset;\n\n    if (onError) {\n      const loc = createLocation(start, end);\n      const err = createCompileError(code, loc, {\n        domain: ERROR_DOMAIN,\n        args\n      });\n      onError(err);\n    }\n  }\n\n  function startNode(type, offset, loc) {\n    const node = {\n      type,\n      start: offset,\n      end: offset\n    };\n\n    if (location) {\n      node.loc = {\n        start: loc,\n        end: loc\n      };\n    }\n\n    return node;\n  }\n\n  function endNode(node, offset, pos, type) {\n    node.end = offset;\n\n    if (type) {\n      node.type = type;\n    }\n\n    if (location && node.loc) {\n      node.loc.end = pos;\n    }\n  }\n\n  function parseText(tokenizer, value) {\n    const context = tokenizer.context();\n    const node = startNode(3\n    /* Text */\n    , context.offset, context.startLoc);\n    node.value = value;\n    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n    return node;\n  }\n\n  function parseList(tokenizer, index) {\n    const context = tokenizer.context();\n    const {\n      lastOffset: offset,\n      lastStartLoc: loc\n    } = context; // get brace left loc\n\n    const node = startNode(5\n    /* List */\n    , offset, loc);\n    node.index = parseInt(index, 10);\n    tokenizer.nextToken(); // skip brach right\n\n    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n    return node;\n  }\n\n  function parseNamed(tokenizer, key) {\n    const context = tokenizer.context();\n    const {\n      lastOffset: offset,\n      lastStartLoc: loc\n    } = context; // get brace left loc\n\n    const node = startNode(4\n    /* Named */\n    , offset, loc);\n    node.key = key;\n    tokenizer.nextToken(); // skip brach right\n\n    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n    return node;\n  }\n\n  function parseLiteral(tokenizer, value) {\n    const context = tokenizer.context();\n    const {\n      lastOffset: offset,\n      lastStartLoc: loc\n    } = context; // get brace left loc\n\n    const node = startNode(9\n    /* Literal */\n    , offset, loc);\n    node.value = value.replace(KNOWN_ESCAPES, fromEscapeSequence);\n    tokenizer.nextToken(); // skip brach right\n\n    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n    return node;\n  }\n\n  function parseLinkedModifier(tokenizer) {\n    const token = tokenizer.nextToken();\n    const context = tokenizer.context();\n    const {\n      lastOffset: offset,\n      lastStartLoc: loc\n    } = context; // get linked dot loc\n\n    const node = startNode(8\n    /* LinkedModifier */\n    , offset, loc);\n\n    if (token.type !== 12\n    /* LinkedModifier */\n    ) {\n      // empty modifier\n      emitError(tokenizer, 11\n      /* UNEXPECTED_EMPTY_LINKED_MODIFIER */\n      , context.lastStartLoc, 0);\n      node.value = '';\n      endNode(node, offset, loc);\n      return {\n        nextConsumeToken: token,\n        node\n      };\n    } // check token\n\n\n    if (token.value == null) {\n      emitError(tokenizer, 13\n      /* UNEXPECTED_LEXICAL_ANALYSIS */\n      , context.lastStartLoc, 0, getTokenCaption(token));\n    }\n\n    node.value = token.value || '';\n    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n    return {\n      node\n    };\n  }\n\n  function parseLinkedKey(tokenizer, value) {\n    const context = tokenizer.context();\n    const node = startNode(7\n    /* LinkedKey */\n    , context.offset, context.startLoc);\n    node.value = value;\n    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n    return node;\n  }\n\n  function parseLinked(tokenizer) {\n    const context = tokenizer.context();\n    const linkedNode = startNode(6\n    /* Linked */\n    , context.offset, context.startLoc);\n    let token = tokenizer.nextToken();\n\n    if (token.type === 9\n    /* LinkedDot */\n    ) {\n      const parsed = parseLinkedModifier(tokenizer);\n      linkedNode.modifier = parsed.node;\n      token = parsed.nextConsumeToken || tokenizer.nextToken();\n    } // asset check token\n\n\n    if (token.type !== 10\n    /* LinkedDelimiter */\n    ) {\n      emitError(tokenizer, 13\n      /* UNEXPECTED_LEXICAL_ANALYSIS */\n      , context.lastStartLoc, 0, getTokenCaption(token));\n    }\n\n    token = tokenizer.nextToken(); // skip brace left\n\n    if (token.type === 2\n    /* BraceLeft */\n    ) {\n      token = tokenizer.nextToken();\n    }\n\n    switch (token.type) {\n      case 11\n      /* LinkedKey */\n      :\n        if (token.value == null) {\n          emitError(tokenizer, 13\n          /* UNEXPECTED_LEXICAL_ANALYSIS */\n          , context.lastStartLoc, 0, getTokenCaption(token));\n        }\n\n        linkedNode.key = parseLinkedKey(tokenizer, token.value || '');\n        break;\n\n      case 5\n      /* Named */\n      :\n        if (token.value == null) {\n          emitError(tokenizer, 13\n          /* UNEXPECTED_LEXICAL_ANALYSIS */\n          , context.lastStartLoc, 0, getTokenCaption(token));\n        }\n\n        linkedNode.key = parseNamed(tokenizer, token.value || '');\n        break;\n\n      case 6\n      /* List */\n      :\n        if (token.value == null) {\n          emitError(tokenizer, 13\n          /* UNEXPECTED_LEXICAL_ANALYSIS */\n          , context.lastStartLoc, 0, getTokenCaption(token));\n        }\n\n        linkedNode.key = parseList(tokenizer, token.value || '');\n        break;\n\n      case 7\n      /* Literal */\n      :\n        if (token.value == null) {\n          emitError(tokenizer, 13\n          /* UNEXPECTED_LEXICAL_ANALYSIS */\n          , context.lastStartLoc, 0, getTokenCaption(token));\n        }\n\n        linkedNode.key = parseLiteral(tokenizer, token.value || '');\n        break;\n\n      default:\n        // empty key\n        emitError(tokenizer, 12\n        /* UNEXPECTED_EMPTY_LINKED_KEY */\n        , context.lastStartLoc, 0);\n        const nextContext = tokenizer.context();\n        const emptyLinkedKeyNode = startNode(7\n        /* LinkedKey */\n        , nextContext.offset, nextContext.startLoc);\n        emptyLinkedKeyNode.value = '';\n        endNode(emptyLinkedKeyNode, nextContext.offset, nextContext.startLoc);\n        linkedNode.key = emptyLinkedKeyNode;\n        endNode(linkedNode, nextContext.offset, nextContext.startLoc);\n        return {\n          nextConsumeToken: token,\n          node: linkedNode\n        };\n    }\n\n    endNode(linkedNode, tokenizer.currentOffset(), tokenizer.currentPosition());\n    return {\n      node: linkedNode\n    };\n  }\n\n  function parseMessage(tokenizer) {\n    const context = tokenizer.context();\n    const startOffset = context.currentType === 1\n    /* Pipe */\n    ? tokenizer.currentOffset() : context.offset;\n    const startLoc = context.currentType === 1\n    /* Pipe */\n    ? context.endLoc : context.startLoc;\n    const node = startNode(2\n    /* Message */\n    , startOffset, startLoc);\n    node.items = [];\n    let nextToken = null;\n\n    do {\n      const token = nextToken || tokenizer.nextToken();\n      nextToken = null;\n\n      switch (token.type) {\n        case 0\n        /* Text */\n        :\n          if (token.value == null) {\n            emitError(tokenizer, 13\n            /* UNEXPECTED_LEXICAL_ANALYSIS */\n            , context.lastStartLoc, 0, getTokenCaption(token));\n          }\n\n          node.items.push(parseText(tokenizer, token.value || ''));\n          break;\n\n        case 6\n        /* List */\n        :\n          if (token.value == null) {\n            emitError(tokenizer, 13\n            /* UNEXPECTED_LEXICAL_ANALYSIS */\n            , context.lastStartLoc, 0, getTokenCaption(token));\n          }\n\n          node.items.push(parseList(tokenizer, token.value || ''));\n          break;\n\n        case 5\n        /* Named */\n        :\n          if (token.value == null) {\n            emitError(tokenizer, 13\n            /* UNEXPECTED_LEXICAL_ANALYSIS */\n            , context.lastStartLoc, 0, getTokenCaption(token));\n          }\n\n          node.items.push(parseNamed(tokenizer, token.value || ''));\n          break;\n\n        case 7\n        /* Literal */\n        :\n          if (token.value == null) {\n            emitError(tokenizer, 13\n            /* UNEXPECTED_LEXICAL_ANALYSIS */\n            , context.lastStartLoc, 0, getTokenCaption(token));\n          }\n\n          node.items.push(parseLiteral(tokenizer, token.value || ''));\n          break;\n\n        case 8\n        /* LinkedAlias */\n        :\n          const parsed = parseLinked(tokenizer);\n          node.items.push(parsed.node);\n          nextToken = parsed.nextConsumeToken || null;\n          break;\n      }\n    } while (context.currentType !== 14\n    /* EOF */\n    && context.currentType !== 1\n    /* Pipe */\n    ); // adjust message node loc\n\n\n    const endOffset = context.currentType === 1\n    /* Pipe */\n    ? context.lastOffset : tokenizer.currentOffset();\n    const endLoc = context.currentType === 1\n    /* Pipe */\n    ? context.lastEndLoc : tokenizer.currentPosition();\n    endNode(node, endOffset, endLoc);\n    return node;\n  }\n\n  function parsePlural(tokenizer, offset, loc, msgNode) {\n    const context = tokenizer.context();\n    let hasEmptyMessage = msgNode.items.length === 0;\n    const node = startNode(1\n    /* Plural */\n    , offset, loc);\n    node.cases = [];\n    node.cases.push(msgNode);\n\n    do {\n      const msg = parseMessage(tokenizer);\n\n      if (!hasEmptyMessage) {\n        hasEmptyMessage = msg.items.length === 0;\n      }\n\n      node.cases.push(msg);\n    } while (context.currentType !== 14\n    /* EOF */\n    );\n\n    if (hasEmptyMessage) {\n      emitError(tokenizer, 10\n      /* MUST_HAVE_MESSAGES_IN_PLURAL */\n      , loc, 0);\n    }\n\n    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n    return node;\n  }\n\n  function parseResource(tokenizer) {\n    const context = tokenizer.context();\n    const {\n      offset,\n      startLoc\n    } = context;\n    const msgNode = parseMessage(tokenizer);\n\n    if (context.currentType === 14\n    /* EOF */\n    ) {\n      return msgNode;\n    } else {\n      return parsePlural(tokenizer, offset, startLoc, msgNode);\n    }\n  }\n\n  function parse(source) {\n    const tokenizer = createTokenizer(source, assign({}, options));\n    const context = tokenizer.context();\n    const node = startNode(0\n    /* Resource */\n    , context.offset, context.startLoc);\n\n    if (location && node.loc) {\n      node.loc.source = source;\n    }\n\n    node.body = parseResource(tokenizer); // assert whether achieved to EOF\n\n    if (context.currentType !== 14\n    /* EOF */\n    ) {\n      emitError(tokenizer, 13\n      /* UNEXPECTED_LEXICAL_ANALYSIS */\n      , context.lastStartLoc, 0, source[context.offset] || '');\n    }\n\n    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n    return node;\n  }\n\n  return {\n    parse\n  };\n}\n\nfunction getTokenCaption(token) {\n  if (token.type === 14\n  /* EOF */\n  ) {\n    return 'EOF';\n  }\n\n  const name = (token.value || '').replace(/\\r?\\n/gu, '\\\\n');\n  return name.length > 10 ? name.slice(0, 9) + '…' : name;\n}\n\nfunction createTransformer(ast, options = {} // eslint-disable-line\n) {\n  const _context = {\n    ast,\n    helpers: new Set()\n  };\n\n  const context = () => _context;\n\n  const helper = name => {\n    _context.helpers.add(name);\n\n    return name;\n  };\n\n  return {\n    context,\n    helper\n  };\n}\n\nfunction traverseNodes(nodes, transformer) {\n  for (let i = 0; i < nodes.length; i++) {\n    traverseNode(nodes[i], transformer);\n  }\n}\n\nfunction traverseNode(node, transformer) {\n  // TODO: if we need pre-hook of transform, should be implemented to here\n  switch (node.type) {\n    case 1\n    /* Plural */\n    :\n      traverseNodes(node.cases, transformer);\n      transformer.helper(\"plural\"\n      /* PLURAL */\n      );\n      break;\n\n    case 2\n    /* Message */\n    :\n      traverseNodes(node.items, transformer);\n      break;\n\n    case 6\n    /* Linked */\n    :\n      const linked = node;\n      traverseNode(linked.key, transformer);\n      transformer.helper(\"linked\"\n      /* LINKED */\n      );\n      break;\n\n    case 5\n    /* List */\n    :\n      transformer.helper(\"interpolate\"\n      /* INTERPOLATE */\n      );\n      transformer.helper(\"list\"\n      /* LIST */\n      );\n      break;\n\n    case 4\n    /* Named */\n    :\n      transformer.helper(\"interpolate\"\n      /* INTERPOLATE */\n      );\n      transformer.helper(\"named\"\n      /* NAMED */\n      );\n      break;\n  } // TODO: if we need post-hook of transform, should be implemented to here\n\n} // transform AST\n\n\nfunction transform(ast, options = {} // eslint-disable-line\n) {\n  const transformer = createTransformer(ast);\n  transformer.helper(\"normalize\"\n  /* NORMALIZE */\n  ); // traverse\n\n  ast.body && traverseNode(ast.body, transformer); // set meta information\n\n  const context = transformer.context();\n  ast.helpers = Array.from(context.helpers);\n}\n\nfunction createCodeGenerator(ast, options) {\n  const {\n    sourceMap,\n    filename,\n    breakLineCode,\n    needIndent: _needIndent\n  } = options;\n  const _context = {\n    source: ast.loc.source,\n    filename,\n    code: '',\n    column: 1,\n    line: 1,\n    offset: 0,\n    map: undefined,\n    breakLineCode,\n    needIndent: _needIndent,\n    indentLevel: 0\n  };\n\n  const context = () => _context;\n\n  function push(code, node) {\n    _context.code += code;\n  }\n\n  function _newline(n, withBreakLine = true) {\n    const _breakLineCode = withBreakLine ? breakLineCode : '';\n\n    push(_needIndent ? _breakLineCode + `  `.repeat(n) : _breakLineCode);\n  }\n\n  function indent(withNewLine = true) {\n    const level = ++_context.indentLevel;\n    withNewLine && _newline(level);\n  }\n\n  function deindent(withNewLine = true) {\n    const level = --_context.indentLevel;\n    withNewLine && _newline(level);\n  }\n\n  function newline() {\n    _newline(_context.indentLevel);\n  }\n\n  const helper = key => `_${key}`;\n\n  const needIndent = () => _context.needIndent;\n\n  return {\n    context,\n    push,\n    indent,\n    deindent,\n    newline,\n    helper,\n    needIndent\n  };\n}\n\nfunction generateLinkedNode(generator, node) {\n  const {\n    helper\n  } = generator;\n  generator.push(`${helper(\"linked\"\n  /* LINKED */\n  )}(`);\n  generateNode(generator, node.key);\n\n  if (node.modifier) {\n    generator.push(`, `);\n    generateNode(generator, node.modifier);\n  }\n\n  generator.push(`)`);\n}\n\nfunction generateMessageNode(generator, node) {\n  const {\n    helper,\n    needIndent\n  } = generator;\n  generator.push(`${helper(\"normalize\"\n  /* NORMALIZE */\n  )}([`);\n  generator.indent(needIndent());\n  const length = node.items.length;\n\n  for (let i = 0; i < length; i++) {\n    generateNode(generator, node.items[i]);\n\n    if (i === length - 1) {\n      break;\n    }\n\n    generator.push(', ');\n  }\n\n  generator.deindent(needIndent());\n  generator.push('])');\n}\n\nfunction generatePluralNode(generator, node) {\n  const {\n    helper,\n    needIndent\n  } = generator;\n\n  if (node.cases.length > 1) {\n    generator.push(`${helper(\"plural\"\n    /* PLURAL */\n    )}([`);\n    generator.indent(needIndent());\n    const length = node.cases.length;\n\n    for (let i = 0; i < length; i++) {\n      generateNode(generator, node.cases[i]);\n\n      if (i === length - 1) {\n        break;\n      }\n\n      generator.push(', ');\n    }\n\n    generator.deindent(needIndent());\n    generator.push(`])`);\n  }\n}\n\nfunction generateResource(generator, node) {\n  if (node.body) {\n    generateNode(generator, node.body);\n  } else {\n    generator.push('null');\n  }\n}\n\nfunction generateNode(generator, node) {\n  const {\n    helper\n  } = generator;\n\n  switch (node.type) {\n    case 0\n    /* Resource */\n    :\n      generateResource(generator, node);\n      break;\n\n    case 1\n    /* Plural */\n    :\n      generatePluralNode(generator, node);\n      break;\n\n    case 2\n    /* Message */\n    :\n      generateMessageNode(generator, node);\n      break;\n\n    case 6\n    /* Linked */\n    :\n      generateLinkedNode(generator, node);\n      break;\n\n    case 8\n    /* LinkedModifier */\n    :\n      generator.push(JSON.stringify(node.value), node);\n      break;\n\n    case 7\n    /* LinkedKey */\n    :\n      generator.push(JSON.stringify(node.value), node);\n      break;\n\n    case 5\n    /* List */\n    :\n      generator.push(`${helper(\"interpolate\"\n      /* INTERPOLATE */\n      )}(${helper(\"list\"\n      /* LIST */\n      )}(${node.index}))`, node);\n      break;\n\n    case 4\n    /* Named */\n    :\n      generator.push(`${helper(\"interpolate\"\n      /* INTERPOLATE */\n      )}(${helper(\"named\"\n      /* NAMED */\n      )}(${JSON.stringify(node.key)}))`, node);\n      break;\n\n    case 9\n    /* Literal */\n    :\n      generator.push(JSON.stringify(node.value), node);\n      break;\n\n    case 3\n    /* Text */\n    :\n      generator.push(JSON.stringify(node.value), node);\n      break;\n\n    default:\n      if (process.env.NODE_ENV !== 'production') {\n        throw new Error(`unhandled codegen node type: ${node.type}`);\n      }\n\n  }\n} // generate code from AST\n\n\nconst generate = (ast, options = {} // eslint-disable-line\n) => {\n  const mode = isString(options.mode) ? options.mode : 'normal';\n  const filename = isString(options.filename) ? options.filename : 'message.intl';\n  const sourceMap = !!options.sourceMap; // prettier-ignore\n\n  const breakLineCode = options.breakLineCode != null ? options.breakLineCode : mode === 'arrow' ? ';' : '\\n';\n  const needIndent = options.needIndent ? options.needIndent : mode !== 'arrow';\n  const helpers = ast.helpers || [];\n  const generator = createCodeGenerator(ast, {\n    mode,\n    filename,\n    sourceMap,\n    breakLineCode,\n    needIndent\n  });\n  generator.push(mode === 'normal' ? `function __msg__ (ctx) {` : `(ctx) => {`);\n  generator.indent(needIndent);\n\n  if (helpers.length > 0) {\n    generator.push(`const { ${helpers.map(s => `${s}: _${s}`).join(', ')} } = ctx`);\n    generator.newline();\n  }\n\n  generator.push(`return `);\n  generateNode(generator, ast);\n  generator.deindent(needIndent);\n  generator.push(`}`);\n  const {\n    code,\n    map\n  } = generator.context();\n  return {\n    ast,\n    code,\n    map: map ? map.toJSON() : undefined // eslint-disable-line @typescript-eslint/no-explicit-any\n\n  };\n};\n\nfunction baseCompile(source, options = {}) {\n  const assignedOptions = assign({}, options); // parse source codes\n\n  const parser = createParser(assignedOptions);\n  const ast = parser.parse(source); // transform ASTs\n\n  transform(ast, assignedOptions); // generate javascript codes\n\n  return generate(ast, assignedOptions);\n}\n\nexport { ERROR_DOMAIN, LocationStub, baseCompile, createCompileError, createLocation, createParser, createPosition, defaultOnError, errorMessages };","map":null,"metadata":{},"sourceType":"module"}