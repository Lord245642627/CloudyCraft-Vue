{"ast":null,"code":"'use strict';\n\nmodule.exports = function ins_plugin(md) {\n  // Insert each marker as a separate text token, and add it to delimiter list\n  //\n  function tokenize(state, silent) {\n    var i,\n        scanned,\n        token,\n        len,\n        ch,\n        start = state.pos,\n        marker = state.src.charCodeAt(start);\n\n    if (silent) {\n      return false;\n    }\n\n    if (marker !== 0x3D\n    /* = */\n    ) {\n      return false;\n    }\n\n    scanned = state.scanDelims(state.pos, true);\n    len = scanned.length;\n    ch = String.fromCharCode(marker);\n\n    if (len < 2) {\n      return false;\n    }\n\n    if (len % 2) {\n      token = state.push('text', '', 0);\n      token.content = ch;\n      len--;\n    }\n\n    for (i = 0; i < len; i += 2) {\n      token = state.push('text', '', 0);\n      token.content = ch + ch;\n\n      if (!scanned.can_open && !scanned.can_close) {\n        continue;\n      }\n\n      state.delimiters.push({\n        marker: marker,\n        length: 0,\n        // disable \"rule of 3\" length checks meant for emphasis\n        jump: i / 2,\n        // 1 delimiter = 2 characters\n        token: state.tokens.length - 1,\n        end: -1,\n        open: scanned.can_open,\n        close: scanned.can_close\n      });\n    }\n\n    state.pos += scanned.length;\n    return true;\n  } // Walk through delimiter list and replace text tokens with tags\n  //\n\n\n  function postProcess(state, delimiters) {\n    var i,\n        j,\n        startDelim,\n        endDelim,\n        token,\n        loneMarkers = [],\n        max = delimiters.length;\n\n    for (i = 0; i < max; i++) {\n      startDelim = delimiters[i];\n\n      if (startDelim.marker !== 0x3D\n      /* = */\n      ) {\n        continue;\n      }\n\n      if (startDelim.end === -1) {\n        continue;\n      }\n\n      endDelim = delimiters[startDelim.end];\n      token = state.tokens[startDelim.token];\n      token.type = 'mark_open';\n      token.tag = 'mark';\n      token.nesting = 1;\n      token.markup = '==';\n      token.content = '';\n      token = state.tokens[endDelim.token];\n      token.type = 'mark_close';\n      token.tag = 'mark';\n      token.nesting = -1;\n      token.markup = '==';\n      token.content = '';\n\n      if (state.tokens[endDelim.token - 1].type === 'text' && state.tokens[endDelim.token - 1].content === '=') {\n        loneMarkers.push(endDelim.token - 1);\n      }\n    } // If a marker sequence has an odd number of characters, it's splitted\n    // like this: `~~~~~` -> `~` + `~~` + `~~`, leaving one marker at the\n    // start of the sequence.\n    //\n    // So, we have to move all those markers after subsequent s_close tags.\n    //\n\n\n    while (loneMarkers.length) {\n      i = loneMarkers.pop();\n      j = i + 1;\n\n      while (j < state.tokens.length && state.tokens[j].type === 'mark_close') {\n        j++;\n      }\n\n      j--;\n\n      if (i !== j) {\n        token = state.tokens[j];\n        state.tokens[j] = state.tokens[i];\n        state.tokens[i] = token;\n      }\n    }\n  }\n\n  md.inline.ruler.before('emphasis', 'mark', tokenize);\n  md.inline.ruler2.before('emphasis', 'mark', function (state) {\n    var curr,\n        tokens_meta = state.tokens_meta,\n        max = (state.tokens_meta || []).length;\n    postProcess(state, state.delimiters);\n\n    for (curr = 0; curr < max; curr++) {\n      if (tokens_meta[curr] && tokens_meta[curr].delimiters) {\n        postProcess(state, tokens_meta[curr].delimiters);\n      }\n    }\n  });\n};","map":{"version":3,"names":["module","exports","ins_plugin","md","tokenize","state","silent","i","scanned","token","len","ch","start","pos","marker","src","charCodeAt","scanDelims","length","String","fromCharCode","push","content","can_open","can_close","delimiters","jump","tokens","end","open","close","postProcess","j","startDelim","endDelim","loneMarkers","max","type","tag","nesting","markup","pop","inline","ruler","before","ruler2","curr","tokens_meta"],"sources":["/Users/lord/Documents/Programmer/vue/VueProjects/cloudycraft-vue/blog-web/node_modules/markdown-it-mark/index.js"],"sourcesContent":["'use strict';\n\n\nmodule.exports = function ins_plugin(md) {\n  // Insert each marker as a separate text token, and add it to delimiter list\n  //\n  function tokenize(state, silent) {\n    var i, scanned, token, len, ch,\n        start = state.pos,\n        marker = state.src.charCodeAt(start);\n\n    if (silent) { return false; }\n\n    if (marker !== 0x3D/* = */) { return false; }\n\n    scanned = state.scanDelims(state.pos, true);\n    len = scanned.length;\n    ch = String.fromCharCode(marker);\n\n    if (len < 2) { return false; }\n\n    if (len % 2) {\n      token         = state.push('text', '', 0);\n      token.content = ch;\n      len--;\n    }\n\n    for (i = 0; i < len; i += 2) {\n      token         = state.push('text', '', 0);\n      token.content = ch + ch;\n\n      if (!scanned.can_open && !scanned.can_close) { continue; }\n\n      state.delimiters.push({\n        marker: marker,\n        length: 0,     // disable \"rule of 3\" length checks meant for emphasis\n        jump:   i / 2, // 1 delimiter = 2 characters\n        token:  state.tokens.length - 1,\n        end:    -1,\n        open:   scanned.can_open,\n        close:  scanned.can_close\n      });\n    }\n\n    state.pos += scanned.length;\n\n    return true;\n  }\n\n\n  // Walk through delimiter list and replace text tokens with tags\n  //\n  function postProcess(state, delimiters) {\n    var i, j,\n        startDelim,\n        endDelim,\n        token,\n        loneMarkers = [],\n        max = delimiters.length;\n\n    for (i = 0; i < max; i++) {\n      startDelim = delimiters[i];\n\n      if (startDelim.marker !== 0x3D/* = */) {\n        continue;\n      }\n\n      if (startDelim.end === -1) {\n        continue;\n      }\n\n      endDelim = delimiters[startDelim.end];\n\n      token         = state.tokens[startDelim.token];\n      token.type    = 'mark_open';\n      token.tag     = 'mark';\n      token.nesting = 1;\n      token.markup  = '==';\n      token.content = '';\n\n      token         = state.tokens[endDelim.token];\n      token.type    = 'mark_close';\n      token.tag     = 'mark';\n      token.nesting = -1;\n      token.markup  = '==';\n      token.content = '';\n\n      if (state.tokens[endDelim.token - 1].type === 'text' &&\n          state.tokens[endDelim.token - 1].content === '=') {\n\n        loneMarkers.push(endDelim.token - 1);\n      }\n    }\n\n    // If a marker sequence has an odd number of characters, it's splitted\n    // like this: `~~~~~` -> `~` + `~~` + `~~`, leaving one marker at the\n    // start of the sequence.\n    //\n    // So, we have to move all those markers after subsequent s_close tags.\n    //\n    while (loneMarkers.length) {\n      i = loneMarkers.pop();\n      j = i + 1;\n\n      while (j < state.tokens.length && state.tokens[j].type === 'mark_close') {\n        j++;\n      }\n\n      j--;\n\n      if (i !== j) {\n        token = state.tokens[j];\n        state.tokens[j] = state.tokens[i];\n        state.tokens[i] = token;\n      }\n    }\n  }\n\n  md.inline.ruler.before('emphasis', 'mark', tokenize);\n  md.inline.ruler2.before('emphasis', 'mark', function (state) {\n    var curr,\n        tokens_meta = state.tokens_meta,\n        max = (state.tokens_meta || []).length;\n\n    postProcess(state, state.delimiters);\n\n    for (curr = 0; curr < max; curr++) {\n      if (tokens_meta[curr] && tokens_meta[curr].delimiters) {\n        postProcess(state, tokens_meta[curr].delimiters);\n      }\n    }\n  });\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}