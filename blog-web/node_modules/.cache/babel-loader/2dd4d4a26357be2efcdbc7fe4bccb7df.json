{"ast":null,"code":"import { inject, computed, ref, getCurrentInstance, nextTick, watch } from 'vue';\nimport { toTypeString, isString, isArray } from '@vue/shared';\nimport '../../../constants/index.mjs';\nimport '../../../tokens/index.mjs';\nimport '../../../hooks/index.mjs';\nimport '../../../utils/index.mjs';\nimport { useSizeProp, useSize } from '../../../hooks/use-common-props/index.mjs';\nimport { formContextKey, formItemContextKey } from '../../../tokens/form.mjs';\nimport { useFormItemInputId } from '../../../hooks/use-form-item/index.mjs';\nimport { UPDATE_MODEL_EVENT } from '../../../constants/event.mjs';\nimport { debugWarn } from '../../../utils/error.mjs';\nimport { isNumber, isBoolean } from '@vueuse/core';\nconst useCheckboxGroupProps = {\n  modelValue: {\n    type: Array,\n    default: () => []\n  },\n  disabled: Boolean,\n  min: {\n    type: Number,\n    default: void 0\n  },\n  max: {\n    type: Number,\n    default: void 0\n  },\n  size: useSizeProp,\n  id: {\n    type: String,\n    default: void 0\n  },\n  label: {\n    type: String,\n    default: void 0\n  },\n  fill: {\n    type: String,\n    default: void 0\n  },\n  textColor: {\n    type: String,\n    default: void 0\n  },\n  tag: {\n    type: String,\n    default: \"div\"\n  },\n  validateEvent: {\n    type: Boolean,\n    default: true\n  }\n};\nconst checkboxProps = {\n  modelValue: {\n    type: [Number, String, Boolean],\n    default: () => void 0\n  },\n  label: {\n    type: [String, Boolean, Number, Object]\n  },\n  indeterminate: Boolean,\n  disabled: Boolean,\n  checked: Boolean,\n  name: {\n    type: String,\n    default: void 0\n  },\n  trueLabel: {\n    type: [String, Number],\n    default: void 0\n  },\n  falseLabel: {\n    type: [String, Number],\n    default: void 0\n  },\n  id: {\n    type: String,\n    default: void 0\n  },\n  controls: {\n    type: String,\n    default: void 0\n  },\n  border: Boolean,\n  size: useSizeProp,\n  tabindex: [String, Number],\n  validateEvent: {\n    type: Boolean,\n    default: true\n  }\n};\n\nconst useCheckboxGroup = () => {\n  const elForm = inject(formContextKey, {});\n  const elFormItem = inject(formItemContextKey, {});\n  const checkboxGroup = inject(\"CheckboxGroup\", {});\n  const isGroup = computed(() => checkboxGroup && (checkboxGroup == null ? void 0 : checkboxGroup.name) === \"ElCheckboxGroup\");\n  const elFormItemSize = computed(() => {\n    return elFormItem.size;\n  });\n  return {\n    isGroup,\n    checkboxGroup,\n    elForm,\n    elFormItemSize,\n    elFormItem\n  };\n};\n\nconst useCheckboxGroupId = (props, {\n  elFormItem\n}) => {\n  const {\n    inputId: groupId,\n    isLabeledByFormItem\n  } = useFormItemInputId(props, {\n    formItemContext: elFormItem\n  });\n  return {\n    isLabeledByFormItem,\n    groupId\n  };\n};\n\nconst useModel = props => {\n  const selfModel = ref(false);\n  const {\n    emit\n  } = getCurrentInstance();\n  const {\n    isGroup,\n    checkboxGroup,\n    elFormItem\n  } = useCheckboxGroup();\n  const isLimitExceeded = ref(false);\n  const model = computed({\n    get() {\n      var _a, _b;\n\n      return isGroup.value ? (_a = checkboxGroup.modelValue) == null ? void 0 : _a.value : (_b = props.modelValue) != null ? _b : selfModel.value;\n    },\n\n    set(val) {\n      var _a;\n\n      if (isGroup.value && Array.isArray(val)) {\n        isLimitExceeded.value = checkboxGroup.max !== void 0 && val.length > checkboxGroup.max.value;\n        isLimitExceeded.value === false && ((_a = checkboxGroup == null ? void 0 : checkboxGroup.changeEvent) == null ? void 0 : _a.call(checkboxGroup, val));\n      } else {\n        emit(UPDATE_MODEL_EVENT, val);\n        selfModel.value = val;\n      }\n    }\n\n  });\n  return {\n    model,\n    isGroup,\n    isLimitExceeded,\n    elFormItem\n  };\n};\n\nconst useCheckboxStatus = (props, slots, {\n  model\n}) => {\n  const {\n    isGroup,\n    checkboxGroup\n  } = useCheckboxGroup();\n  const focus = ref(false);\n  const size = useSize(checkboxGroup == null ? void 0 : checkboxGroup.checkboxGroupSize, {\n    prop: true\n  });\n  const isChecked = computed(() => {\n    const value = model.value;\n\n    if (toTypeString(value) === \"[object Boolean]\") {\n      return value;\n    } else if (Array.isArray(value)) {\n      return value.includes(props.label);\n    } else if (value !== null && value !== void 0) {\n      return value === props.trueLabel;\n    } else {\n      return !!value;\n    }\n  });\n  const checkboxSize = useSize(computed(() => {\n    var _a;\n\n    return isGroup.value ? (_a = checkboxGroup == null ? void 0 : checkboxGroup.checkboxGroupSize) == null ? void 0 : _a.value : void 0;\n  }));\n  const hasOwnLabel = computed(() => {\n    return !!(slots.default || props.label);\n  });\n  return {\n    isChecked,\n    focus,\n    size,\n    checkboxSize,\n    hasOwnLabel\n  };\n};\n\nconst useDisabled = (props, {\n  model,\n  isChecked\n}) => {\n  const {\n    elForm,\n    isGroup,\n    checkboxGroup\n  } = useCheckboxGroup();\n  const isLimitDisabled = computed(() => {\n    var _a, _b;\n\n    const max = (_a = checkboxGroup.max) == null ? void 0 : _a.value;\n    const min = (_b = checkboxGroup.min) == null ? void 0 : _b.value;\n    return !!(max || min) && model.value.length >= max && !isChecked.value || model.value.length <= min && isChecked.value;\n  });\n  const isDisabled = computed(() => {\n    var _a, _b;\n\n    const disabled = props.disabled || (elForm == null ? void 0 : elForm.disabled);\n    return (_b = isGroup.value ? ((_a = checkboxGroup.disabled) == null ? void 0 : _a.value) || disabled || isLimitDisabled.value : disabled) != null ? _b : false;\n  });\n  return {\n    isDisabled,\n    isLimitDisabled\n  };\n};\n\nconst setStoreValue = (props, {\n  model\n}) => {\n  function addToStore() {\n    if (Array.isArray(model.value) && !model.value.includes(props.label)) {\n      model.value.push(props.label);\n    } else {\n      model.value = props.trueLabel || true;\n    }\n  }\n\n  props.checked && addToStore();\n};\n\nconst useEvent = (props, {\n  model,\n  isLimitExceeded,\n  hasOwnLabel,\n  isDisabled,\n  isLabeledByFormItem\n}) => {\n  const {\n    elFormItem,\n    checkboxGroup\n  } = useCheckboxGroup();\n  const {\n    emit\n  } = getCurrentInstance();\n\n  function getLabeledValue(value) {\n    var _a, _b;\n\n    return value === props.trueLabel || value === true ? (_a = props.trueLabel) != null ? _a : true : (_b = props.falseLabel) != null ? _b : false;\n  }\n\n  function emitChangeEvent(checked, e) {\n    emit(\"change\", getLabeledValue(checked), e);\n  }\n\n  function handleChange(e) {\n    if (isLimitExceeded.value) return;\n    const target = e.target;\n    emit(\"change\", getLabeledValue(target.checked), e);\n  }\n\n  async function onClickRoot(e) {\n    if (isLimitExceeded.value) return;\n\n    if (!hasOwnLabel.value && !isDisabled.value && isLabeledByFormItem.value) {\n      model.value = getLabeledValue([false, props.falseLabel].includes(model.value));\n      await nextTick();\n      emitChangeEvent(model.value, e);\n    }\n  }\n\n  const validateEvent = computed(() => {\n    var _a;\n\n    return ((_a = checkboxGroup.validateEvent) == null ? void 0 : _a.value) || props.validateEvent;\n  });\n  watch(() => props.modelValue, () => {\n    var _a;\n\n    if (validateEvent.value) {\n      (_a = elFormItem == null ? void 0 : elFormItem.validate) == null ? void 0 : _a.call(elFormItem, \"change\").catch(err => debugWarn(err));\n    }\n  });\n  return {\n    handleChange,\n    onClickRoot\n  };\n};\n\nconst checkboxEmits = {\n  [UPDATE_MODEL_EVENT]: val => isString(val) || isNumber(val) || isBoolean(val),\n  change: val => isString(val) || isNumber(val) || isBoolean(val)\n};\nconst checkboxGroupEmits = {\n  [UPDATE_MODEL_EVENT]: val => isArray(val),\n  change: val => isArray(val)\n};\n\nconst useCheckbox = (props, slots) => {\n  const {\n    model,\n    isGroup,\n    isLimitExceeded,\n    elFormItem\n  } = useModel(props);\n  const {\n    focus,\n    size,\n    isChecked,\n    checkboxSize,\n    hasOwnLabel\n  } = useCheckboxStatus(props, slots, {\n    model\n  });\n  const {\n    isDisabled\n  } = useDisabled(props, {\n    model,\n    isChecked\n  });\n  const {\n    inputId,\n    isLabeledByFormItem\n  } = useFormItemInputId(props, {\n    formItemContext: elFormItem,\n    disableIdGeneration: hasOwnLabel,\n    disableIdManagement: isGroup\n  });\n  const {\n    handleChange,\n    onClickRoot\n  } = useEvent(props, {\n    model,\n    isLimitExceeded,\n    hasOwnLabel,\n    isDisabled,\n    isLabeledByFormItem\n  });\n  setStoreValue(props, {\n    model\n  });\n  return {\n    elFormItem,\n    inputId,\n    isLabeledByFormItem,\n    isChecked,\n    isDisabled,\n    isGroup,\n    checkboxSize,\n    hasOwnLabel,\n    model,\n    handleChange,\n    onClickRoot,\n    focus,\n    size\n  };\n};\n\nexport { checkboxEmits, checkboxGroupEmits, checkboxProps, useCheckbox, useCheckboxGroup, useCheckboxGroupId, useCheckboxGroupProps };","map":null,"metadata":{},"sourceType":"module"}