{"ast":null,"code":"// Process block-level custom containers\n//\n'use strict';\n\nmodule.exports = function container_plugin(md, name, options) {\n  // Second param may be useful if you decide\n  // to increase minimal allowed marker length\n  function validateDefault(params\n  /*, markup*/\n  ) {\n    return params.trim().split(' ', 2)[0] === name;\n  }\n\n  function renderDefault(tokens, idx, _options, env, slf) {\n    // add a class to the opening tag\n    if (tokens[idx].nesting === 1) {\n      tokens[idx].attrJoin('class', name);\n    }\n\n    return slf.renderToken(tokens, idx, _options, env, slf);\n  }\n\n  options = options || {};\n  var min_markers = 3,\n      marker_str = options.marker || ':',\n      marker_char = marker_str.charCodeAt(0),\n      marker_len = marker_str.length,\n      validate = options.validate || validateDefault,\n      render = options.render || renderDefault;\n\n  function container(state, startLine, endLine, silent) {\n    var pos,\n        nextLine,\n        marker_count,\n        markup,\n        params,\n        token,\n        old_parent,\n        old_line_max,\n        auto_closed = false,\n        start = state.bMarks[startLine] + state.tShift[startLine],\n        max = state.eMarks[startLine]; // Check out the first character quickly,\n    // this should filter out most of non-containers\n    //\n\n    if (marker_char !== state.src.charCodeAt(start)) {\n      return false;\n    } // Check out the rest of the marker string\n    //\n\n\n    for (pos = start + 1; pos <= max; pos++) {\n      if (marker_str[(pos - start) % marker_len] !== state.src[pos]) {\n        break;\n      }\n    }\n\n    marker_count = Math.floor((pos - start) / marker_len);\n\n    if (marker_count < min_markers) {\n      return false;\n    }\n\n    pos -= (pos - start) % marker_len;\n    markup = state.src.slice(start, pos);\n    params = state.src.slice(pos, max);\n\n    if (!validate(params, markup)) {\n      return false;\n    } // Since start is found, we can report success here in validation mode\n    //\n\n\n    if (silent) {\n      return true;\n    } // Search for the end of the block\n    //\n\n\n    nextLine = startLine;\n\n    for (;;) {\n      nextLine++;\n\n      if (nextLine >= endLine) {\n        // unclosed block should be autoclosed by end of document.\n        // also block seems to be autoclosed by end of parent\n        break;\n      }\n\n      start = state.bMarks[nextLine] + state.tShift[nextLine];\n      max = state.eMarks[nextLine];\n\n      if (start < max && state.sCount[nextLine] < state.blkIndent) {\n        // non-empty line with negative indent should stop the list:\n        // - ```\n        //  test\n        break;\n      }\n\n      if (marker_char !== state.src.charCodeAt(start)) {\n        continue;\n      }\n\n      if (state.sCount[nextLine] - state.blkIndent >= 4) {\n        // closing fence should be indented less than 4 spaces\n        continue;\n      }\n\n      for (pos = start + 1; pos <= max; pos++) {\n        if (marker_str[(pos - start) % marker_len] !== state.src[pos]) {\n          break;\n        }\n      } // closing code fence must be at least as long as the opening one\n\n\n      if (Math.floor((pos - start) / marker_len) < marker_count) {\n        continue;\n      } // make sure tail has spaces only\n\n\n      pos -= (pos - start) % marker_len;\n      pos = state.skipSpaces(pos);\n\n      if (pos < max) {\n        continue;\n      } // found!\n\n\n      auto_closed = true;\n      break;\n    }\n\n    old_parent = state.parentType;\n    old_line_max = state.lineMax;\n    state.parentType = 'container'; // this will prevent lazy continuations from ever going past our end marker\n\n    state.lineMax = nextLine;\n    token = state.push('container_' + name + '_open', 'div', 1);\n    token.markup = markup;\n    token.block = true;\n    token.info = params;\n    token.map = [startLine, nextLine];\n    state.md.block.tokenize(state, startLine + 1, nextLine);\n    token = state.push('container_' + name + '_close', 'div', -1);\n    token.markup = state.src.slice(start, pos);\n    token.block = true;\n    state.parentType = old_parent;\n    state.lineMax = old_line_max;\n    state.line = nextLine + (auto_closed ? 1 : 0);\n    return true;\n  }\n\n  md.block.ruler.before('fence', 'container_' + name, container, {\n    alt: ['paragraph', 'reference', 'blockquote', 'list']\n  });\n  md.renderer.rules['container_' + name + '_open'] = render;\n  md.renderer.rules['container_' + name + '_close'] = render;\n};","map":{"version":3,"names":["module","exports","container_plugin","md","name","options","validateDefault","params","trim","split","renderDefault","tokens","idx","_options","env","slf","nesting","attrJoin","renderToken","min_markers","marker_str","marker","marker_char","charCodeAt","marker_len","length","validate","render","container","state","startLine","endLine","silent","pos","nextLine","marker_count","markup","token","old_parent","old_line_max","auto_closed","start","bMarks","tShift","max","eMarks","src","Math","floor","slice","sCount","blkIndent","skipSpaces","parentType","lineMax","push","block","info","map","tokenize","line","ruler","before","alt","renderer","rules"],"sources":["/Users/lord/Documents/Programmer/vue/VueProjects/cloudycraft-vue/blog-web/node_modules/markdown-it-container/index.js"],"sourcesContent":["// Process block-level custom containers\n//\n'use strict';\n\n\nmodule.exports = function container_plugin(md, name, options) {\n\n  // Second param may be useful if you decide\n  // to increase minimal allowed marker length\n  function validateDefault(params/*, markup*/) {\n    return params.trim().split(' ', 2)[0] === name;\n  }\n\n  function renderDefault(tokens, idx, _options, env, slf) {\n\n    // add a class to the opening tag\n    if (tokens[idx].nesting === 1) {\n      tokens[idx].attrJoin('class', name);\n    }\n\n    return slf.renderToken(tokens, idx, _options, env, slf);\n  }\n\n  options = options || {};\n\n  var min_markers = 3,\n      marker_str  = options.marker || ':',\n      marker_char = marker_str.charCodeAt(0),\n      marker_len  = marker_str.length,\n      validate    = options.validate || validateDefault,\n      render      = options.render || renderDefault;\n\n  function container(state, startLine, endLine, silent) {\n    var pos, nextLine, marker_count, markup, params, token,\n        old_parent, old_line_max,\n        auto_closed = false,\n        start = state.bMarks[startLine] + state.tShift[startLine],\n        max = state.eMarks[startLine];\n\n    // Check out the first character quickly,\n    // this should filter out most of non-containers\n    //\n    if (marker_char !== state.src.charCodeAt(start)) { return false; }\n\n    // Check out the rest of the marker string\n    //\n    for (pos = start + 1; pos <= max; pos++) {\n      if (marker_str[(pos - start) % marker_len] !== state.src[pos]) {\n        break;\n      }\n    }\n\n    marker_count = Math.floor((pos - start) / marker_len);\n    if (marker_count < min_markers) { return false; }\n    pos -= (pos - start) % marker_len;\n\n    markup = state.src.slice(start, pos);\n    params = state.src.slice(pos, max);\n    if (!validate(params, markup)) { return false; }\n\n    // Since start is found, we can report success here in validation mode\n    //\n    if (silent) { return true; }\n\n    // Search for the end of the block\n    //\n    nextLine = startLine;\n\n    for (;;) {\n      nextLine++;\n      if (nextLine >= endLine) {\n        // unclosed block should be autoclosed by end of document.\n        // also block seems to be autoclosed by end of parent\n        break;\n      }\n\n      start = state.bMarks[nextLine] + state.tShift[nextLine];\n      max = state.eMarks[nextLine];\n\n      if (start < max && state.sCount[nextLine] < state.blkIndent) {\n        // non-empty line with negative indent should stop the list:\n        // - ```\n        //  test\n        break;\n      }\n\n      if (marker_char !== state.src.charCodeAt(start)) { continue; }\n\n      if (state.sCount[nextLine] - state.blkIndent >= 4) {\n        // closing fence should be indented less than 4 spaces\n        continue;\n      }\n\n      for (pos = start + 1; pos <= max; pos++) {\n        if (marker_str[(pos - start) % marker_len] !== state.src[pos]) {\n          break;\n        }\n      }\n\n      // closing code fence must be at least as long as the opening one\n      if (Math.floor((pos - start) / marker_len) < marker_count) { continue; }\n\n      // make sure tail has spaces only\n      pos -= (pos - start) % marker_len;\n      pos = state.skipSpaces(pos);\n\n      if (pos < max) { continue; }\n\n      // found!\n      auto_closed = true;\n      break;\n    }\n\n    old_parent = state.parentType;\n    old_line_max = state.lineMax;\n    state.parentType = 'container';\n\n    // this will prevent lazy continuations from ever going past our end marker\n    state.lineMax = nextLine;\n\n    token        = state.push('container_' + name + '_open', 'div', 1);\n    token.markup = markup;\n    token.block  = true;\n    token.info   = params;\n    token.map    = [ startLine, nextLine ];\n\n    state.md.block.tokenize(state, startLine + 1, nextLine);\n\n    token        = state.push('container_' + name + '_close', 'div', -1);\n    token.markup = state.src.slice(start, pos);\n    token.block  = true;\n\n    state.parentType = old_parent;\n    state.lineMax = old_line_max;\n    state.line = nextLine + (auto_closed ? 1 : 0);\n\n    return true;\n  }\n\n  md.block.ruler.before('fence', 'container_' + name, container, {\n    alt: [ 'paragraph', 'reference', 'blockquote', 'list' ]\n  });\n  md.renderer.rules['container_' + name + '_open'] = render;\n  md.renderer.rules['container_' + name + '_close'] = render;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}