{"ast":null,"code":"import { createPopper } from '@popperjs/core';\nimport { get } from 'lodash-unified';\nimport escapeHtml from 'escape-html';\nimport '../../../utils/index.mjs';\nimport '../../../hooks/index.mjs';\nimport { hasOwn } from '@vue/shared';\nimport { useZIndex } from '../../../hooks/use-z-index/index.mjs';\nimport { off, on } from '../../../utils/dom/event.mjs';\n\nconst getCell = function (event) {\n  let cell = event.target;\n\n  while (cell && cell.tagName.toUpperCase() !== \"HTML\") {\n    if (cell.tagName.toUpperCase() === \"TD\") {\n      return cell;\n    }\n\n    cell = cell.parentNode;\n  }\n\n  return null;\n};\n\nconst isObject = function (obj) {\n  return obj !== null && typeof obj === \"object\";\n};\n\nconst orderBy = function (array, sortKey, reverse, sortMethod, sortBy) {\n  if (!sortKey && !sortMethod && (!sortBy || Array.isArray(sortBy) && !sortBy.length)) {\n    return array;\n  }\n\n  if (typeof reverse === \"string\") {\n    reverse = reverse === \"descending\" ? -1 : 1;\n  } else {\n    reverse = reverse && reverse < 0 ? -1 : 1;\n  }\n\n  const getKey = sortMethod ? null : function (value, index) {\n    if (sortBy) {\n      if (!Array.isArray(sortBy)) {\n        sortBy = [sortBy];\n      }\n\n      return sortBy.map(by => {\n        if (typeof by === \"string\") {\n          return get(value, by);\n        } else {\n          return by(value, index, array);\n        }\n      });\n    }\n\n    if (sortKey !== \"$key\") {\n      if (isObject(value) && \"$value\" in value) value = value.$value;\n    }\n\n    return [isObject(value) ? get(value, sortKey) : value];\n  };\n\n  const compare = function (a, b) {\n    if (sortMethod) {\n      return sortMethod(a.value, b.value);\n    }\n\n    for (let i = 0, len = a.key.length; i < len; i++) {\n      if (a.key[i] < b.key[i]) {\n        return -1;\n      }\n\n      if (a.key[i] > b.key[i]) {\n        return 1;\n      }\n    }\n\n    return 0;\n  };\n\n  return array.map((value, index) => {\n    return {\n      value,\n      index,\n      key: getKey ? getKey(value, index) : null\n    };\n  }).sort((a, b) => {\n    let order = compare(a, b);\n\n    if (!order) {\n      order = a.index - b.index;\n    }\n\n    return order * +reverse;\n  }).map(item => item.value);\n};\n\nconst getColumnById = function (table, columnId) {\n  let column = null;\n  table.columns.forEach(item => {\n    if (item.id === columnId) {\n      column = item;\n    }\n  });\n  return column;\n};\n\nconst getColumnByKey = function (table, columnKey) {\n  let column = null;\n\n  for (let i = 0; i < table.columns.length; i++) {\n    const item = table.columns[i];\n\n    if (item.columnKey === columnKey) {\n      column = item;\n      break;\n    }\n  }\n\n  return column;\n};\n\nconst getColumnByCell = function (table, cell, namespace) {\n  const matches = (cell.className || \"\").match(new RegExp(`${namespace}-table_[^\\\\s]+`, \"gm\"));\n\n  if (matches) {\n    return getColumnById(table, matches[0]);\n  }\n\n  return null;\n};\n\nconst getRowIdentity = (row, rowKey) => {\n  if (!row) throw new Error(\"Row is required when get row identity\");\n\n  if (typeof rowKey === \"string\") {\n    if (!rowKey.includes(\".\")) {\n      return `${row[rowKey]}`;\n    }\n\n    const key = rowKey.split(\".\");\n    let current = row;\n\n    for (const element of key) {\n      current = current[element];\n    }\n\n    return `${current}`;\n  } else if (typeof rowKey === \"function\") {\n    return rowKey.call(null, row);\n  }\n};\n\nconst getKeysMap = function (array, rowKey) {\n  const arrayMap = {};\n  (array || []).forEach((row, index) => {\n    arrayMap[getRowIdentity(row, rowKey)] = {\n      row,\n      index\n    };\n  });\n  return arrayMap;\n};\n\nfunction mergeOptions(defaults, config) {\n  const options = {};\n  let key;\n\n  for (key in defaults) {\n    options[key] = defaults[key];\n  }\n\n  for (key in config) {\n    if (hasOwn(config, key)) {\n      const value = config[key];\n\n      if (typeof value !== \"undefined\") {\n        options[key] = value;\n      }\n    }\n  }\n\n  return options;\n}\n\nfunction parseWidth(width) {\n  if (width === \"\") return width;\n\n  if (width !== void 0) {\n    width = Number.parseInt(width, 10);\n\n    if (Number.isNaN(width)) {\n      width = \"\";\n    }\n  }\n\n  return width;\n}\n\nfunction parseMinWidth(minWidth) {\n  if (minWidth === \"\") return minWidth;\n\n  if (minWidth !== void 0) {\n    minWidth = parseWidth(minWidth);\n\n    if (Number.isNaN(minWidth)) {\n      minWidth = 80;\n    }\n  }\n\n  return minWidth;\n}\n\nfunction parseHeight(height) {\n  if (typeof height === \"number\") {\n    return height;\n  }\n\n  if (typeof height === \"string\") {\n    if (/^\\d+(?:px)?$/.test(height)) {\n      return Number.parseInt(height, 10);\n    } else {\n      return height;\n    }\n  }\n\n  return null;\n}\n\nfunction compose(...funcs) {\n  if (funcs.length === 0) {\n    return arg => arg;\n  }\n\n  if (funcs.length === 1) {\n    return funcs[0];\n  }\n\n  return funcs.reduce((a, b) => (...args) => a(b(...args)));\n}\n\nfunction toggleRowStatus(statusArr, row, newVal) {\n  let changed = false;\n  const index = statusArr.indexOf(row);\n  const included = index !== -1;\n\n  const addRow = () => {\n    statusArr.push(row);\n    changed = true;\n  };\n\n  const removeRow = () => {\n    statusArr.splice(index, 1);\n    changed = true;\n  };\n\n  if (typeof newVal === \"boolean\") {\n    if (newVal && !included) {\n      addRow();\n    } else if (!newVal && included) {\n      removeRow();\n    }\n  } else {\n    if (included) {\n      removeRow();\n    } else {\n      addRow();\n    }\n  }\n\n  return changed;\n}\n\nfunction walkTreeNode(root, cb, childrenKey = \"children\", lazyKey = \"hasChildren\") {\n  const isNil = array => !(Array.isArray(array) && array.length);\n\n  function _walker(parent, children, level) {\n    cb(parent, children, level);\n    children.forEach(item => {\n      if (item[lazyKey]) {\n        cb(item, null, level + 1);\n        return;\n      }\n\n      const children2 = item[childrenKey];\n\n      if (!isNil(children2)) {\n        _walker(item, children2, level + 1);\n      }\n    });\n  }\n\n  root.forEach(item => {\n    if (item[lazyKey]) {\n      cb(item, null, 0);\n      return;\n    }\n\n    const children = item[childrenKey];\n\n    if (!isNil(children)) {\n      _walker(item, children, 0);\n    }\n  });\n}\n\nlet removePopper;\n\nfunction createTablePopper(parentNode, trigger, popperContent, popperOptions, tooltipEffect) {\n  const {\n    nextZIndex\n  } = useZIndex();\n  const ns = parentNode == null ? void 0 : parentNode.dataset.prefix;\n  const scrollContainer = parentNode == null ? void 0 : parentNode.querySelector(`.${ns}-scrollbar__wrap`);\n\n  function renderContent() {\n    const isLight = tooltipEffect === \"light\";\n    const content2 = document.createElement(\"div\");\n    content2.className = `${ns}-popper ${isLight ? \"is-light\" : \"is-dark\"}`;\n    popperContent = escapeHtml(popperContent);\n    content2.innerHTML = popperContent;\n    content2.style.zIndex = String(nextZIndex());\n    parentNode == null ? void 0 : parentNode.appendChild(content2);\n    return content2;\n  }\n\n  function renderArrow() {\n    const arrow2 = document.createElement(\"div\");\n    arrow2.className = `${ns}-popper__arrow`;\n    return arrow2;\n  }\n\n  function showPopper() {\n    popperInstance && popperInstance.update();\n  }\n\n  removePopper = () => {\n    try {\n      popperInstance && popperInstance.destroy();\n      content && (parentNode == null ? void 0 : parentNode.removeChild(content));\n      off(trigger, \"mouseenter\", showPopper);\n      off(trigger, \"mouseleave\", removePopper);\n\n      if (scrollContainer) {\n        off(scrollContainer, \"scroll\", removePopper);\n      }\n\n      removePopper = void 0;\n    } catch (e) {}\n  };\n\n  let popperInstance = null;\n  const content = renderContent();\n  const arrow = renderArrow();\n  content.appendChild(arrow);\n  popperInstance = createPopper(trigger, content, {\n    strategy: \"absolute\",\n    modifiers: [{\n      name: \"offset\",\n      options: {\n        offset: [0, 8]\n      }\n    }, {\n      name: \"arrow\",\n      options: {\n        element: arrow,\n        padding: 10\n      }\n    }],\n    ...popperOptions\n  });\n  on(trigger, \"mouseenter\", showPopper);\n  on(trigger, \"mouseleave\", removePopper);\n\n  if (scrollContainer) {\n    on(scrollContainer, \"scroll\", removePopper);\n  }\n\n  return popperInstance;\n}\n\nconst isFixedColumn = (index, fixed, store, realColumns) => {\n  let start = 0;\n  let after = index;\n\n  if (realColumns) {\n    if (realColumns[index].colSpan > 1) {\n      return {};\n    }\n\n    for (let i = 0; i < index; i++) {\n      start += realColumns[i].colSpan;\n    }\n\n    after = start + realColumns[index].colSpan - 1;\n  } else {\n    start = index;\n  }\n\n  let fixedLayout;\n  const columns = store.states.columns;\n\n  switch (fixed) {\n    case \"left\":\n      if (after < store.states.fixedLeafColumnsLength.value) {\n        fixedLayout = \"left\";\n      }\n\n      break;\n\n    case \"right\":\n      if (start >= columns.value.length - store.states.rightFixedLeafColumnsLength.value) {\n        fixedLayout = \"right\";\n      }\n\n      break;\n\n    default:\n      if (after < store.states.fixedLeafColumnsLength.value) {\n        fixedLayout = \"left\";\n      } else if (start >= columns.value.length - store.states.rightFixedLeafColumnsLength.value) {\n        fixedLayout = \"right\";\n      }\n\n  }\n\n  return fixedLayout ? {\n    direction: fixedLayout,\n    start,\n    after\n  } : {};\n};\n\nconst getFixedColumnsClass = (namespace, index, fixed, store, realColumns) => {\n  const classes = [];\n  const {\n    direction,\n    start\n  } = isFixedColumn(index, fixed, store, realColumns);\n\n  if (direction) {\n    const isLeft = direction === \"left\";\n    classes.push(`${namespace}-fixed-column--${direction}`);\n\n    if (isLeft && start === store.states.fixedLeafColumnsLength.value - 1) {\n      classes.push(\"is-last-column\");\n    } else if (!isLeft && start === store.states.columns.value.length - store.states.rightFixedLeafColumnsLength.value) {\n      classes.push(\"is-first-column\");\n    }\n  }\n\n  return classes;\n};\n\nfunction getOffset(offset, column) {\n  return offset + (column.realWidth === null || Number.isNaN(column.realWidth) ? Number(column.width) : column.realWidth);\n}\n\nconst getFixedColumnOffset = (index, fixed, store, realColumns) => {\n  const {\n    direction,\n    start = 0\n  } = isFixedColumn(index, fixed, store, realColumns);\n\n  if (!direction) {\n    return;\n  }\n\n  const styles = {};\n  const isLeft = direction === \"left\";\n  const columns = store.states.columns.value;\n\n  if (isLeft) {\n    styles.left = columns.slice(0, index).reduce(getOffset, 0);\n  } else {\n    styles.right = columns.slice(start + 1).reverse().reduce(getOffset, 0);\n  }\n\n  return styles;\n};\n\nconst ensurePosition = (style, key) => {\n  if (!style) return;\n\n  if (!Number.isNaN(style[key])) {\n    style[key] = `${style[key]}px`;\n  }\n};\n\nexport { compose, createTablePopper, ensurePosition, getCell, getColumnByCell, getColumnById, getColumnByKey, getFixedColumnOffset, getFixedColumnsClass, getKeysMap, getRowIdentity, isFixedColumn, mergeOptions, orderBy, parseHeight, parseMinWidth, parseWidth, removePopper, toggleRowStatus, walkTreeNode };","map":null,"metadata":{},"sourceType":"module"}