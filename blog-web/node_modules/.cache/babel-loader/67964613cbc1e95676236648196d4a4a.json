{"ast":null,"code":"const obtainAllFocusableElements = element => {\n  const nodes = [];\n  const walker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: node => {\n      const isHiddenInput = node.tagName === \"INPUT\" && node.type === \"hidden\";\n      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;\n      return node.tabIndex >= 0 || node === document.activeElement ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    }\n  });\n\n  while (walker.nextNode()) nodes.push(walker.currentNode);\n\n  return nodes;\n};\n\nconst getVisibleElement = (elements, container) => {\n  for (const element of elements) {\n    if (!isHidden(element, container)) return element;\n  }\n};\n\nconst isHidden = (element, container) => {\n  if (process.env.NODE_ENV === \"test\") return false;\n  if (getComputedStyle(element).visibility === \"hidden\") return true;\n\n  while (element) {\n    if (container && element === container) return false;\n    if (getComputedStyle(element).display === \"none\") return true;\n    element = element.parentElement;\n  }\n\n  return false;\n};\n\nconst getEdges = container => {\n  const focusable = obtainAllFocusableElements(container);\n  const first = getVisibleElement(focusable, container);\n  const last = getVisibleElement(focusable.reverse(), container);\n  return [first, last];\n};\n\nconst isSelectable = element => {\n  return element instanceof HTMLInputElement && \"select\" in element;\n};\n\nconst tryFocus = (element, shouldSelect) => {\n  if (element && element.focus) {\n    const prevFocusedElement = document.activeElement;\n    element.focus({\n      preventScroll: true\n    });\n\n    if (element !== prevFocusedElement && isSelectable(element) && shouldSelect) {\n      element.select();\n    }\n  }\n};\n\nfunction removeFromStack(list, item) {\n  const copy = [...list];\n  const idx = list.indexOf(item);\n\n  if (idx !== -1) {\n    copy.splice(idx, 1);\n  }\n\n  return copy;\n}\n\nconst createFocusableStack = () => {\n  let stack = [];\n\n  const push = layer => {\n    const currentLayer = stack[0];\n\n    if (currentLayer && layer !== currentLayer) {\n      currentLayer.pause();\n    }\n\n    stack = removeFromStack(stack, layer);\n    stack.unshift(layer);\n  };\n\n  const remove = layer => {\n    var _a, _b;\n\n    stack = removeFromStack(stack, layer);\n    (_b = (_a = stack[0]) == null ? void 0 : _a.resume) == null ? void 0 : _b.call(_a);\n  };\n\n  return {\n    push,\n    remove\n  };\n};\n\nconst focusFirstDescendant = (elements, shouldSelect = false) => {\n  const prevFocusedElement = document.activeElement;\n\n  for (const element of elements) {\n    tryFocus(element, shouldSelect);\n    if (document.activeElement !== prevFocusedElement) return;\n  }\n};\n\nconst focusableStack = createFocusableStack();\nexport { focusFirstDescendant, focusableStack, getEdges, getVisibleElement, isHidden, obtainAllFocusableElements, tryFocus };","map":null,"metadata":{},"sourceType":"module"}