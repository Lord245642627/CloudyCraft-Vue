{"ast":null,"code":"/* eslint no-var: off */\n\n/**\n * This file is responsible for parsing the content from the DOM and making\n * sure data is nested properly.\n *\n * @author Tim Scanlin\n */\nmodule.exports = function parseContent(options) {\n  var reduce = [].reduce;\n  /**\n   * Get the last item in an array and return a reference to it.\n   * @param {Array} array\n   * @return {Object}\n   */\n\n  function getLastItem(array) {\n    return array[array.length - 1];\n  }\n  /**\n   * Get heading level for a heading dom node.\n   * @param {HTMLElement} heading\n   * @return {Number}\n   */\n\n\n  function getHeadingLevel(heading) {\n    return +heading.nodeName.toUpperCase().replace('H', '');\n  }\n  /**\n   * Get important properties from a heading element and store in a plain object.\n   * @param {HTMLElement} heading\n   * @return {Object}\n   */\n\n\n  function getHeadingObject(heading) {\n    // each node is processed twice by this method because nestHeadingsArray() and addNode() calls it\n    // first time heading is real DOM node element, second time it is obj\n    // that is causing problem so I am processing only original DOM node\n    if (!(heading instanceof window.HTMLElement)) return heading;\n\n    if (options.ignoreHiddenElements && (!heading.offsetHeight || !heading.offsetParent)) {\n      return null;\n    }\n\n    const headingLabel = heading.getAttribute('data-heading-label') || (options.headingLabelCallback ? String(options.headingLabelCallback(heading.textContent)) : heading.textContent.trim());\n    var obj = {\n      id: heading.id,\n      children: [],\n      nodeName: heading.nodeName,\n      headingLevel: getHeadingLevel(heading),\n      textContent: headingLabel\n    };\n\n    if (options.includeHtml) {\n      obj.childNodes = heading.childNodes;\n    }\n\n    if (options.headingObjectCallback) {\n      return options.headingObjectCallback(obj, heading);\n    }\n\n    return obj;\n  }\n  /**\n   * Add a node to the nested array.\n   * @param {Object} node\n   * @param {Array} nest\n   * @return {Array}\n   */\n\n\n  function addNode(node, nest) {\n    var obj = getHeadingObject(node);\n    var level = obj.headingLevel;\n    var array = nest;\n    var lastItem = getLastItem(array);\n    var lastItemLevel = lastItem ? lastItem.headingLevel : 0;\n    var counter = level - lastItemLevel;\n\n    while (counter > 0) {\n      lastItem = getLastItem(array); // Handle case where there are multiple h5+ in a row.\n\n      if (lastItem && level === lastItem.headingLevel) {\n        break;\n      } else if (lastItem && lastItem.children !== undefined) {\n        array = lastItem.children;\n      }\n\n      counter--;\n    }\n\n    if (level >= options.collapseDepth) {\n      obj.isCollapsed = true;\n    }\n\n    array.push(obj);\n    return array;\n  }\n  /**\n   * Select headings in content area, exclude any selector in options.ignoreSelector\n   * @param {HTMLElement} contentElement\n   * @param {Array} headingSelector\n   * @return {Array}\n   */\n\n\n  function selectHeadings(contentElement, headingSelector) {\n    var selectors = headingSelector;\n\n    if (options.ignoreSelector) {\n      selectors = headingSelector.split(',').map(function mapSelectors(selector) {\n        return selector.trim() + ':not(' + options.ignoreSelector + ')';\n      });\n    }\n\n    try {\n      return contentElement.querySelectorAll(selectors);\n    } catch (e) {\n      console.warn('Headers not found with selector: ' + selectors); // eslint-disable-line\n\n      return null;\n    }\n  }\n  /**\n   * Nest headings array into nested arrays with 'children' property.\n   * @param {Array} headingsArray\n   * @return {Object}\n   */\n\n\n  function nestHeadingsArray(headingsArray) {\n    return reduce.call(headingsArray, function reducer(prev, curr) {\n      var currentHeading = getHeadingObject(curr);\n\n      if (currentHeading) {\n        addNode(currentHeading, prev.nest);\n      }\n\n      return prev;\n    }, {\n      nest: []\n    });\n  }\n\n  return {\n    nestHeadingsArray: nestHeadingsArray,\n    selectHeadings: selectHeadings\n  };\n};","map":{"version":3,"names":["module","exports","parseContent","options","reduce","getLastItem","array","length","getHeadingLevel","heading","nodeName","toUpperCase","replace","getHeadingObject","window","HTMLElement","ignoreHiddenElements","offsetHeight","offsetParent","headingLabel","getAttribute","headingLabelCallback","String","textContent","trim","obj","id","children","headingLevel","includeHtml","childNodes","headingObjectCallback","addNode","node","nest","level","lastItem","lastItemLevel","counter","undefined","collapseDepth","isCollapsed","push","selectHeadings","contentElement","headingSelector","selectors","ignoreSelector","split","map","mapSelectors","selector","querySelectorAll","e","console","warn","nestHeadingsArray","headingsArray","call","reducer","prev","curr","currentHeading"],"sources":["/Users/lord/Documents/Programmer/vue/VueProjects/cloudycraft-vue/blog-web/node_modules/tocbot/src/js/parse-content.js"],"sourcesContent":["/* eslint no-var: off */\n/**\n * This file is responsible for parsing the content from the DOM and making\n * sure data is nested properly.\n *\n * @author Tim Scanlin\n */\n\nmodule.exports = function parseContent (options) {\n  var reduce = [].reduce\n\n  /**\n   * Get the last item in an array and return a reference to it.\n   * @param {Array} array\n   * @return {Object}\n   */\n  function getLastItem (array) {\n    return array[array.length - 1]\n  }\n\n  /**\n   * Get heading level for a heading dom node.\n   * @param {HTMLElement} heading\n   * @return {Number}\n   */\n  function getHeadingLevel (heading) {\n    return +heading.nodeName.toUpperCase().replace('H', '')\n  }\n\n  /**\n   * Get important properties from a heading element and store in a plain object.\n   * @param {HTMLElement} heading\n   * @return {Object}\n   */\n  function getHeadingObject (heading) {\n    // each node is processed twice by this method because nestHeadingsArray() and addNode() calls it\n    // first time heading is real DOM node element, second time it is obj\n    // that is causing problem so I am processing only original DOM node\n    if (!(heading instanceof window.HTMLElement)) return heading\n\n    if (options.ignoreHiddenElements && (!heading.offsetHeight || !heading.offsetParent)) {\n      return null\n    }\n\n    const headingLabel = heading.getAttribute('data-heading-label') ||\n      (options.headingLabelCallback ? String(options.headingLabelCallback(heading.textContent)) : heading.textContent.trim())\n    var obj = {\n      id: heading.id,\n      children: [],\n      nodeName: heading.nodeName,\n      headingLevel: getHeadingLevel(heading),\n      textContent: headingLabel\n    }\n\n    if (options.includeHtml) {\n      obj.childNodes = heading.childNodes\n    }\n\n    if (options.headingObjectCallback) {\n      return options.headingObjectCallback(obj, heading)\n    }\n\n    return obj\n  }\n\n  /**\n   * Add a node to the nested array.\n   * @param {Object} node\n   * @param {Array} nest\n   * @return {Array}\n   */\n  function addNode (node, nest) {\n    var obj = getHeadingObject(node)\n    var level = obj.headingLevel\n    var array = nest\n    var lastItem = getLastItem(array)\n    var lastItemLevel = lastItem\n      ? lastItem.headingLevel\n      : 0\n    var counter = level - lastItemLevel\n\n    while (counter > 0) {\n      lastItem = getLastItem(array)\n      // Handle case where there are multiple h5+ in a row.\n      if (lastItem && level === lastItem.headingLevel) {\n        break\n      } else if (lastItem && lastItem.children !== undefined) {\n        array = lastItem.children\n      }\n      counter--\n    }\n\n    if (level >= options.collapseDepth) {\n      obj.isCollapsed = true\n    }\n\n    array.push(obj)\n    return array\n  }\n\n  /**\n   * Select headings in content area, exclude any selector in options.ignoreSelector\n   * @param {HTMLElement} contentElement\n   * @param {Array} headingSelector\n   * @return {Array}\n   */\n  function selectHeadings (contentElement, headingSelector) {\n    var selectors = headingSelector\n    if (options.ignoreSelector) {\n      selectors = headingSelector.split(',')\n        .map(function mapSelectors (selector) {\n          return selector.trim() + ':not(' + options.ignoreSelector + ')'\n        })\n    }\n    try {\n      return contentElement.querySelectorAll(selectors)\n    } catch (e) {\n      console.warn('Headers not found with selector: ' + selectors); // eslint-disable-line\n      return null\n    }\n  }\n\n  /**\n   * Nest headings array into nested arrays with 'children' property.\n   * @param {Array} headingsArray\n   * @return {Object}\n   */\n  function nestHeadingsArray (headingsArray) {\n    return reduce.call(headingsArray, function reducer (prev, curr) {\n      var currentHeading = getHeadingObject(curr)\n      if (currentHeading) {\n        addNode(currentHeading, prev.nest)\n      }\n      return prev\n    }, {\n      nest: []\n    })\n  }\n\n  return {\n    nestHeadingsArray: nestHeadingsArray,\n    selectHeadings: selectHeadings\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}