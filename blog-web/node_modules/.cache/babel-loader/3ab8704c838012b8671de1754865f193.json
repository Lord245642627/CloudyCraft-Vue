{"ast":null,"code":"// Process block-level custom containers\n//\n'use strict';\n\nmodule.exports = function container_plugin(md, name, options) {\n  // Second param may be useful if you decide\n  // to increase minimal allowed marker length\n  function validateDefault(params\n  /*, markup*/\n  ) {\n    return params.trim().split(' ', 2)[0] === name;\n  }\n\n  function renderDefault(tokens, idx, _options, env, slf) {\n    // add a class to the opening tag\n    if (tokens[idx].nesting === 1) {\n      tokens[idx].attrJoin('class', name);\n    }\n\n    return slf.renderToken(tokens, idx, _options, env, slf);\n  }\n\n  options = options || {};\n  var min_markers = 3,\n      marker_str = options.marker || ':',\n      marker_char = marker_str.charCodeAt(0),\n      marker_len = marker_str.length,\n      validate = options.validate || validateDefault,\n      render = options.render || renderDefault;\n\n  function container(state, startLine, endLine, silent) {\n    var pos,\n        nextLine,\n        marker_count,\n        markup,\n        params,\n        token,\n        old_parent,\n        old_line_max,\n        auto_closed = false,\n        start = state.bMarks[startLine] + state.tShift[startLine],\n        max = state.eMarks[startLine]; // Check out the first character quickly,\n    // this should filter out most of non-containers\n    //\n\n    if (marker_char !== state.src.charCodeAt(start)) {\n      return false;\n    } // Check out the rest of the marker string\n    //\n\n\n    for (pos = start + 1; pos <= max; pos++) {\n      if (marker_str[(pos - start) % marker_len] !== state.src[pos]) {\n        break;\n      }\n    }\n\n    marker_count = Math.floor((pos - start) / marker_len);\n\n    if (marker_count < min_markers) {\n      return false;\n    }\n\n    pos -= (pos - start) % marker_len;\n    markup = state.src.slice(start, pos);\n    params = state.src.slice(pos, max);\n\n    if (!validate(params, markup)) {\n      return false;\n    } // Since start is found, we can report success here in validation mode\n    //\n\n\n    if (silent) {\n      return true;\n    } // Search for the end of the block\n    //\n\n\n    nextLine = startLine;\n\n    for (;;) {\n      nextLine++;\n\n      if (nextLine >= endLine) {\n        // unclosed block should be autoclosed by end of document.\n        // also block seems to be autoclosed by end of parent\n        break;\n      }\n\n      start = state.bMarks[nextLine] + state.tShift[nextLine];\n      max = state.eMarks[nextLine];\n\n      if (start < max && state.sCount[nextLine] < state.blkIndent) {\n        // non-empty line with negative indent should stop the list:\n        // - ```\n        //  test\n        break;\n      }\n\n      if (marker_char !== state.src.charCodeAt(start)) {\n        continue;\n      }\n\n      if (state.sCount[nextLine] - state.blkIndent >= 4) {\n        // closing fence should be indented less than 4 spaces\n        continue;\n      }\n\n      for (pos = start + 1; pos <= max; pos++) {\n        if (marker_str[(pos - start) % marker_len] !== state.src[pos]) {\n          break;\n        }\n      } // closing code fence must be at least as long as the opening one\n\n\n      if (Math.floor((pos - start) / marker_len) < marker_count) {\n        continue;\n      } // make sure tail has spaces only\n\n\n      pos -= (pos - start) % marker_len;\n      pos = state.skipSpaces(pos);\n\n      if (pos < max) {\n        continue;\n      } // found!\n\n\n      auto_closed = true;\n      break;\n    }\n\n    old_parent = state.parentType;\n    old_line_max = state.lineMax;\n    state.parentType = 'container'; // this will prevent lazy continuations from ever going past our end marker\n\n    state.lineMax = nextLine;\n    token = state.push('container_' + name + '_open', 'div', 1);\n    token.markup = markup;\n    token.block = true;\n    token.info = params;\n    token.map = [startLine, nextLine];\n    state.md.block.tokenize(state, startLine + 1, nextLine);\n    token = state.push('container_' + name + '_close', 'div', -1);\n    token.markup = state.src.slice(start, pos);\n    token.block = true;\n    state.parentType = old_parent;\n    state.lineMax = old_line_max;\n    state.line = nextLine + (auto_closed ? 1 : 0);\n    return true;\n  }\n\n  md.block.ruler.before('fence', 'container_' + name, container, {\n    alt: ['paragraph', 'reference', 'blockquote', 'list']\n  });\n  md.renderer.rules['container_' + name + '_open'] = render;\n  md.renderer.rules['container_' + name + '_close'] = render;\n};","map":null,"metadata":{},"sourceType":"script"}