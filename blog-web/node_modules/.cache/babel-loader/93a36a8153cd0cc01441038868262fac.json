{"ast":null,"code":"import * as _ from 'lodash-es';\nimport { Graph } from '../../graphlib/index.js';\nexport { buildLayerGraph };\n/*\n * Constructs a graph that can be used to sort a layer of nodes. The graph will\n * contain all base and subgraph nodes from the request layer in their original\n * hierarchy and any edges that are incident on these nodes and are of the type\n * requested by the \"relationship\" parameter.\n *\n * Nodes from the requested rank that do not have parents are assigned a root\n * node in the output graph, which is set in the root graph attribute. This\n * makes it easy to walk the hierarchy of movable nodes during ordering.\n *\n * Pre-conditions:\n *\n *    1. Input graph is a DAG\n *    2. Base nodes in the input graph have a rank attribute\n *    3. Subgraph nodes in the input graph has minRank and maxRank attributes\n *    4. Edges have an assigned weight\n *\n * Post-conditions:\n *\n *    1. Output graph has all nodes in the movable rank with preserved\n *       hierarchy.\n *    2. Root nodes in the movable layer are made children of the node\n *       indicated by the root attribute of the graph.\n *    3. Non-movable nodes incident on movable nodes, selected by the\n *       relationship parameter, are included in the graph (without hierarchy).\n *    4. Edges incident on movable nodes, selected by the relationship\n *       parameter, are added to the output graph.\n *    5. The weights for copied edges are aggregated as need, since the output\n *       graph is not a multi-graph.\n */\n\nfunction buildLayerGraph(g, rank, relationship) {\n  var root = createRootNode(g),\n      result = new Graph({\n    compound: true\n  }).setGraph({\n    root: root\n  }).setDefaultNodeLabel(function (v) {\n    return g.node(v);\n  });\n\n  _.forEach(g.nodes(), function (v) {\n    var node = g.node(v),\n        parent = g.parent(v);\n\n    if (node.rank === rank || node.minRank <= rank && rank <= node.maxRank) {\n      result.setNode(v);\n      result.setParent(v, parent || root); // This assumes we have only short edges!\n\n      _.forEach(g[relationship](v), function (e) {\n        var u = e.v === v ? e.w : e.v,\n            edge = result.edge(u, v),\n            weight = !_.isUndefined(edge) ? edge.weight : 0;\n        result.setEdge(u, v, {\n          weight: g.edge(e).weight + weight\n        });\n      });\n\n      if (_.has(node, 'minRank')) {\n        result.setNode(v, {\n          borderLeft: node.borderLeft[rank],\n          borderRight: node.borderRight[rank]\n        });\n      }\n    }\n  });\n\n  return result;\n}\n\nfunction createRootNode(g) {\n  var v;\n\n  while (g.hasNode(v = _.uniqueId('_root')));\n\n  return v;\n}","map":{"version":3,"names":["_","Graph","buildLayerGraph","g","rank","relationship","root","createRootNode","result","compound","setGraph","setDefaultNodeLabel","v","node","forEach","nodes","parent","minRank","maxRank","setNode","setParent","e","u","w","edge","weight","isUndefined","setEdge","has","borderLeft","borderRight","hasNode","uniqueId"],"sources":["/Users/lord/Documents/Programmer/vue/VueProjects/blog-vue/blog-web/node_modules/dagre-d3-es/src/dagre/order/build-layer-graph.js"],"sourcesContent":["import * as _ from 'lodash-es';\nimport { Graph } from '../../graphlib/index.js';\n\nexport { buildLayerGraph };\n\n/*\n * Constructs a graph that can be used to sort a layer of nodes. The graph will\n * contain all base and subgraph nodes from the request layer in their original\n * hierarchy and any edges that are incident on these nodes and are of the type\n * requested by the \"relationship\" parameter.\n *\n * Nodes from the requested rank that do not have parents are assigned a root\n * node in the output graph, which is set in the root graph attribute. This\n * makes it easy to walk the hierarchy of movable nodes during ordering.\n *\n * Pre-conditions:\n *\n *    1. Input graph is a DAG\n *    2. Base nodes in the input graph have a rank attribute\n *    3. Subgraph nodes in the input graph has minRank and maxRank attributes\n *    4. Edges have an assigned weight\n *\n * Post-conditions:\n *\n *    1. Output graph has all nodes in the movable rank with preserved\n *       hierarchy.\n *    2. Root nodes in the movable layer are made children of the node\n *       indicated by the root attribute of the graph.\n *    3. Non-movable nodes incident on movable nodes, selected by the\n *       relationship parameter, are included in the graph (without hierarchy).\n *    4. Edges incident on movable nodes, selected by the relationship\n *       parameter, are added to the output graph.\n *    5. The weights for copied edges are aggregated as need, since the output\n *       graph is not a multi-graph.\n */\nfunction buildLayerGraph(g, rank, relationship) {\n  var root = createRootNode(g),\n    result = new Graph({ compound: true })\n      .setGraph({ root: root })\n      .setDefaultNodeLabel(function (v) {\n        return g.node(v);\n      });\n\n  _.forEach(g.nodes(), function (v) {\n    var node = g.node(v),\n      parent = g.parent(v);\n\n    if (node.rank === rank || (node.minRank <= rank && rank <= node.maxRank)) {\n      result.setNode(v);\n      result.setParent(v, parent || root);\n\n      // This assumes we have only short edges!\n      _.forEach(g[relationship](v), function (e) {\n        var u = e.v === v ? e.w : e.v,\n          edge = result.edge(u, v),\n          weight = !_.isUndefined(edge) ? edge.weight : 0;\n        result.setEdge(u, v, { weight: g.edge(e).weight + weight });\n      });\n\n      if (_.has(node, 'minRank')) {\n        result.setNode(v, {\n          borderLeft: node.borderLeft[rank],\n          borderRight: node.borderRight[rank],\n        });\n      }\n    }\n  });\n\n  return result;\n}\n\nfunction createRootNode(g) {\n  var v;\n  while (g.hasNode((v = _.uniqueId('_root'))));\n  return v;\n}\n"],"mappings":"AAAA,OAAO,KAAKA,CAAZ,MAAmB,WAAnB;AACA,SAASC,KAAT,QAAsB,yBAAtB;AAEA,SAASC,eAAT;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASA,eAAT,CAAyBC,CAAzB,EAA4BC,IAA5B,EAAkCC,YAAlC,EAAgD;EAC9C,IAAIC,IAAI,GAAGC,cAAc,CAACJ,CAAD,CAAzB;EAAA,IACEK,MAAM,GAAG,IAAIP,KAAJ,CAAU;IAAEQ,QAAQ,EAAE;EAAZ,CAAV,EACNC,QADM,CACG;IAAEJ,IAAI,EAAEA;EAAR,CADH,EAENK,mBAFM,CAEc,UAAUC,CAAV,EAAa;IAChC,OAAOT,CAAC,CAACU,IAAF,CAAOD,CAAP,CAAP;EACD,CAJM,CADX;;EAOAZ,CAAC,CAACc,OAAF,CAAUX,CAAC,CAACY,KAAF,EAAV,EAAqB,UAAUH,CAAV,EAAa;IAChC,IAAIC,IAAI,GAAGV,CAAC,CAACU,IAAF,CAAOD,CAAP,CAAX;IAAA,IACEI,MAAM,GAAGb,CAAC,CAACa,MAAF,CAASJ,CAAT,CADX;;IAGA,IAAIC,IAAI,CAACT,IAAL,KAAcA,IAAd,IAAuBS,IAAI,CAACI,OAAL,IAAgBb,IAAhB,IAAwBA,IAAI,IAAIS,IAAI,CAACK,OAAhE,EAA0E;MACxEV,MAAM,CAACW,OAAP,CAAeP,CAAf;MACAJ,MAAM,CAACY,SAAP,CAAiBR,CAAjB,EAAoBI,MAAM,IAAIV,IAA9B,EAFwE,CAIxE;;MACAN,CAAC,CAACc,OAAF,CAAUX,CAAC,CAACE,YAAD,CAAD,CAAgBO,CAAhB,CAAV,EAA8B,UAAUS,CAAV,EAAa;QACzC,IAAIC,CAAC,GAAGD,CAAC,CAACT,CAAF,KAAQA,CAAR,GAAYS,CAAC,CAACE,CAAd,GAAkBF,CAAC,CAACT,CAA5B;QAAA,IACEY,IAAI,GAAGhB,MAAM,CAACgB,IAAP,CAAYF,CAAZ,EAAeV,CAAf,CADT;QAAA,IAEEa,MAAM,GAAG,CAACzB,CAAC,CAAC0B,WAAF,CAAcF,IAAd,CAAD,GAAuBA,IAAI,CAACC,MAA5B,GAAqC,CAFhD;QAGAjB,MAAM,CAACmB,OAAP,CAAeL,CAAf,EAAkBV,CAAlB,EAAqB;UAAEa,MAAM,EAAEtB,CAAC,CAACqB,IAAF,CAAOH,CAAP,EAAUI,MAAV,GAAmBA;QAA7B,CAArB;MACD,CALD;;MAOA,IAAIzB,CAAC,CAAC4B,GAAF,CAAMf,IAAN,EAAY,SAAZ,CAAJ,EAA4B;QAC1BL,MAAM,CAACW,OAAP,CAAeP,CAAf,EAAkB;UAChBiB,UAAU,EAAEhB,IAAI,CAACgB,UAAL,CAAgBzB,IAAhB,CADI;UAEhB0B,WAAW,EAAEjB,IAAI,CAACiB,WAAL,CAAiB1B,IAAjB;QAFG,CAAlB;MAID;IACF;EACF,CAvBD;;EAyBA,OAAOI,MAAP;AACD;;AAED,SAASD,cAAT,CAAwBJ,CAAxB,EAA2B;EACzB,IAAIS,CAAJ;;EACA,OAAOT,CAAC,CAAC4B,OAAF,CAAWnB,CAAC,GAAGZ,CAAC,CAACgC,QAAF,CAAW,OAAX,CAAf,CAAP,CAA4C;;EAC5C,OAAOpB,CAAP;AACD"},"metadata":{},"sourceType":"module"}