{"ast":null,"code":"import { isVNode, render, createVNode } from 'vue';\nimport { isClient, isNumber } from '@vueuse/core';\nimport '../../../utils/index.mjs';\nimport '../../../hooks/index.mjs';\nimport { messageConfig } from '../../config-provider/src/config-provider.mjs';\nimport MessageConstructor from './message2.mjs';\nimport { messageDefaults, messageTypes } from './message.mjs';\nimport { instances } from './instance.mjs';\nimport { isString, isFunction } from '@vue/shared';\nimport { isElement } from '../../../utils/types.mjs';\nimport { debugWarn } from '../../../utils/error.mjs';\nimport { useZIndex } from '../../../hooks/use-z-index/index.mjs';\nlet seed = 1;\n\nconst normalizeOptions = params => {\n  const options = !params || isString(params) || isVNode(params) || isFunction(params) ? {\n    message: params\n  } : params;\n  const normalized = { ...messageDefaults,\n    ...options\n  };\n\n  if (isString(normalized.appendTo)) {\n    let appendTo = document.querySelector(normalized.appendTo);\n\n    if (!isElement(appendTo)) {\n      debugWarn(\"ElMessage\", \"the appendTo option is not an HTMLElement. Falling back to document.body.\");\n      appendTo = document.body;\n    }\n\n    normalized.appendTo = appendTo;\n  }\n\n  return normalized;\n};\n\nconst closeMessage = instance => {\n  const idx = instances.indexOf(instance);\n  if (idx === -1) return;\n  instances.splice(idx, 1);\n  const {\n    handler\n  } = instance;\n  handler.close();\n};\n\nconst createMessage = ({\n  appendTo,\n  ...options\n}, context) => {\n  const {\n    nextZIndex\n  } = useZIndex();\n  const id = `message_${seed++}`;\n  const userOnClose = options.onClose;\n  const container = document.createElement(\"div\");\n  const props = { ...options,\n    zIndex: nextZIndex() + options.zIndex,\n    id,\n    onClose: () => {\n      userOnClose == null ? void 0 : userOnClose();\n      closeMessage(instance);\n    },\n    onDestroy: () => {\n      render(null, container);\n    }\n  };\n  const vnode = createVNode(MessageConstructor, props, isFunction(props.message) || isVNode(props.message) ? {\n    default: props.message\n  } : null);\n  vnode.appContext = context || message._context;\n  render(vnode, container);\n  appendTo.appendChild(container.firstElementChild);\n  const vm = vnode.component;\n  const handler = {\n    close: () => {\n      vm.exposeProxy.visible = false;\n    }\n  };\n  const instance = {\n    id,\n    vnode,\n    vm,\n    handler,\n    props: vnode.component.props\n  };\n  return instance;\n};\n\nconst message = (options = {}, context) => {\n  if (!isClient) return {\n    close: () => void 0\n  };\n\n  if (isNumber(messageConfig.max) && instances.length >= messageConfig.max) {\n    return {\n      close: () => void 0\n    };\n  }\n\n  const normalized = normalizeOptions(options);\n\n  if (normalized.grouping && instances.length) {\n    const instance2 = instances.find(({\n      vnode: vm\n    }) => {\n      var _a;\n\n      return ((_a = vm.props) == null ? void 0 : _a.message) === normalized.message;\n    });\n\n    if (instance2) {\n      instance2.props.repeatNum += 1;\n      instance2.props.type = normalized.type;\n      return instance2.handler;\n    }\n  }\n\n  const instance = createMessage(normalized, context);\n  instances.push(instance);\n  return instance.handler;\n};\n\nmessageTypes.forEach(type => {\n  message[type] = (options = {}, appContext) => {\n    const normalized = normalizeOptions(options);\n    return message({ ...normalized,\n      type\n    }, appContext);\n  };\n});\n\nfunction closeAll(type) {\n  for (const instance of instances) {\n    if (!type || type === instance.props.type) {\n      instance.handler.close();\n    }\n  }\n}\n\nmessage.closeAll = closeAll;\nmessage._context = null;\nexport { closeAll, message as default };","map":null,"metadata":{},"sourceType":"module"}